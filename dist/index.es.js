var jm = Object.defineProperty;
var Mm = (e, t, r) => t in e ? jm(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Kr = (e, t, r) => Mm(e, typeof t != "symbol" ? t + "" : t, r);
import * as be from "react";
import qt, { createContext as bi, useState as Rt, useCallback as ft, useContext as mo, useLayoutEffect as Fm, useEffect as Xt, forwardRef as Dm, Children as Bm, isValidElement as la, cloneElement as ca, useMemo as kt, useRef as xr } from "react";
import { Vector3 as Qe, Box3 as An, Color as up, Quaternion as fp, DoubleSide as $m, Raycaster as Um, Vector2 as qo, Plane as Ou, Matrix4 as dp, Points as Ms } from "three";
import { Box as zm, Points as Hm, MapControls as Wm, Grid as Vm, GizmoHelper as Zm, GizmoViewport as qm, PivotControls as Ym, Line as Fs, Html as Gm } from "@react-three/drei";
import { useFrame as ac, Canvas as Km, useThree as sc } from "@react-three/fiber";
import * as Xm from "react-dom";
import Mi from "react-dom";
var Yt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Qm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Fi = { exports: {} }, ko = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Au;
function Jm() {
  if (Au) return ko;
  Au = 1;
  var e = qt, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, c, p) {
    var l, d = {}, u = null, h = null;
    p !== void 0 && (u = "" + p), c.key !== void 0 && (u = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (l in c) o.call(c, l) && !i.hasOwnProperty(l) && (d[l] = c[l]);
    if (s && s.defaultProps) for (l in c = s.defaultProps, c) d[l] === void 0 && (d[l] = c[l]);
    return { $$typeof: t, type: s, key: u, ref: h, props: d, _owner: n.current };
  }
  return ko.Fragment = r, ko.jsx = a, ko.jsxs = a, ko;
}
var Co = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ku;
function eg() {
  return ku || (ku = 1, process.env.NODE_ENV !== "production" && function() {
    var e = qt, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function b(ie) {
      if (ie === null || typeof ie != "object")
        return null;
      var Se = y && ie[y] || ie[f];
      return typeof Se == "function" ? Se : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function x(ie) {
      {
        for (var Se = arguments.length, ke = new Array(Se > 1 ? Se - 1 : 0), Ve = 1; Ve < Se; Ve++)
          ke[Ve - 1] = arguments[Ve];
        E("error", ie, ke);
      }
    }
    function E(ie, Se, ke) {
      {
        var Ve = w.ReactDebugCurrentFrame, Ke = Ve.getStackAddendum();
        Ke !== "" && (Se += "%s", ke = ke.concat([Ke]));
        var Be = ke.map(function($e) {
          return String($e);
        });
        Be.unshift("Warning: " + Se), Function.prototype.apply.call(console[ie], console, Be);
      }
    }
    var T = !1, C = !1, R = !1, A = !1, j = !1, N;
    N = Symbol.for("react.module.reference");
    function O(ie) {
      return !!(typeof ie == "string" || typeof ie == "function" || ie === o || ie === i || j || ie === n || ie === p || ie === l || A || ie === h || T || C || R || typeof ie == "object" && ie !== null && (ie.$$typeof === u || ie.$$typeof === d || ie.$$typeof === a || ie.$$typeof === s || ie.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ie.$$typeof === N || ie.getModuleId !== void 0));
    }
    function D(ie, Se, ke) {
      var Ve = ie.displayName;
      if (Ve)
        return Ve;
      var Ke = Se.displayName || Se.name || "";
      return Ke !== "" ? ke + "(" + Ke + ")" : ke;
    }
    function H(ie) {
      return ie.displayName || "Context";
    }
    function G(ie) {
      if (ie == null)
        return null;
      if (typeof ie.tag == "number" && x("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ie == "function")
        return ie.displayName || ie.name || null;
      if (typeof ie == "string")
        return ie;
      switch (ie) {
        case o:
          return "Fragment";
        case r:
          return "Portal";
        case i:
          return "Profiler";
        case n:
          return "StrictMode";
        case p:
          return "Suspense";
        case l:
          return "SuspenseList";
      }
      if (typeof ie == "object")
        switch (ie.$$typeof) {
          case s:
            var Se = ie;
            return H(Se) + ".Consumer";
          case a:
            var ke = ie;
            return H(ke._context) + ".Provider";
          case c:
            return D(ie, ie.render, "ForwardRef");
          case d:
            var Ve = ie.displayName || null;
            return Ve !== null ? Ve : G(ie.type) || "Memo";
          case u: {
            var Ke = ie, Be = Ke._payload, $e = Ke._init;
            try {
              return G($e(Be));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var X = Object.assign, Q = 0, M, k, $, ne, te, de, ae;
    function z() {
    }
    z.__reactDisabledLog = !0;
    function Z() {
      {
        if (Q === 0) {
          M = console.log, k = console.info, $ = console.warn, ne = console.error, te = console.group, de = console.groupCollapsed, ae = console.groupEnd;
          var ie = {
            configurable: !0,
            enumerable: !0,
            value: z,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ie,
            log: ie,
            warn: ie,
            error: ie,
            group: ie,
            groupCollapsed: ie,
            groupEnd: ie
          });
        }
        Q++;
      }
    }
    function oe() {
      {
        if (Q--, Q === 0) {
          var ie = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: X({}, ie, {
              value: M
            }),
            info: X({}, ie, {
              value: k
            }),
            warn: X({}, ie, {
              value: $
            }),
            error: X({}, ie, {
              value: ne
            }),
            group: X({}, ie, {
              value: te
            }),
            groupCollapsed: X({}, ie, {
              value: de
            }),
            groupEnd: X({}, ie, {
              value: ae
            })
          });
        }
        Q < 0 && x("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ye = w.ReactCurrentDispatcher, V;
    function q(ie, Se, ke) {
      {
        if (V === void 0)
          try {
            throw Error();
          } catch (Ke) {
            var Ve = Ke.stack.trim().match(/\n( *(at )?)/);
            V = Ve && Ve[1] || "";
          }
        return `
` + V + ie;
      }
    }
    var ee = !1, ue;
    {
      var ge = typeof WeakMap == "function" ? WeakMap : Map;
      ue = new ge();
    }
    function he(ie, Se) {
      if (!ie || ee)
        return "";
      {
        var ke = ue.get(ie);
        if (ke !== void 0)
          return ke;
      }
      var Ve;
      ee = !0;
      var Ke = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Be;
      Be = ye.current, ye.current = null, Z();
      try {
        if (Se) {
          var $e = function() {
            throw Error();
          };
          if (Object.defineProperty($e.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct($e, []);
            } catch (nr) {
              Ve = nr;
            }
            Reflect.construct(ie, [], $e);
          } else {
            try {
              $e.call();
            } catch (nr) {
              Ve = nr;
            }
            ie.call($e.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nr) {
            Ve = nr;
          }
          ie();
        }
      } catch (nr) {
        if (nr && Ve && typeof nr.stack == "string") {
          for (var He = nr.stack.split(`
`), et = Ve.stack.split(`
`), Xe = He.length - 1, ct = et.length - 1; Xe >= 1 && ct >= 0 && He[Xe] !== et[ct]; )
            ct--;
          for (; Xe >= 1 && ct >= 0; Xe--, ct--)
            if (He[Xe] !== et[ct]) {
              if (Xe !== 1 || ct !== 1)
                do
                  if (Xe--, ct--, ct < 0 || He[Xe] !== et[ct]) {
                    var zt = `
` + He[Xe].replace(" at new ", " at ");
                    return ie.displayName && zt.includes("<anonymous>") && (zt = zt.replace("<anonymous>", ie.displayName)), typeof ie == "function" && ue.set(ie, zt), zt;
                  }
                while (Xe >= 1 && ct >= 0);
              break;
            }
        }
      } finally {
        ee = !1, ye.current = Be, oe(), Error.prepareStackTrace = Ke;
      }
      var Gr = ie ? ie.displayName || ie.name : "", Wt = Gr ? q(Gr) : "";
      return typeof ie == "function" && ue.set(ie, Wt), Wt;
    }
    function W(ie, Se, ke) {
      return he(ie, !1);
    }
    function Y(ie) {
      var Se = ie.prototype;
      return !!(Se && Se.isReactComponent);
    }
    function se(ie, Se, ke) {
      if (ie == null)
        return "";
      if (typeof ie == "function")
        return he(ie, Y(ie));
      if (typeof ie == "string")
        return q(ie);
      switch (ie) {
        case p:
          return q("Suspense");
        case l:
          return q("SuspenseList");
      }
      if (typeof ie == "object")
        switch (ie.$$typeof) {
          case c:
            return W(ie.render);
          case d:
            return se(ie.type, Se, ke);
          case u: {
            var Ve = ie, Ke = Ve._payload, Be = Ve._init;
            try {
              return se(Be(Ke), Se, ke);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Oe = {}, B = w.ReactDebugCurrentFrame;
    function U(ie) {
      if (ie) {
        var Se = ie._owner, ke = se(ie.type, ie._source, Se ? Se.type : null);
        B.setExtraStackFrame(ke);
      } else
        B.setExtraStackFrame(null);
    }
    function _(ie, Se, ke, Ve, Ke) {
      {
        var Be = Function.call.bind(Te);
        for (var $e in ie)
          if (Be(ie, $e)) {
            var He = void 0;
            try {
              if (typeof ie[$e] != "function") {
                var et = Error((Ve || "React class") + ": " + ke + " type `" + $e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ie[$e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw et.name = "Invariant Violation", et;
              }
              He = ie[$e](Se, $e, Ve, ke, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Xe) {
              He = Xe;
            }
            He && !(He instanceof Error) && (U(Ke), x("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ve || "React class", ke, $e, typeof He), U(null)), He instanceof Error && !(He.message in Oe) && (Oe[He.message] = !0, U(Ke), x("Failed %s type: %s", ke, He.message), U(null));
          }
      }
    }
    var v = Array.isArray;
    function S(ie) {
      return v(ie);
    }
    function P(ie) {
      {
        var Se = typeof Symbol == "function" && Symbol.toStringTag, ke = Se && ie[Symbol.toStringTag] || ie.constructor.name || "Object";
        return ke;
      }
    }
    function J(ie) {
      try {
        return ve(ie), !1;
      } catch {
        return !0;
      }
    }
    function ve(ie) {
      return "" + ie;
    }
    function Re(ie) {
      if (J(ie))
        return x("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", P(ie)), ve(ie);
    }
    var je = w.ReactCurrentOwner, qe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, We, Fe;
    Fe = {};
    function rt(ie) {
      if (Te.call(ie, "ref")) {
        var Se = Object.getOwnPropertyDescriptor(ie, "ref").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return ie.ref !== void 0;
    }
    function Ge(ie) {
      if (Te.call(ie, "key")) {
        var Se = Object.getOwnPropertyDescriptor(ie, "key").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return ie.key !== void 0;
    }
    function Je(ie, Se) {
      if (typeof ie.ref == "string" && je.current && Se && je.current.stateNode !== Se) {
        var ke = G(je.current.type);
        Fe[ke] || (x('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(je.current.type), ie.ref), Fe[ke] = !0);
      }
    }
    function Ze(ie, Se) {
      {
        var ke = function() {
          ze || (ze = !0, x("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        ke.isReactWarning = !0, Object.defineProperty(ie, "key", {
          get: ke,
          configurable: !0
        });
      }
    }
    function F(ie, Se) {
      {
        var ke = function() {
          We || (We = !0, x("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        ke.isReactWarning = !0, Object.defineProperty(ie, "ref", {
          get: ke,
          configurable: !0
        });
      }
    }
    var we = function(ie, Se, ke, Ve, Ke, Be, $e) {
      var He = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: ie,
        key: Se,
        ref: ke,
        props: $e,
        // Record the component responsible for creating this element.
        _owner: Be
      };
      return He._store = {}, Object.defineProperty(He._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(He, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ve
      }), Object.defineProperty(He, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ke
      }), Object.freeze && (Object.freeze(He.props), Object.freeze(He)), He;
    };
    function xe(ie, Se, ke, Ve, Ke) {
      {
        var Be, $e = {}, He = null, et = null;
        ke !== void 0 && (Re(ke), He = "" + ke), Ge(Se) && (Re(Se.key), He = "" + Se.key), rt(Se) && (et = Se.ref, Je(Se, Ke));
        for (Be in Se)
          Te.call(Se, Be) && !qe.hasOwnProperty(Be) && ($e[Be] = Se[Be]);
        if (ie && ie.defaultProps) {
          var Xe = ie.defaultProps;
          for (Be in Xe)
            $e[Be] === void 0 && ($e[Be] = Xe[Be]);
        }
        if (He || et) {
          var ct = typeof ie == "function" ? ie.displayName || ie.name || "Unknown" : ie;
          He && Ze($e, ct), et && F($e, ct);
        }
        return we(ie, He, et, Ke, Ve, je.current, $e);
      }
    }
    var Ce = w.ReactCurrentOwner, re = w.ReactDebugCurrentFrame;
    function me(ie) {
      if (ie) {
        var Se = ie._owner, ke = se(ie.type, ie._source, Se ? Se.type : null);
        re.setExtraStackFrame(ke);
      } else
        re.setExtraStackFrame(null);
    }
    var I;
    I = !1;
    function Ee(ie) {
      return typeof ie == "object" && ie !== null && ie.$$typeof === t;
    }
    function De() {
      {
        if (Ce.current) {
          var ie = G(Ce.current.type);
          if (ie)
            return `

Check the render method of \`` + ie + "`.";
        }
        return "";
      }
    }
    function g(ie) {
      return "";
    }
    var fe = {};
    function le(ie) {
      {
        var Se = De();
        if (!Se) {
          var ke = typeof ie == "string" ? ie : ie.displayName || ie.name;
          ke && (Se = `

Check the top-level render call using <` + ke + ">.");
        }
        return Se;
      }
    }
    function L(ie, Se) {
      {
        if (!ie._store || ie._store.validated || ie.key != null)
          return;
        ie._store.validated = !0;
        var ke = le(Se);
        if (fe[ke])
          return;
        fe[ke] = !0;
        var Ve = "";
        ie && ie._owner && ie._owner !== Ce.current && (Ve = " It was passed a child from " + G(ie._owner.type) + "."), me(ie), x('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ke, Ve), me(null);
      }
    }
    function K(ie, Se) {
      {
        if (typeof ie != "object")
          return;
        if (S(ie))
          for (var ke = 0; ke < ie.length; ke++) {
            var Ve = ie[ke];
            Ee(Ve) && L(Ve, Se);
          }
        else if (Ee(ie))
          ie._store && (ie._store.validated = !0);
        else if (ie) {
          var Ke = b(ie);
          if (typeof Ke == "function" && Ke !== ie.entries)
            for (var Be = Ke.call(ie), $e; !($e = Be.next()).done; )
              Ee($e.value) && L($e.value, Se);
        }
      }
    }
    function ce(ie) {
      {
        var Se = ie.type;
        if (Se == null || typeof Se == "string")
          return;
        var ke;
        if (typeof Se == "function")
          ke = Se.propTypes;
        else if (typeof Se == "object" && (Se.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Se.$$typeof === d))
          ke = Se.propTypes;
        else
          return;
        if (ke) {
          var Ve = G(Se);
          _(ke, ie.props, "prop", Ve, ie);
        } else if (Se.PropTypes !== void 0 && !I) {
          I = !0;
          var Ke = G(Se);
          x("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ke || "Unknown");
        }
        typeof Se.getDefaultProps == "function" && !Se.getDefaultProps.isReactClassApproved && x("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Le(ie) {
      {
        for (var Se = Object.keys(ie.props), ke = 0; ke < Se.length; ke++) {
          var Ve = Se[ke];
          if (Ve !== "children" && Ve !== "key") {
            me(ie), x("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ve), me(null);
            break;
          }
        }
        ie.ref !== null && (me(ie), x("Invalid attribute `ref` supplied to `React.Fragment`."), me(null));
      }
    }
    var Ae = {};
    function Ie(ie, Se, ke, Ve, Ke, Be) {
      {
        var $e = O(ie);
        if (!$e) {
          var He = "";
          (ie === void 0 || typeof ie == "object" && ie !== null && Object.keys(ie).length === 0) && (He += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var et = g();
          et ? He += et : He += De();
          var Xe;
          ie === null ? Xe = "null" : S(ie) ? Xe = "array" : ie !== void 0 && ie.$$typeof === t ? (Xe = "<" + (G(ie.type) || "Unknown") + " />", He = " Did you accidentally export a JSX literal instead of a component?") : Xe = typeof ie, x("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Xe, He);
        }
        var ct = xe(ie, Se, ke, Ke, Be);
        if (ct == null)
          return ct;
        if ($e) {
          var zt = Se.children;
          if (zt !== void 0)
            if (Ve)
              if (S(zt)) {
                for (var Gr = 0; Gr < zt.length; Gr++)
                  K(zt[Gr], ie);
                Object.freeze && Object.freeze(zt);
              } else
                x("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              K(zt, ie);
        }
        if (Te.call(Se, "key")) {
          var Wt = G(ie), nr = Object.keys(Se).filter(function(Lm) {
            return Lm !== "key";
          }), js = nr.length > 0 ? "{key: someKey, " + nr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ae[Wt + js]) {
            var Nm = nr.length > 0 ? "{" + nr.join(": ..., ") + ": ...}" : "{}";
            x(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, js, Wt, Nm, Wt), Ae[Wt + js] = !0;
          }
        }
        return ie === o ? Le(ct) : ce(ct), ct;
      }
    }
    function Ye(ie, Se, ke) {
      return Ie(ie, Se, ke, !0);
    }
    function It(ie, Se, ke) {
      return Ie(ie, Se, ke, !1);
    }
    var nt = It, pe = Ye;
    Co.Fragment = o, Co.jsx = nt, Co.jsxs = pe;
  }()), Co;
}
var Cu;
function tg() {
  return Cu || (Cu = 1, process.env.NODE_ENV === "production" ? Fi.exports = Jm() : Fi.exports = eg()), Fi.exports;
}
var _e = tg();
class rg {
  constructor(t = {}) {
    Kr(this, "baseUrl");
    Kr(this, "token");
    Kr(this, "authType");
    Kr(this, "fetchImpl");
    this.baseUrl = t.baseUrl ?? "", this.token = t.accessToken, this.authType = t.authType ?? "2legged", this.fetchImpl = t.fetchImpl ?? fetch;
  }
  headers() {
    const t = { "Content-Type": "application/json" };
    return this.token && (t.Authorization = `Bearer ${this.token}`), t;
  }
  getApiPath(t) {
    const r = this.authType === "3legged" ? "/ext/v2/userAuthenticated" : "/ext/v2/authenticated";
    return `${this.baseUrl}${r}${t}`;
  }
  // ---- 既存で使われている想定のAPI ----
  // Viewer などで使用
  async getContractFileList(t) {
    const { contractId: r } = t, o = this.getApiPath("/contractFile"), n = new URLSearchParams({ contractId: String(r) }), i = await this.fetchImpl(`${o}?${n}`, {
      headers: this.headers()
    });
    if (!i.ok) throw new Error(`HTTP ${i.status}`);
    return { contractFiles: (await i.json()).contractFiles ?? [] };
  }
  async getContractFileMetadata(t) {
    const { contractId: r, contractFileId: o } = t, n = this.getApiPath("/pclod/meta"), i = new URLSearchParams({
      contractFileId: String(o)
    });
    this.authType === "2legged" && i.append("contractId", String(r));
    const a = await this.fetchImpl(`${n}?${i}`, {
      headers: this.headers()
    });
    if (!a.ok) throw new Error(`HTTP ${a.status}`);
    return await a.json();
  }
  // 画像（位置）バッファ
  async getContractFileImagePosition(t) {
    const { contractId: r, contractFileId: o, level: n = 0, addr: i = "0-0-0" } = t, a = this.getApiPath("/pclod/imagePosition"), s = new URLSearchParams({
      contractFileId: String(o),
      level: String(n),
      addr: i
    });
    this.authType === "2legged" && s.append("contractId", String(r));
    const c = await this.fetchImpl(`${a}?${s}`, {
      headers: this.headers()
    });
    if (!c.ok) throw new Error(`HTTP ${c.status}`);
    return await c.arrayBuffer();
  }
  // 画像（色）バッファ
  async getContractFileImageColor(t) {
    const { contractId: r, contractFileId: o, level: n = 0, addr: i = "0-0-0" } = t, a = this.getApiPath("/pclod/imageColor"), s = new URLSearchParams({
      contractFileId: String(o),
      level: String(n),
      addr: i
    });
    this.authType === "2legged" && s.append("contractId", String(r));
    const c = await this.fetchImpl(`${a}?${s}`, {
      headers: this.headers()
    });
    if (!c.ok) throw new Error(`HTTP ${c.status}`);
    return await c.arrayBuffer();
  }
  // ダウンロードURL
  async getContractFileDownloadUrl(t, r) {
    const o = this.getApiPath(`/contractFile/downloadURL/${r}`);
    let n = o;
    if (this.authType === "2legged") {
      const c = new URLSearchParams({ contractId: String(t) });
      n = `${o}?${c}`;
    }
    const i = await this.fetchImpl(n, {
      headers: this.headers()
    });
    if (!i.ok) throw new Error(`HTTP ${i.status}`);
    const a = await i.json(), s = a.presignedURL ?? a.url ?? "";
    return { url: s, presignedURL: s };
  }
  // アップロード開始（点群アップロードAPIを使用）
  async uploadContractFile(t) {
    const { contractId: r, name: o, buffer: n, pointCloudAttribute: i } = t, a = this.getApiPath("/contractFile/pointCloud"), s = {
      contractId: r,
      name: o,
      size: n.byteLength,
      pointCloudAttribute: i ?? {}
    }, c = await this.fetchImpl(a, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify(s)
    });
    if (!c.ok) throw new Error(`HTTP ${c.status}`);
    const p = await c.json(), l = await this.fetchImpl(p.presignedURL, {
      method: "PUT",
      body: n
    });
    if (!l.ok) throw new Error(`Upload failed: HTTP ${l.status}`);
    const d = this.getApiPath(`/contractFile/uploaded/${p.contractFileId}`), u = await this.fetchImpl(d, {
      method: "PUT",
      headers: this.headers(),
      body: JSON.stringify({ contractId: r })
    });
    if (!u.ok) throw new Error(`Complete upload failed: HTTP ${u.status}`);
    return await u.json();
  }
  // Construction関連のAPI
  async getConstructionList() {
    const t = this.getApiPath("/construction"), r = await this.fetchImpl(t, {
      headers: this.headers()
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return { constructions: (await r.json()).constructions ?? [] };
  }
  async getConstruction(t) {
    const r = this.getApiPath(`/construction/${t}`), o = await this.fetchImpl(r, {
      headers: this.headers()
    });
    if (!o.ok) throw new Error(`HTTP ${o.status}`);
    return await o.json();
  }
  async createConstruction(t) {
    const r = this.getApiPath("/construction"), o = await this.fetchImpl(r, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify(t)
    });
    if (!o.ok) throw new Error(`HTTP ${o.status}`);
    return await o.json();
  }
  // Contract関連のAPI
  async getContractList(t) {
    const { constructionId: r } = t, o = this.getApiPath("/contract"), n = new URLSearchParams();
    (this.authType === "2legged" || r) && n.append("constructionId", String(r));
    const i = n.toString() ? `${o}?${n}` : o, a = await this.fetchImpl(i, {
      headers: this.headers()
    });
    if (!a.ok) throw new Error(`HTTP ${a.status}`);
    return { contracts: (await a.json()).contracts ?? [] };
  }
  async createContract(t) {
    const { constructionId: r, name: o, contractedAt: n, status: i } = t, a = this.getApiPath("/contract"), s = {
      name: o,
      contractedAt: n,
      constructionId: r
    };
    i !== void 0 && (s.status = i);
    const c = await this.fetchImpl(a, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify(s)
    });
    if (!c.ok) throw new Error(`HTTP ${c.status}`);
    return await c.json();
  }
}
const pp = bi(void 0), ng = ({ children: e }) => {
  const [t, r] = Rt(), [o, n] = Rt(), i = ft(
    (a) => {
      const s = new rg({
        accessToken: a.token,
        baseUrl: a.baseUrl,
        authType: a.authType
      });
      r(s);
    },
    []
  );
  return /* @__PURE__ */ _e.jsx(pp.Provider, { value: { client: t, initialize: i, project: o, setProject: n }, children: e });
}, vi = () => {
  const e = mo(pp);
  if (!e)
    throw new Error("useClient must be used within a ClientProvider");
  return e;
}, hp = bi(void 0), og = ({
  children: e
}) => {
  const [t, r] = Rt([]), o = ft((i, a) => {
    r(
      i.map((s) => ({
        file: s,
        visible: a === void 0 ? !0 : s.id !== void 0 && a.includes(s.id)
      }))
    );
  }, []), n = ft((i) => {
    r(
      (a) => a.map(
        (s) => s.file.id === i.file.id ? {
          ...s,
          visible: !s.visible
        } : s
      )
    );
  }, []);
  return /* @__PURE__ */ _e.jsx(
    hp.Provider,
    {
      value: { load: o, toggleVisibility: n, containers: t },
      children: e
    }
  );
}, lc = () => {
  const e = mo(hp);
  if (!e)
    throw new Error(
      "useContractFiles must be used within a ContractFilesProvider"
    );
  return e;
}, yp = bi(void 0), ig = ({ children: e }) => {
  const [t, r] = Rt(new Qe()), { client: o, project: n } = vi(), { containers: i } = lc(), a = ft((p) => {
    r(p);
  }, [r]), s = ft((p) => {
    r(p);
  }, [r]), c = ft(async (p) => {
    if (!(!o || !n || !i.find((d) => d.file.id === p)))
      try {
        const u = await o.getContractFileMetadata({
          ...n,
          contractFileId: p
        }), { min: h, max: y } = u.bounds, b = new An(
          new Qe().fromArray(h),
          new Qe().fromArray(y)
        ).getCenter(new Qe());
        a(b.negate());
      } catch (d) {
        console.error("[useReferencePoint] Failed to focus file:", d);
      }
  }, [o, n, i, a]);
  return /* @__PURE__ */ _e.jsx(yp.Provider, { value: { point: t, change: a, save: s, focusFileById: c }, children: e });
}, qa = () => {
  const e = mo(yp);
  if (!e)
    throw new Error("useReferencePoint must be used within a ReferencePointProvider");
  return e;
};
var ag = Fm;
function sg() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function lg() {
  const e = sg();
  if (e.__xstate__)
    return e.__xstate__;
}
const cg = (e) => {
  if (typeof window > "u")
    return;
  const t = lg();
  t && t.register(e);
};
class Pu {
  constructor(t) {
    this._process = t, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(t) {
    const r = {
      value: t,
      next: null
    };
    if (this._current) {
      this._last.next = r, this._last = r;
      return;
    }
    this._current = r, this._last = r, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const t = this._current;
      this._process(t.value), this._current = t.next;
    }
    this._last = null;
  }
}
const mp = ".", ug = "", gp = "", fg = "#", dg = "*", bp = "xstate.init", xl = "xstate.stop";
function pg(e, t) {
  return {
    type: `xstate.after.${e}.${t}`
  };
}
function Rl(e, t) {
  return {
    type: `xstate.done.state.${e}`,
    output: t
  };
}
function hg(e, t) {
  return {
    type: `xstate.done.actor.${e}`,
    output: t,
    actorId: e
  };
}
function yg(e, t) {
  return {
    type: `xstate.error.actor.${e}`,
    error: t,
    actorId: e
  };
}
function vp(e) {
  return {
    type: bp,
    input: e
  };
}
function Xr(e) {
  setTimeout(() => {
    throw e;
  });
}
const mg = typeof Symbol == "function" && Symbol.observable || "@@observable";
function _p(e, t) {
  const r = Iu(e), o = Iu(t);
  return typeof o == "string" ? typeof r == "string" ? o === r : !1 : typeof r == "string" ? r in o : Object.keys(r).every((n) => n in o ? _p(r[n], o[n]) : !1);
}
function cc(e) {
  if (Ep(e))
    return e;
  const t = [];
  let r = "";
  for (let o = 0; o < e.length; o++) {
    switch (e.charCodeAt(o)) {
      // \
      case 92:
        r += e[o + 1], o++;
        continue;
      // .
      case 46:
        t.push(r), r = "";
        continue;
    }
    r += e[o];
  }
  return t.push(r), t;
}
function Iu(e) {
  if (Kg(e))
    return e.value;
  if (typeof e != "string")
    return e;
  const t = cc(e);
  return gg(t);
}
function gg(e) {
  if (e.length === 1)
    return e[0];
  const t = {};
  let r = t;
  for (let o = 0; o < e.length - 1; o++)
    if (o === e.length - 2)
      r[e[o]] = e[o + 1];
    else {
      const n = r;
      r = {}, n[e[o]] = r;
    }
  return t;
}
function Nu(e, t) {
  const r = {}, o = Object.keys(e);
  for (let n = 0; n < o.length; n++) {
    const i = o[n];
    r[i] = t(e[i], i, e, n);
  }
  return r;
}
function wp(e) {
  return Ep(e) ? e : [e];
}
function fn(e) {
  return e === void 0 ? [] : wp(e);
}
function Ol(e, t, r, o) {
  return typeof e == "function" ? e({
    context: t,
    event: r,
    self: o
  }) : e;
}
function Ep(e) {
  return Array.isArray(e);
}
function bg(e) {
  return e.type.startsWith("xstate.error.actor");
}
function qn(e) {
  return wp(e).map((t) => typeof t > "u" || typeof t == "string" ? {
    target: t
  } : t);
}
function Sp(e) {
  if (!(e === void 0 || e === ug))
    return fn(e);
}
function xa(e, t, r) {
  var i, a, s;
  const o = typeof e == "object", n = o ? e : void 0;
  return {
    next: (i = o ? e.next : e) == null ? void 0 : i.bind(n),
    error: (a = o ? e.error : t) == null ? void 0 : a.bind(n),
    complete: (s = o ? e.complete : r) == null ? void 0 : s.bind(n)
  };
}
function Lu(e, t) {
  return `${t}.${e}`;
}
function uc(e, t) {
  const r = t.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!r)
    return e.implementations.actors[t];
  const [, o, n] = r, a = e.getStateNodeById(n).config.invoke;
  return (Array.isArray(a) ? a[o] : a).src;
}
function ju(e, t) {
  return `${e.sessionId}.${t}`;
}
let vg = 0;
function _g(e, t) {
  const r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new Set(), a = {}, {
    clock: s,
    logger: c
  } = t, p = {
    schedule: (u, h, y, f, b = Math.random().toString(36).slice(2)) => {
      const w = {
        source: u,
        target: h,
        event: y,
        delay: f,
        id: b,
        startedAt: Date.now()
      }, x = ju(u, b);
      d._snapshot._scheduledEvents[x] = w;
      const E = s.setTimeout(() => {
        delete a[x], delete d._snapshot._scheduledEvents[x], d._relay(u, h, y);
      }, f);
      a[x] = E;
    },
    cancel: (u, h) => {
      const y = ju(u, h), f = a[y];
      delete a[y], delete d._snapshot._scheduledEvents[y], f !== void 0 && s.clearTimeout(f);
    },
    cancelAll: (u) => {
      for (const h in d._snapshot._scheduledEvents) {
        const y = d._snapshot._scheduledEvents[h];
        y.source === u && p.cancel(u, y.id);
      }
    }
  }, l = (u) => {
    if (!i.size)
      return;
    const h = {
      ...u,
      rootId: e.sessionId
    };
    i.forEach((y) => {
      var f;
      return (f = y.next) == null ? void 0 : f.call(y, h);
    });
  }, d = {
    _snapshot: {
      _scheduledEvents: ((t == null ? void 0 : t.snapshot) && t.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${vg++}`,
    _register: (u, h) => (r.set(u, h), u),
    _unregister: (u) => {
      r.delete(u.sessionId);
      const h = n.get(u);
      h !== void 0 && (o.delete(h), n.delete(u));
    },
    get: (u) => o.get(u),
    _set: (u, h) => {
      const y = o.get(u);
      if (y && y !== h)
        throw new Error(`Actor with system ID '${u}' already exists.`);
      o.set(u, h), n.set(h, u);
    },
    inspect: (u) => {
      const h = xa(u);
      return i.add(h), {
        unsubscribe() {
          i.delete(h);
        }
      };
    },
    _sendInspectionEvent: l,
    _relay: (u, h, y) => {
      d._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: u,
        actorRef: h,
        event: y
      }), h._send(y);
    },
    scheduler: p,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...d._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const u = d._snapshot._scheduledEvents;
      d._snapshot._scheduledEvents = {};
      for (const h in u) {
        const {
          source: y,
          target: f,
          event: b,
          delay: w,
          id: x
        } = u[h];
        p.schedule(y, f, b, w, x);
      }
    },
    _clock: s,
    _logger: c
  };
  return d;
}
let Ds = !1;
const fc = 1;
let or = /* @__PURE__ */ function(e) {
  return e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped", e;
}({});
const wg = {
  clock: {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: (e) => clearTimeout(e)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class Eg {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(t, r) {
    this.logic = t, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Pu(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = or.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const o = {
      ...wg,
      ...r
    }, {
      clock: n,
      logger: i,
      parent: a,
      syncSnapshot: s,
      id: c,
      systemId: p,
      inspect: l
    } = o;
    this.system = a ? a.system : _g(this, {
      clock: n,
      logger: i
    }), l && !a && this.system.inspect(xa(l)), this.sessionId = this.system._bookId(), this.id = c ?? this.sessionId, this.logger = (r == null ? void 0 : r.logger) ?? this.system._logger, this.clock = (r == null ? void 0 : r.clock) ?? this.system._clock, this._parent = a, this._syncSnapshot = s, this.options = o, this.src = o.src ?? t, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (d) => {
        this._deferred.push(d);
      },
      system: this.system,
      stopChild: (d) => {
        if (d._parent !== this)
          throw new Error(`Cannot stop child actor ${d.id} of ${this.id} because it is not a child`);
        d._stop();
      },
      emit: (d) => {
        const u = this.eventListeners.get(d.type), h = this.eventListeners.get("*");
        if (!u && !h)
          return;
        const y = [...u ? u.values() : [], ...h ? h.values() : []];
        for (const f of y)
          f(d);
      },
      actionExecutor: (d) => {
        const u = () => {
          if (this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: d.type,
              params: d.params
            }
          }), !d.exec)
            return;
          const h = Ds;
          try {
            Ds = !0, d.exec(d.info, d.params);
          } finally {
            Ds = h;
          }
        };
        this._processingStatus === or.Running ? u() : this._deferred.push(u);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), p && (this._systemId = p, this.system._set(p, this)), this._initState((r == null ? void 0 : r.snapshot) ?? (r == null ? void 0 : r.state)), p && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(t) {
    var r;
    try {
      this._snapshot = t ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(t, this._actorScope) : t : this.logic.getInitialSnapshot(this._actorScope, (r = this.options) == null ? void 0 : r.input);
    } catch (o) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: o
      };
    }
  }
  update(t, r) {
    var n, i;
    this._snapshot = t;
    let o;
    for (; o = this._deferred.shift(); )
      try {
        o();
      } catch (a) {
        this._deferred.length = 0, this._snapshot = {
          ...t,
          status: "error",
          error: a
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const a of this.observers)
          try {
            (n = a.next) == null || n.call(a, t);
          } catch (s) {
            Xr(s);
          }
        break;
      case "done":
        for (const a of this.observers)
          try {
            (i = a.next) == null || i.call(a, t);
          } catch (s) {
            Xr(s);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = hg(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: r,
      snapshot: t
    });
  }
  /**
   * Subscribe an observer to an actor’s snapshot values.
   *
   * @remarks
   * The observer will receive the actor’s snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(t, r, o) {
    var i;
    const n = xa(t, r, o);
    if (this._processingStatus !== or.Stopped)
      this.observers.add(n);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            (i = n.complete) == null || i.call(n);
          } catch (a) {
            Xr(a);
          }
          break;
        case "error": {
          const a = this._snapshot.error;
          if (!n.error)
            Xr(a);
          else
            try {
              n.error(a);
            } catch (s) {
              Xr(s);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(n);
      }
    };
  }
  on(t, r) {
    let o = this.eventListeners.get(t);
    o || (o = /* @__PURE__ */ new Set(), this.eventListeners.set(t, o));
    const n = r.bind(void 0);
    return o.add(n), {
      unsubscribe: () => {
        o.delete(n);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === or.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (o) => {
        o.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: o
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = or.Running;
    const t = vp(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: t
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, t), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (o) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: o
        }, this._error(o), this;
      }
    return this.update(this._snapshot, t), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(t) {
    let r, o;
    try {
      r = this.logic.transition(this._snapshot, t, this._actorScope);
    } catch (n) {
      o = {
        err: n
      };
    }
    if (o) {
      const {
        err: n
      } = o;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: n
      }, this._error(n);
      return;
    }
    this.update(r, t), t.type === xl && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === or.Stopped ? this : (this.mailbox.clear(), this._processingStatus === or.NotStarted ? (this._processingStatus = or.Stopped, this) : (this.mailbox.enqueue({
      type: xl
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    var t;
    for (const r of this.observers)
      try {
        (t = r.complete) == null || t.call(r);
      } catch (o) {
        Xr(o);
      }
    this.observers.clear();
  }
  _reportError(t) {
    if (!this.observers.size) {
      this._parent || Xr(t);
      return;
    }
    let r = !1;
    for (const o of this.observers) {
      const n = o.error;
      r || (r = !n);
      try {
        n == null || n(t);
      } catch (i) {
        Xr(i);
      }
    }
    this.observers.clear(), r && Xr(t);
  }
  _error(t) {
    this._stopProcedure(), this._reportError(t), this._parent && this.system._relay(this, this._parent, yg(this.id, t));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== or.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Pu(this._process.bind(this)), this._processingStatus = or.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(t) {
    this._processingStatus !== or.Stopped && this.mailbox.enqueue(t);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(t) {
    this.system._relay(void 0, this, t);
  }
  attachDevTools() {
    const {
      devTools: t
    } = this.options;
    t && (typeof t == "function" ? t : cg)(this);
  }
  toJSON() {
    return {
      xstate$$type: fc,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(t) {
    return this.logic.getPersistedSnapshot(this._snapshot, t);
  }
  [mg]() {
    return this;
  }
  /**
   * Read an actor’s snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function to(e, ...[t]) {
  return new Eg(e, t);
}
function Sg(e, t, r, o, {
  sendId: n
}) {
  const i = typeof n == "function" ? n(r, o) : n;
  return [t, {
    sendId: i
  }, void 0];
}
function Tg(e, t) {
  e.defer(() => {
    e.system.scheduler.cancel(e.self, t.sendId);
  });
}
function xg(e) {
  function t(r, o) {
  }
  return t.type = "xstate.cancel", t.sendId = e, t.resolve = Sg, t.execute = Tg, t;
}
function Rg(e, t, r, o, {
  id: n,
  systemId: i,
  src: a,
  input: s,
  syncSnapshot: c
}) {
  const p = typeof a == "string" ? uc(t.machine, a) : a, l = typeof n == "function" ? n(r) : n;
  let d, u;
  return p && (u = typeof s == "function" ? s({
    context: t.context,
    event: r.event,
    self: e.self
  }) : s, d = to(p, {
    id: l,
    src: a,
    parent: e.self,
    syncSnapshot: c,
    systemId: i,
    input: u
  })), [In(t, {
    children: {
      ...t.children,
      [l]: d
    }
  }), {
    id: n,
    systemId: i,
    actorRef: d,
    src: a,
    input: u
  }, void 0];
}
function Og(e, {
  actorRef: t
}) {
  t && e.defer(() => {
    t._processingStatus !== or.Stopped && t.start();
  });
}
function Ag(...[e, {
  id: t,
  systemId: r,
  input: o,
  syncSnapshot: n = !1
} = {}]) {
  function i(a, s) {
  }
  return i.type = "xstate.spawnChild", i.id = t, i.systemId = r, i.src = e, i.input = o, i.syncSnapshot = n, i.resolve = Rg, i.execute = Og, i;
}
function kg(e, t, r, o, {
  actorRef: n
}) {
  const i = typeof n == "function" ? n(r, o) : n, a = typeof i == "string" ? t.children[i] : i;
  let s = t.children;
  return a && (s = {
    ...s
  }, delete s[a.id]), [In(t, {
    children: s
  }), a, void 0];
}
function Cg(e, t) {
  if (t) {
    if (e.system._unregister(t), t._processingStatus !== or.Running) {
      e.stopChild(t);
      return;
    }
    e.defer(() => {
      e.stopChild(t);
    });
  }
}
function Tp(e) {
  function t(r, o) {
  }
  return t.type = "xstate.stopChild", t.actorRef = e, t.resolve = kg, t.execute = Cg, t;
}
function dc(e, t, r, o) {
  const {
    machine: n
  } = o, i = typeof e == "function", a = i ? e : n.implementations.guards[typeof e == "string" ? e : e.type];
  if (!i && !a)
    throw new Error(`Guard '${typeof e == "string" ? e : e.type}' is not implemented.'.`);
  if (typeof a != "function")
    return dc(a, t, r, o);
  const s = {
    context: t,
    event: r
  }, c = i || typeof e == "string" ? void 0 : "params" in e ? typeof e.params == "function" ? e.params({
    context: t,
    event: r
  }) : e.params : void 0;
  return "check" in a ? a.check(
    o,
    s,
    a
    // this holds all params
  ) : a(s, c);
}
const pc = (e) => e.type === "atomic" || e.type === "final";
function ro(e) {
  return Object.values(e.states).filter((t) => t.type !== "history");
}
function _i(e, t) {
  const r = [];
  if (t === e)
    return r;
  let o = e.parent;
  for (; o && o !== t; )
    r.push(o), o = o.parent;
  return r;
}
function Ra(e) {
  const t = new Set(e), r = Rp(t);
  for (const o of t)
    if (o.type === "compound" && (!r.get(o) || !r.get(o).length))
      Mu(o).forEach((n) => t.add(n));
    else if (o.type === "parallel") {
      for (const n of ro(o))
        if (n.type !== "history" && !t.has(n)) {
          const i = Mu(n);
          for (const a of i)
            t.add(a);
        }
    }
  for (const o of t) {
    let n = o.parent;
    for (; n; )
      t.add(n), n = n.parent;
  }
  return t;
}
function xp(e, t) {
  const r = t.get(e);
  if (!r)
    return {};
  if (e.type === "compound") {
    const n = r[0];
    if (n) {
      if (pc(n))
        return n.key;
    } else
      return {};
  }
  const o = {};
  for (const n of r)
    o[n.key] = xp(n, t);
  return o;
}
function Rp(e) {
  const t = /* @__PURE__ */ new Map();
  for (const r of e)
    t.has(r) || t.set(r, []), r.parent && (t.has(r.parent) || t.set(r.parent, []), t.get(r.parent).push(r));
  return t;
}
function Op(e, t) {
  const r = Ra(t);
  return xp(e, Rp(r));
}
function hc(e, t) {
  return t.type === "compound" ? ro(t).some((r) => r.type === "final" && e.has(r)) : t.type === "parallel" ? ro(t).every((r) => hc(e, r)) : t.type === "final";
}
const Ya = (e) => e[0] === fg;
function Pg(e, t) {
  return e.transitions.get(t) || [...e.transitions.keys()].filter((o) => {
    if (o === dg)
      return !0;
    if (!o.endsWith(".*"))
      return !1;
    const n = o.split("."), i = t.split(".");
    for (let a = 0; a < n.length; a++) {
      const s = n[a], c = i[a];
      if (s === "*")
        return a === n.length - 1;
      if (s !== c)
        return !1;
    }
    return !0;
  }).sort((o, n) => n.length - o.length).flatMap((o) => e.transitions.get(o));
}
function Ig(e) {
  const t = e.config.after;
  if (!t)
    return [];
  const r = (n) => {
    const i = pg(n, e.id), a = i.type;
    return e.entry.push(i0(i, {
      id: a,
      delay: n
    })), e.exit.push(xg(a)), a;
  };
  return Object.keys(t).flatMap((n) => {
    const i = t[n], a = typeof i == "string" ? {
      target: i
    } : i, s = Number.isNaN(+n) ? n : +n, c = r(s);
    return fn(a).map((p) => ({
      ...p,
      event: c,
      delay: s
    }));
  }).map((n) => {
    const {
      delay: i
    } = n;
    return {
      ...Tn(e, n.event, n),
      delay: i
    };
  });
}
function Tn(e, t, r) {
  const o = Sp(r.target), n = r.reenter ?? !1, i = jg(e, o), a = {
    ...r,
    actions: fn(r.actions),
    guard: r.guard,
    target: i,
    source: e,
    reenter: n,
    eventType: t,
    toJSON: () => ({
      ...a,
      source: `#${e.id}`,
      target: i ? i.map((s) => `#${s.id}`) : void 0
    })
  };
  return a;
}
function Ng(e) {
  const t = /* @__PURE__ */ new Map();
  if (e.config.on)
    for (const r of Object.keys(e.config.on)) {
      if (r === gp)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const o = e.config.on[r];
      t.set(r, qn(o).map((n) => Tn(e, r, n)));
    }
  if (e.config.onDone) {
    const r = `xstate.done.state.${e.id}`;
    t.set(r, qn(e.config.onDone).map((o) => Tn(e, r, o)));
  }
  for (const r of e.invoke) {
    if (r.onDone) {
      const o = `xstate.done.actor.${r.id}`;
      t.set(o, qn(r.onDone).map((n) => Tn(e, o, n)));
    }
    if (r.onError) {
      const o = `xstate.error.actor.${r.id}`;
      t.set(o, qn(r.onError).map((n) => Tn(e, o, n)));
    }
    if (r.onSnapshot) {
      const o = `xstate.snapshot.${r.id}`;
      t.set(o, qn(r.onSnapshot).map((n) => Tn(e, o, n)));
    }
  }
  for (const r of e.after) {
    let o = t.get(r.eventType);
    o || (o = [], t.set(r.eventType, o)), o.push(r);
  }
  return t;
}
function Lg(e, t) {
  const r = typeof t == "string" ? e.states[t] : t ? e.states[t.target] : void 0;
  if (!r && t)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${t}" not found on parent state node #${e.id}`
    );
  const o = {
    source: e,
    actions: !t || typeof t == "string" ? [] : fn(t.actions),
    eventType: null,
    reenter: !1,
    target: r ? [r] : [],
    toJSON: () => ({
      ...o,
      source: `#${e.id}`,
      target: r ? [`#${r.id}`] : []
    })
  };
  return o;
}
function jg(e, t) {
  if (t !== void 0)
    return t.map((r) => {
      if (typeof r != "string")
        return r;
      if (Ya(r))
        return e.machine.getStateNodeById(r);
      const o = r[0] === mp;
      if (o && !e.parent)
        return Oa(e, r.slice(1));
      const n = o ? e.key + r : r;
      if (e.parent)
        try {
          return Oa(e.parent, n);
        } catch (i) {
          throw new Error(`Invalid transition definition for state node '${e.id}':
${i.message}`);
        }
      else
        throw new Error(`Invalid target: "${r}" is not a valid target from the root node. Did you mean ".${r}"?`);
    });
}
function Ap(e) {
  const t = Sp(e.config.target);
  return t ? {
    target: t.map((r) => typeof r == "string" ? Oa(e.parent, r) : r)
  } : e.parent.initial;
}
function xn(e) {
  return e.type === "history";
}
function Mu(e) {
  const t = kp(e);
  for (const r of t)
    for (const o of _i(r, e))
      t.add(o);
  return t;
}
function kp(e) {
  const t = /* @__PURE__ */ new Set();
  function r(o) {
    if (!t.has(o)) {
      if (t.add(o), o.type === "compound")
        r(o.initial.target[0]);
      else if (o.type === "parallel")
        for (const n of ro(o))
          r(n);
    }
  }
  return r(e), t;
}
function no(e, t) {
  if (Ya(t))
    return e.machine.getStateNodeById(t);
  if (!e.states)
    throw new Error(`Unable to retrieve child state '${t}' from '${e.id}'; no child states exist.`);
  const r = e.states[t];
  if (!r)
    throw new Error(`Child state '${t}' does not exist on '${e.id}'`);
  return r;
}
function Oa(e, t) {
  if (typeof t == "string" && Ya(t))
    try {
      return e.machine.getStateNodeById(t);
    } catch {
    }
  const r = cc(t).slice();
  let o = e;
  for (; r.length; ) {
    const n = r.shift();
    if (!n.length)
      break;
    o = no(o, n);
  }
  return o;
}
function Aa(e, t) {
  if (typeof t == "string") {
    const n = e.states[t];
    if (!n)
      throw new Error(`State '${t}' does not exist on '${e.id}'`);
    return [e, n];
  }
  const r = Object.keys(t), o = r.map((n) => no(e, n)).filter(Boolean);
  return [e.machine.root, e].concat(o, r.reduce((n, i) => {
    const a = no(e, i);
    if (!a)
      return n;
    const s = Aa(a, t[i]);
    return n.concat(s);
  }, []));
}
function Mg(e, t, r, o) {
  const i = no(e, t).next(r, o);
  return !i || !i.length ? e.next(r, o) : i;
}
function Fg(e, t, r, o) {
  const n = Object.keys(t), i = no(e, n[0]), a = yc(i, t[n[0]], r, o);
  return !a || !a.length ? e.next(r, o) : a;
}
function Dg(e, t, r, o) {
  const n = [];
  for (const i of Object.keys(t)) {
    const a = t[i];
    if (!a)
      continue;
    const s = no(e, i), c = yc(s, a, r, o);
    c && n.push(...c);
  }
  return n.length ? n : e.next(r, o);
}
function yc(e, t, r, o) {
  return typeof t == "string" ? Mg(e, t, r, o) : Object.keys(t).length === 1 ? Fg(e, t, r, o) : Dg(e, t, r, o);
}
function Bg(e) {
  return Object.keys(e.states).map((t) => e.states[t]).filter((t) => t.type === "history");
}
function pn(e, t) {
  let r = e;
  for (; r.parent && r.parent !== t; )
    r = r.parent;
  return r.parent === t;
}
function $g(e, t) {
  const r = new Set(e), o = new Set(t);
  for (const n of r)
    if (o.has(n))
      return !0;
  for (const n of o)
    if (r.has(n))
      return !0;
  return !1;
}
function Cp(e, t, r) {
  const o = /* @__PURE__ */ new Set();
  for (const n of e) {
    let i = !1;
    const a = /* @__PURE__ */ new Set();
    for (const s of o)
      if ($g(Al([n], t, r), Al([s], t, r)))
        if (pn(n.source, s.source))
          a.add(s);
        else {
          i = !0;
          break;
        }
    if (!i) {
      for (const s of a)
        o.delete(s);
      o.add(n);
    }
  }
  return Array.from(o);
}
function Ug(e) {
  const [t, ...r] = e;
  for (const o of _i(t, void 0))
    if (r.every((n) => pn(n, o)))
      return o;
}
function mc(e, t) {
  if (!e.target)
    return [];
  const r = /* @__PURE__ */ new Set();
  for (const o of e.target)
    if (xn(o))
      if (t[o.id])
        for (const n of t[o.id])
          r.add(n);
      else
        for (const n of mc(Ap(o), t))
          r.add(n);
    else
      r.add(o);
  return [...r];
}
function Pp(e, t) {
  const r = mc(e, t);
  if (!r)
    return;
  if (!e.reenter && r.every((n) => n === e.source || pn(n, e.source)))
    return e.source;
  const o = Ug(r.concat(e.source));
  if (o)
    return o;
  if (!e.reenter)
    return e.source.machine.root;
}
function Al(e, t, r) {
  var n;
  const o = /* @__PURE__ */ new Set();
  for (const i of e)
    if ((n = i.target) != null && n.length) {
      const a = Pp(i, r);
      i.reenter && i.source === a && o.add(a);
      for (const s of t)
        pn(s, a) && o.add(s);
    }
  return [...o];
}
function zg(e, t) {
  if (e.length !== t.size)
    return !1;
  for (const r of e)
    if (!t.has(r))
      return !1;
  return !0;
}
function kl(e, t, r, o, n, i) {
  if (!e.length)
    return t;
  const a = new Set(t._nodes);
  let s = t.historyValue;
  const c = Cp(e, a, s);
  let p = t;
  n || ([p, s] = Zg(p, o, r, c, a, s, i, r.actionExecutor)), p = oo(p, o, r, c.flatMap((d) => d.actions), i, void 0), p = Wg(p, o, r, c, a, i, s, n);
  const l = [...a];
  p.status === "done" && (p = oo(p, o, r, l.sort((d, u) => u.order - d.order).flatMap((d) => d.exit), i, void 0));
  try {
    return s === t.historyValue && zg(t._nodes, a) ? p : In(p, {
      _nodes: l,
      historyValue: s
    });
  } catch (d) {
    throw d;
  }
}
function Hg(e, t, r, o, n) {
  if (o.output === void 0)
    return;
  const i = Rl(n.id, n.output !== void 0 && n.parent ? Ol(n.output, e.context, t, r.self) : void 0);
  return Ol(o.output, e.context, i, r.self);
}
function Wg(e, t, r, o, n, i, a, s) {
  let c = e;
  const p = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  Vg(o, a, l, p), s && l.add(e.machine.root);
  const d = /* @__PURE__ */ new Set();
  for (const u of [...p].sort((h, y) => h.order - y.order)) {
    n.add(u);
    const h = [];
    h.push(...u.entry);
    for (const y of u.invoke)
      h.push(Ag(y.src, {
        ...y,
        syncSnapshot: !!y.onSnapshot
      }));
    if (l.has(u)) {
      const y = u.initial.actions;
      h.push(...y);
    }
    if (c = oo(c, t, r, h, i, u.invoke.map((y) => y.id)), u.type === "final") {
      const y = u.parent;
      let f = (y == null ? void 0 : y.type) === "parallel" ? y : y == null ? void 0 : y.parent, b = f || u;
      for ((y == null ? void 0 : y.type) === "compound" && i.push(Rl(y.id, u.output !== void 0 ? Ol(u.output, c.context, t, r.self) : void 0)); (f == null ? void 0 : f.type) === "parallel" && !d.has(f) && hc(n, f); )
        d.add(f), i.push(Rl(f.id)), b = f, f = f.parent;
      if (f)
        continue;
      c = In(c, {
        status: "done",
        output: Hg(c, t, r, c.machine.root, b)
      });
    }
  }
  return c;
}
function Vg(e, t, r, o) {
  for (const n of e) {
    const i = Pp(n, t);
    for (const s of n.target || [])
      !xn(s) && // if the target is different than the source then it will *definitely* be entered
      (n.source !== s || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      n.source !== i || // reentering transitions always enter the target, even if it's the source itself
      n.reenter) && (o.add(s), r.add(s)), Gn(s, t, r, o);
    const a = mc(n, t);
    for (const s of a) {
      const c = _i(s, i);
      (i == null ? void 0 : i.type) === "parallel" && c.push(i), Ip(o, t, r, c, !n.source.parent && n.reenter ? void 0 : i);
    }
  }
}
function Gn(e, t, r, o) {
  var n;
  if (xn(e))
    if (t[e.id]) {
      const i = t[e.id];
      for (const a of i)
        o.add(a), Gn(a, t, r, o);
      for (const a of i)
        Bs(a, e.parent, o, t, r);
    } else {
      const i = Ap(e);
      for (const a of i.target)
        o.add(a), i === ((n = e.parent) == null ? void 0 : n.initial) && r.add(e.parent), Gn(a, t, r, o);
      for (const a of i.target)
        Bs(a, e.parent, o, t, r);
    }
  else if (e.type === "compound") {
    const [i] = e.initial.target;
    xn(i) || (o.add(i), r.add(i)), Gn(i, t, r, o), Bs(i, e, o, t, r);
  } else if (e.type === "parallel")
    for (const i of ro(e).filter((a) => !xn(a)))
      [...o].some((a) => pn(a, i)) || (xn(i) || (o.add(i), r.add(i)), Gn(i, t, r, o));
}
function Ip(e, t, r, o, n) {
  for (const i of o)
    if ((!n || pn(i, n)) && e.add(i), i.type === "parallel")
      for (const a of ro(i).filter((s) => !xn(s)))
        [...e].some((s) => pn(s, a)) || (e.add(a), Gn(a, t, r, e));
}
function Bs(e, t, r, o, n) {
  Ip(r, o, n, _i(e, t));
}
function Zg(e, t, r, o, n, i, a, s) {
  let c = e;
  const p = Al(o, n, i);
  p.sort((d, u) => u.order - d.order);
  let l;
  for (const d of p)
    for (const u of Bg(d)) {
      let h;
      u.history === "deep" ? h = (y) => pc(y) && pn(y, d) : h = (y) => y.parent === d, l ?? (l = {
        ...i
      }), l[u.id] = Array.from(n).filter(h);
    }
  for (const d of p)
    c = oo(c, t, r, [...d.exit, ...d.invoke.map((u) => Tp(u.id))], a, void 0), n.delete(d);
  return [c, l || i];
}
function qg(e, t) {
  return e.implementations.actions[t];
}
function Np(e, t, r, o, n, i) {
  const {
    machine: a
  } = e;
  let s = e;
  for (const c of o) {
    const p = typeof c == "function", l = p ? c : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      qg(a, typeof c == "string" ? c : c.type)
    ), d = {
      context: s.context,
      event: t,
      self: r.self,
      system: r.system
    }, u = p || typeof c == "string" ? void 0 : "params" in c ? typeof c.params == "function" ? c.params({
      context: s.context,
      event: t
    }) : c.params : void 0;
    if (!l || !("resolve" in l)) {
      r.actionExecutor({
        type: typeof c == "string" ? c : typeof c == "object" ? c.type : c.name || "(anonymous)",
        info: d,
        params: u,
        exec: l
      });
      continue;
    }
    const h = l, [y, f, b] = h.resolve(
      r,
      s,
      d,
      u,
      l,
      // this holds all params
      n
    );
    s = y, "retryResolve" in h && (i == null || i.push([h, f])), "execute" in h && r.actionExecutor({
      type: h.type,
      info: d,
      params: f,
      exec: h.execute.bind(null, r, f)
    }), b && (s = Np(s, t, r, b, n, i));
  }
  return s;
}
function oo(e, t, r, o, n, i) {
  const a = i ? [] : void 0, s = Np(e, t, r, o, {
    internalQueue: n,
    deferredActorIds: i
  }, a);
  return a == null || a.forEach(([c, p]) => {
    c.retryResolve(r, s, p);
  }), s;
}
function $s(e, t, r, o) {
  let n = e;
  const i = [];
  function a(p, l, d) {
    r.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: r.self,
      event: l,
      snapshot: p,
      _transitions: d
    }), i.push(p);
  }
  if (t.type === xl)
    return n = In(Fu(n, t, r), {
      status: "stopped"
    }), a(n, t, []), {
      snapshot: n,
      microstates: i
    };
  let s = t;
  if (s.type !== bp) {
    const p = s, l = bg(p), d = Du(p, n);
    if (l && !d.length)
      return n = In(e, {
        status: "error",
        error: p.error
      }), a(n, p, []), {
        snapshot: n,
        microstates: i
      };
    n = kl(
      d,
      e,
      r,
      s,
      !1,
      // isInitial
      o
    ), a(n, p, d);
  }
  let c = !0;
  for (; n.status === "active"; ) {
    let p = c ? Yg(n, s) : [];
    const l = p.length ? n : void 0;
    if (!p.length) {
      if (!o.length)
        break;
      s = o.shift(), p = Du(s, n);
    }
    n = kl(p, n, r, s, !1, o), c = n !== l, a(n, s, p);
  }
  return n.status !== "active" && Fu(n, s, r), {
    snapshot: n,
    microstates: i
  };
}
function Fu(e, t, r) {
  return oo(e, t, r, Object.values(e.children).map((o) => Tp(o)), [], void 0);
}
function Du(e, t) {
  return t.machine.getTransitionData(t, e);
}
function Yg(e, t) {
  const r = /* @__PURE__ */ new Set(), o = e._nodes.filter(pc);
  for (const n of o)
    e: for (const i of [n].concat(_i(n, void 0)))
      if (i.always) {
        for (const a of i.always)
          if (a.guard === void 0 || dc(a.guard, e.context, t, e)) {
            r.add(a);
            break e;
          }
      }
  return Cp(Array.from(r), new Set(e._nodes), e.historyValue);
}
function Gg(e, t) {
  const r = Ra(Aa(e, t));
  return Op(e, [...r]);
}
function Kg(e) {
  return !!e && typeof e == "object" && "machine" in e && "value" in e;
}
const Xg = function(t) {
  return _p(t, this.value);
}, Qg = function(t) {
  return this.tags.has(t);
}, Jg = function(t) {
  const r = this.machine.getTransitionData(this, t);
  return !!(r != null && r.length) && // Check that at least one transition is not forbidden
  r.some((o) => o.target !== void 0 || o.actions.length);
}, e0 = function() {
  const {
    _nodes: t,
    tags: r,
    machine: o,
    getMeta: n,
    toJSON: i,
    can: a,
    hasTag: s,
    matches: c,
    ...p
  } = this;
  return {
    ...p,
    tags: Array.from(r)
  };
}, t0 = function() {
  return this._nodes.reduce((t, r) => (r.meta !== void 0 && (t[r.id] = r.meta), t), {});
};
function ua(e, t) {
  return {
    status: e.status,
    output: e.output,
    error: e.error,
    machine: t,
    context: e.context,
    _nodes: e._nodes,
    value: Op(t.root, e._nodes),
    tags: new Set(e._nodes.flatMap((r) => r.tags)),
    children: e.children,
    historyValue: e.historyValue || {},
    matches: Xg,
    hasTag: Qg,
    can: Jg,
    getMeta: t0,
    toJSON: e0
  };
}
function In(e, t = {}) {
  return ua({
    ...e,
    ...t
  }, e.machine);
}
function r0(e, t) {
  const {
    _nodes: r,
    tags: o,
    machine: n,
    children: i,
    context: a,
    can: s,
    hasTag: c,
    matches: p,
    getMeta: l,
    toJSON: d,
    ...u
  } = e, h = {};
  for (const f in i) {
    const b = i[f];
    h[f] = {
      snapshot: b.getPersistedSnapshot(t),
      src: b.src,
      systemId: b._systemId,
      syncSnapshot: b._syncSnapshot
    };
  }
  return {
    ...u,
    context: Lp(a),
    children: h
  };
}
function Lp(e) {
  let t;
  for (const r in e) {
    const o = e[r];
    if (o && typeof o == "object")
      if ("sessionId" in o && "send" in o && "ref" in o)
        t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[r] = {
          xstate$$type: fc,
          id: o.id
        };
      else {
        const n = Lp(o);
        n !== o && (t ?? (t = Array.isArray(e) ? e.slice() : {
          ...e
        }), t[r] = n);
      }
  }
  return t ?? e;
}
function n0(e, t, r, o, {
  event: n,
  id: i,
  delay: a
}, {
  internalQueue: s
}) {
  const c = t.machine.implementations.delays;
  if (typeof n == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${n}" }) instead`
    );
  const p = typeof n == "function" ? n(r, o) : n;
  let l;
  if (typeof a == "string") {
    const d = c && c[a];
    l = typeof d == "function" ? d(r, o) : d;
  } else
    l = typeof a == "function" ? a(r, o) : a;
  return typeof l != "number" && s.push(p), [t, {
    event: p,
    id: i,
    delay: l
  }, void 0];
}
function o0(e, t) {
  const {
    event: r,
    delay: o,
    id: n
  } = t;
  if (typeof o == "number") {
    e.defer(() => {
      const i = e.self;
      e.system.scheduler.schedule(i, i, r, o, n);
    });
    return;
  }
}
function i0(e, t) {
  function r(o, n) {
  }
  return r.type = "xstate.raise", r.event = e, r.id = t == null ? void 0 : t.id, r.delay = t == null ? void 0 : t.delay, r.resolve = n0, r.execute = o0, r;
}
function a0(e, {
  machine: t,
  context: r
}, o, n) {
  const i = (a, s = {}) => {
    const {
      systemId: c,
      input: p
    } = s;
    if (typeof a == "string") {
      const l = uc(t, a);
      if (!l)
        throw new Error(`Actor logic '${a}' not implemented in machine '${t.id}'`);
      const d = to(l, {
        id: s.id,
        parent: e.self,
        syncSnapshot: s.syncSnapshot,
        input: typeof p == "function" ? p({
          context: r,
          event: o,
          self: e.self
        }) : p,
        src: a,
        systemId: c
      });
      return n[d.id] = d, d;
    } else
      return to(a, {
        id: s.id,
        parent: e.self,
        syncSnapshot: s.syncSnapshot,
        input: s.input,
        src: a,
        systemId: c
      });
  };
  return (a, s) => {
    const c = i(a, s);
    return n[c.id] = c, e.defer(() => {
      c._processingStatus !== or.Stopped && c.start();
    }), c;
  };
}
function s0(e, t, r, o, {
  assignment: n
}) {
  if (!t.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const i = {}, a = {
    context: t.context,
    event: r.event,
    spawn: a0(e, t, r.event, i),
    self: e.self,
    system: e.system
  };
  let s = {};
  if (typeof n == "function")
    s = n(a, o);
  else
    for (const p of Object.keys(n)) {
      const l = n[p];
      s[p] = typeof l == "function" ? l(a, o) : l;
    }
  const c = Object.assign({}, t.context, s);
  return [In(t, {
    context: c,
    children: Object.keys(i).length ? {
      ...t.children,
      ...i
    } : t.children
  }), void 0, void 0];
}
function l0(e) {
  function t(r, o) {
  }
  return t.type = "xstate.assign", t.assignment = e, t.resolve = s0, t;
}
const Bu = /* @__PURE__ */ new WeakMap();
function Mn(e, t, r) {
  let o = Bu.get(e);
  return o ? t in o || (o[t] = r()) : (o = {
    [t]: r()
  }, Bu.set(e, o)), o[t];
}
const c0 = {}, Po = (e) => typeof e == "string" ? {
  type: e
} : typeof e == "function" ? "resolve" in e ? {
  type: e.type
} : {
  type: e.name
} : e;
class gc {
  constructor(t, r) {
    if (this.config = t, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = r._parent, this.key = r._key, this.machine = r._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(mp), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? Nu(this.config.states, (o, n) => new gc(o, {
      _parent: this,
      _key: n,
      _machine: this.machine
    })) : c0, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = fn(this.config.entry).slice(), this.exit = fn(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = fn(t.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = Ng(this), this.config.always && (this.always = qn(this.config.always).map((t) => Tn(this, gp, t))), Object.keys(this.states).forEach((t) => {
      this.states[t]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(Po),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((t) => `#${t.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(Po),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: Nu(this.states, (t) => t.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t) => ({
        ...t,
        actions: t.actions.map(Po)
      })),
      entry: this.entry.map(Po),
      exit: this.exit.map(Po),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return Mn(this, "invoke", () => fn(this.config.invoke).map((t, r) => {
      const {
        src: o,
        systemId: n
      } = t, i = t.id ?? Lu(this.id, r), a = typeof o == "string" ? o : `xstate.invoke.${Lu(this.id, r)}`;
      return {
        ...t,
        src: a,
        id: i,
        systemId: n,
        toJSON() {
          const {
            onDone: s,
            onError: c,
            ...p
          } = t;
          return {
            ...p,
            type: "xstate.invoke",
            src: a,
            id: i
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return Mn(this, "on", () => [...this.transitions].flatMap(([r, o]) => o.map((n) => [r, n])).reduce((r, [o, n]) => (r[o] = r[o] || [], r[o].push(n), r), {}));
  }
  get after() {
    return Mn(this, "delayedTransitions", () => Ig(this));
  }
  get initial() {
    return Mn(this, "initial", () => Lg(this, this.config.initial));
  }
  /** @internal */
  next(t, r) {
    const o = r.type, n = [];
    let i;
    const a = Mn(this, `candidates-${o}`, () => Pg(this, o));
    for (const s of a) {
      const {
        guard: c
      } = s, p = t.context;
      let l = !1;
      try {
        l = !c || dc(c, p, r, t);
      } catch (d) {
        const u = typeof c == "string" ? c : typeof c == "object" ? c.type : void 0;
        throw new Error(`Unable to evaluate guard ${u ? `'${u}' ` : ""}in transition for event '${o}' in state node '${this.id}':
${d.message}`);
      }
      if (l) {
        n.push(...s.actions), i = s;
        break;
      }
    }
    return i ? [i] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return Mn(this, "events", () => {
      const {
        states: t
      } = this, r = new Set(this.ownEvents);
      if (t)
        for (const o of Object.keys(t)) {
          const n = t[o];
          if (n.states)
            for (const i of n.events)
              r.add(`${i}`);
        }
      return Array.from(r);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const t = new Set([...this.transitions.keys()].filter((r) => this.transitions.get(r).some((o) => !(!o.target && !o.actions.length && !o.reenter))));
    return Array.from(t);
  }
}
const u0 = "#";
class bc {
  constructor(t, r) {
    this.config = t, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = t.id || "(machine)", this.implementations = {
      actors: (r == null ? void 0 : r.actors) ?? {},
      actions: (r == null ? void 0 : r.actions) ?? {},
      delays: (r == null ? void 0 : r.delays) ?? {},
      guards: (r == null ? void 0 : r.guards) ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new gc(t, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(t) {
    const {
      actions: r,
      guards: o,
      actors: n,
      delays: i
    } = this.implementations;
    return new bc(this.config, {
      actions: {
        ...r,
        ...t.actions
      },
      guards: {
        ...o,
        ...t.guards
      },
      actors: {
        ...n,
        ...t.actors
      },
      delays: {
        ...i,
        ...t.delays
      }
    });
  }
  resolveState(t) {
    const r = Gg(this.root, t.value), o = Ra(Aa(this.root, r));
    return ua({
      _nodes: [...o],
      context: t.context || {},
      children: {},
      status: hc(o, this.root) ? "done" : t.status || "active",
      output: t.output,
      error: t.error,
      historyValue: t.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(t, r, o) {
    return $s(t, r, o, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(t, r, o) {
    return $s(t, r, o, []).microstates;
  }
  getTransitionData(t, r) {
    return yc(this.root, t.value, t, r) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(t, r, o) {
    const {
      context: n
    } = this.config, i = ua({
      context: typeof n != "function" && n ? n : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof n == "function" ? oo(i, r, t, [l0(({
      spawn: s,
      event: c,
      self: p
    }) => n({
      spawn: s,
      input: c.input,
      self: p
    }))], o, void 0) : i;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(t, r) {
    const o = vp(r), n = [], i = this.getPreInitialState(t, o, n), a = kl([{
      target: [...kp(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], i, t, o, !0, n), {
      snapshot: s
    } = $s(a, o, t, n);
    return s;
  }
  start(t) {
    Object.values(t.children).forEach((r) => {
      r.getSnapshot().status === "active" && r.start();
    });
  }
  getStateNodeById(t) {
    const r = cc(t), o = r.slice(1), n = Ya(r[0]) ? r[0].slice(u0.length) : r[0], i = this.idMap.get(n);
    if (!i)
      throw new Error(`Child state node '#${n}' does not exist on machine '${this.id}'`);
    return Oa(i, o);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(t, r) {
    return r0(t, r);
  }
  restoreSnapshot(t, r) {
    const o = {}, n = t.children;
    Object.keys(n).forEach((c) => {
      const p = n[c], l = p.snapshot, d = p.src, u = typeof d == "string" ? uc(this, d) : d;
      if (!u)
        return;
      const h = to(u, {
        id: c,
        parent: r.self,
        syncSnapshot: p.syncSnapshot,
        snapshot: l,
        src: d,
        systemId: p.systemId
      });
      o[c] = h;
    });
    const i = ua({
      ...t,
      children: o,
      _nodes: Array.from(Ra(Aa(this.root, t.value)))
    }, this), a = /* @__PURE__ */ new Set();
    function s(c, p) {
      if (!a.has(c)) {
        a.add(c);
        for (const l in c) {
          const d = c[l];
          if (d && typeof d == "object") {
            if ("xstate$$type" in d && d.xstate$$type === fc) {
              c[l] = p[d.id];
              continue;
            }
            s(d, p);
          }
        }
      }
    }
    return s(i.context, o), i;
  }
}
function f0(e, t) {
  return new bc(e, t);
}
var Di = { exports: {} }, Us = {}, Bi = { exports: {} }, zs = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $u;
function d0() {
  if ($u) return zs;
  $u = 1;
  var e = qt;
  function t(d, u) {
    return d === u && (d !== 0 || 1 / d === 1 / u) || d !== d && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : t, o = e.useState, n = e.useEffect, i = e.useLayoutEffect, a = e.useDebugValue;
  function s(d, u) {
    var h = u(), y = o({ inst: { value: h, getSnapshot: u } }), f = y[0].inst, b = y[1];
    return i(
      function() {
        f.value = h, f.getSnapshot = u, c(f) && b({ inst: f });
      },
      [d, h, u]
    ), n(
      function() {
        return c(f) && b({ inst: f }), d(function() {
          c(f) && b({ inst: f });
        });
      },
      [d]
    ), a(h), h;
  }
  function c(d) {
    var u = d.getSnapshot;
    d = d.value;
    try {
      var h = u();
      return !r(d, h);
    } catch {
      return !0;
    }
  }
  function p(d, u) {
    return u();
  }
  var l = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? p : s;
  return zs.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : l, zs;
}
var Hs = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uu;
function p0() {
  return Uu || (Uu = 1, process.env.NODE_ENV !== "production" && function() {
    function e(h, y) {
      return h === y && (h !== 0 || 1 / h === 1 / y) || h !== h && y !== y;
    }
    function t(h, y) {
      l || n.startTransition === void 0 || (l = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var f = y();
      if (!d) {
        var b = y();
        i(f, b) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      b = a({
        inst: { value: f, getSnapshot: y }
      });
      var w = b[0].inst, x = b[1];
      return c(
        function() {
          w.value = f, w.getSnapshot = y, r(w) && x({ inst: w });
        },
        [h, f, y]
      ), s(
        function() {
          return r(w) && x({ inst: w }), h(function() {
            r(w) && x({ inst: w });
          });
        },
        [h]
      ), p(f), f;
    }
    function r(h) {
      var y = h.getSnapshot;
      h = h.value;
      try {
        var f = y();
        return !i(h, f);
      } catch {
        return !0;
      }
    }
    function o(h, y) {
      return y();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var n = qt, i = typeof Object.is == "function" ? Object.is : e, a = n.useState, s = n.useEffect, c = n.useLayoutEffect, p = n.useDebugValue, l = !1, d = !1, u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? o : t;
    Hs.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Hs;
}
var zu;
function vc() {
  return zu || (zu = 1, process.env.NODE_ENV === "production" ? Bi.exports = d0() : Bi.exports = p0()), Bi.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hu;
function h0() {
  if (Hu) return Us;
  Hu = 1;
  var e = qt, t = vc();
  function r(p, l) {
    return p === l && (p !== 0 || 1 / p === 1 / l) || p !== p && l !== l;
  }
  var o = typeof Object.is == "function" ? Object.is : r, n = t.useSyncExternalStore, i = e.useRef, a = e.useEffect, s = e.useMemo, c = e.useDebugValue;
  return Us.useSyncExternalStoreWithSelector = function(p, l, d, u, h) {
    var y = i(null);
    if (y.current === null) {
      var f = { hasValue: !1, value: null };
      y.current = f;
    } else f = y.current;
    y = s(
      function() {
        function w(R) {
          if (!x) {
            if (x = !0, E = R, R = u(R), h !== void 0 && f.hasValue) {
              var A = f.value;
              if (h(A, R))
                return T = A;
            }
            return T = R;
          }
          if (A = T, o(E, R)) return A;
          var j = u(R);
          return h !== void 0 && h(A, j) ? (E = R, A) : (E = R, T = j);
        }
        var x = !1, E, T, C = d === void 0 ? null : d;
        return [
          function() {
            return w(l());
          },
          C === null ? void 0 : function() {
            return w(C());
          }
        ];
      },
      [l, d, u, h]
    );
    var b = n(p, y[0], y[1]);
    return a(
      function() {
        f.hasValue = !0, f.value = b;
      },
      [b]
    ), c(b), b;
  }, Us;
}
var Ws = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wu;
function y0() {
  return Wu || (Wu = 1, process.env.NODE_ENV !== "production" && function() {
    function e(p, l) {
      return p === l && (p !== 0 || 1 / p === 1 / l) || p !== p && l !== l;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = qt, r = vc(), o = typeof Object.is == "function" ? Object.is : e, n = r.useSyncExternalStore, i = t.useRef, a = t.useEffect, s = t.useMemo, c = t.useDebugValue;
    Ws.useSyncExternalStoreWithSelector = function(p, l, d, u, h) {
      var y = i(null);
      if (y.current === null) {
        var f = { hasValue: !1, value: null };
        y.current = f;
      } else f = y.current;
      y = s(
        function() {
          function w(R) {
            if (!x) {
              if (x = !0, E = R, R = u(R), h !== void 0 && f.hasValue) {
                var A = f.value;
                if (h(A, R))
                  return T = A;
              }
              return T = R;
            }
            if (A = T, o(E, R))
              return A;
            var j = u(R);
            return h !== void 0 && h(A, j) ? (E = R, A) : (E = R, T = j);
          }
          var x = !1, E, T, C = d === void 0 ? null : d;
          return [
            function() {
              return w(l());
            },
            C === null ? void 0 : function() {
              return w(C());
            }
          ];
        },
        [l, d, u, h]
      );
      var b = n(p, y[0], y[1]);
      return a(
        function() {
          f.hasValue = !0, f.value = b;
        },
        [b]
      ), c(b), b;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Ws;
}
var Vu;
function m0() {
  return Vu || (Vu = 1, process.env.NODE_ENV === "production" ? Di.exports = h0() : Di.exports = y0()), Di.exports;
}
var g0 = m0();
vc();
const jp = (e, t) => {
  t(e);
  const r = e.getSnapshot().children;
  r && Object.values(r).forEach((o) => {
    jp(o, t);
  });
};
function b0(e) {
  var o, n;
  const t = [];
  jp(e, (i) => {
    t.push([i, i.getSnapshot()]), i.observers = /* @__PURE__ */ new Set();
  });
  const r = (n = (o = e.system).getSnapshot) == null ? void 0 : n.call(o);
  e.stop(), e.system._snapshot = r, t.forEach(([i, a]) => {
    i._processingStatus = 0, i._snapshot = a;
  });
}
function v0(e, ...[t]) {
  let [[r, o], n] = Rt(() => {
    const i = to(e, t);
    return [e.config, i];
  });
  if (e.config !== r) {
    const i = to(e, {
      ...t,
      snapshot: o.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    n([e.config, i]), o = i;
  }
  return ag(() => {
    o.logic.implementations = e.implementations;
  }), o;
}
function _0(e, ...[t, r]) {
  const o = v0(e, t);
  return Xt(() => {
    if (!r)
      return;
    const n = o.subscribe(xa(r));
    return () => {
      n.unsubscribe();
    };
  }, [r]), Xt(() => (o.start(), () => {
    b0(o);
  }), [o]), o;
}
function w0(e, t) {
  return e === t;
}
function E0(e, t, r = w0) {
  const o = ft((a) => {
    if (!e)
      return () => {
      };
    const {
      unsubscribe: s
    } = e.subscribe(a);
    return s;
  }, [e]), n = ft(() => e == null ? void 0 : e.getSnapshot(), [e]);
  return g0.useSyncExternalStoreWithSelector(o, n, n, t, r);
}
function S0(e, t) {
  const r = /* @__PURE__ */ be.createContext(null), o = r.Provider;
  function n({
    children: s,
    logic: c = e,
    machine: p,
    options: l
  }) {
    if (p)
      throw new Error('The "machine" prop has been deprecated. Please use "logic" instead.');
    const d = _0(c, {
      ...t,
      ...l
    });
    return /* @__PURE__ */ be.createElement(o, {
      value: d,
      children: s
    });
  }
  n.displayName = "ActorProvider";
  function i() {
    const s = be.useContext(r);
    if (!s)
      throw new Error(`You used a hook from "${n.displayName}" but it's not inside a <${n.displayName}> component.`);
    return s;
  }
  function a(s, c) {
    const p = i();
    return E0(p, s, c);
  }
  return {
    Provider: n,
    useActorRef: i,
    useSelector: a
  };
}
const T0 = f0(
  {
    id: "root",
    initial: "idle",
    states: {
      idle: {},
      appearance: {},
      reference_point: {},
      metric: {
        initial: "idle",
        states: {
          idle: {},
          create: {},
          translate: {}
        }
      },
      modeling: {
        initial: "idle",
        states: {
          idle: {},
          sphere: {},
          cube: {}
        }
      },
      transform: {
        initial: "idle",
        states: {
          idle: {},
          position: {},
          rotation: {}
        }
      }
    },
    on: {
      IDLE: {
        target: ".idle"
      },
      APPEARANCE: {
        target: ".appearance"
      },
      REFERENCE_POINT: {
        target: ".reference_point"
      },
      CREATE_METRIC: {
        target: ".metric.create"
      },
      TRANSLATE_METRIC: {
        target: ".metric.translate"
      },
      MODELING_SPHERE: {
        target: ".modeling.sphere"
      },
      MODELING_CUBE: {
        target: ".modeling.cube"
      },
      TRANSFORM_POSITION: {
        target: ".transform.position"
      },
      TRANSFORM_ROTATION: {
        target: ".transform.rotation"
      }
    }
  },
  {
    actions: {}
  }
), ti = S0(T0), ri = {
  black: "#000",
  white: "#fff"
}, Fn = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, Dn = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, Bn = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, $n = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, Un = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, Io = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, x0 = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function Hr(e, ...t) {
  const r = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((o) => r.searchParams.append("args[]", o)), `Minified MUI error #${e}; visit ${r} for the full message.`;
}
const Ga = "$$material";
function ka() {
  return ka = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var o in r) ({}).hasOwnProperty.call(r, o) && (e[o] = r[o]);
    }
    return e;
  }, ka.apply(null, arguments);
}
var R0 = !1;
function O0(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function A0(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var k0 = /* @__PURE__ */ function() {
  function e(r) {
    var o = this;
    this._insertTag = function(n) {
      var i;
      o.tags.length === 0 ? o.insertionPoint ? i = o.insertionPoint.nextSibling : o.prepend ? i = o.container.firstChild : i = o.before : i = o.tags[o.tags.length - 1].nextSibling, o.container.insertBefore(n, i), o.tags.push(n);
    }, this.isSpeedy = r.speedy === void 0 ? !R0 : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(o) {
    o.forEach(this._insertTag);
  }, t.insert = function(o) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(A0(this));
    var n = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var i = O0(n);
      try {
        i.insertRule(o, i.cssRules.length);
      } catch {
      }
    } else
      n.appendChild(document.createTextNode(o));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(o) {
      var n;
      return (n = o.parentNode) == null ? void 0 : n.removeChild(o);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Kt = "-ms-", Ca = "-moz-", yt = "-webkit-", Mp = "comm", _c = "rule", wc = "decl", C0 = "@import", Fp = "@keyframes", P0 = "@layer", I0 = Math.abs, Ka = String.fromCharCode, N0 = Object.assign;
function L0(e, t) {
  return Vt(e, 0) ^ 45 ? (((t << 2 ^ Vt(e, 0)) << 2 ^ Vt(e, 1)) << 2 ^ Vt(e, 2)) << 2 ^ Vt(e, 3) : 0;
}
function Dp(e) {
  return e.trim();
}
function j0(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function mt(e, t, r) {
  return e.replace(t, r);
}
function Cl(e, t) {
  return e.indexOf(t);
}
function Vt(e, t) {
  return e.charCodeAt(t) | 0;
}
function ni(e, t, r) {
  return e.slice(t, r);
}
function Nr(e) {
  return e.length;
}
function Ec(e) {
  return e.length;
}
function $i(e, t) {
  return t.push(e), e;
}
function M0(e, t) {
  return e.map(t).join("");
}
var Xa = 1, io = 1, Bp = 0, cr = 0, Ut = 0, go = "";
function Qa(e, t, r, o, n, i, a) {
  return { value: e, root: t, parent: r, type: o, props: n, children: i, line: Xa, column: io, length: a, return: "" };
}
function No(e, t) {
  return N0(Qa("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function F0() {
  return Ut;
}
function D0() {
  return Ut = cr > 0 ? Vt(go, --cr) : 0, io--, Ut === 10 && (io = 1, Xa--), Ut;
}
function dr() {
  return Ut = cr < Bp ? Vt(go, cr++) : 0, io++, Ut === 10 && (io = 1, Xa++), Ut;
}
function Br() {
  return Vt(go, cr);
}
function fa() {
  return cr;
}
function wi(e, t) {
  return ni(go, e, t);
}
function oi(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function $p(e) {
  return Xa = io = 1, Bp = Nr(go = e), cr = 0, [];
}
function Up(e) {
  return go = "", e;
}
function da(e) {
  return Dp(wi(cr - 1, Pl(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function B0(e) {
  for (; (Ut = Br()) && Ut < 33; )
    dr();
  return oi(e) > 2 || oi(Ut) > 3 ? "" : " ";
}
function $0(e, t) {
  for (; --t && dr() && !(Ut < 48 || Ut > 102 || Ut > 57 && Ut < 65 || Ut > 70 && Ut < 97); )
    ;
  return wi(e, fa() + (t < 6 && Br() == 32 && dr() == 32));
}
function Pl(e) {
  for (; dr(); )
    switch (Ut) {
      // ] ) " '
      case e:
        return cr;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Pl(Ut);
        break;
      // (
      case 40:
        e === 41 && Pl(e);
        break;
      // \
      case 92:
        dr();
        break;
    }
  return cr;
}
function U0(e, t) {
  for (; dr() && e + Ut !== 57; )
    if (e + Ut === 84 && Br() === 47)
      break;
  return "/*" + wi(t, cr - 1) + "*" + Ka(e === 47 ? e : dr());
}
function z0(e) {
  for (; !oi(Br()); )
    dr();
  return wi(e, cr);
}
function H0(e) {
  return Up(pa("", null, null, null, [""], e = $p(e), 0, [0], e));
}
function pa(e, t, r, o, n, i, a, s, c) {
  for (var p = 0, l = 0, d = a, u = 0, h = 0, y = 0, f = 1, b = 1, w = 1, x = 0, E = "", T = n, C = i, R = o, A = E; b; )
    switch (y = x, x = dr()) {
      // (
      case 40:
        if (y != 108 && Vt(A, d - 1) == 58) {
          Cl(A += mt(da(x), "&", "&\f"), "&\f") != -1 && (w = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        A += da(x);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        A += B0(y);
        break;
      // \
      case 92:
        A += $0(fa() - 1, 7);
        continue;
      // /
      case 47:
        switch (Br()) {
          case 42:
          case 47:
            $i(W0(U0(dr(), fa()), t, r), c);
            break;
          default:
            A += "/";
        }
        break;
      // {
      case 123 * f:
        s[p++] = Nr(A) * w;
      // } ; \0
      case 125 * f:
      case 59:
      case 0:
        switch (x) {
          // \0 }
          case 0:
          case 125:
            b = 0;
          // ;
          case 59 + l:
            w == -1 && (A = mt(A, /\f/g, "")), h > 0 && Nr(A) - d && $i(h > 32 ? qu(A + ";", o, r, d - 1) : qu(mt(A, " ", "") + ";", o, r, d - 2), c);
            break;
          // @ ;
          case 59:
            A += ";";
          // { rule/at-rule
          default:
            if ($i(R = Zu(A, t, r, p, l, n, s, E, T = [], C = [], d), i), x === 123)
              if (l === 0)
                pa(A, t, R, R, T, i, d, s, C);
              else
                switch (u === 99 && Vt(A, 3) === 110 ? 100 : u) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    pa(e, R, R, o && $i(Zu(e, R, R, 0, 0, n, s, E, n, T = [], d), C), n, C, d, s, o ? T : C);
                    break;
                  default:
                    pa(A, R, R, R, [""], C, 0, s, C);
                }
        }
        p = l = h = 0, f = w = 1, E = A = "", d = a;
        break;
      // :
      case 58:
        d = 1 + Nr(A), h = y;
      default:
        if (f < 1) {
          if (x == 123)
            --f;
          else if (x == 125 && f++ == 0 && D0() == 125)
            continue;
        }
        switch (A += Ka(x), x * f) {
          // &
          case 38:
            w = l > 0 ? 1 : (A += "\f", -1);
            break;
          // ,
          case 44:
            s[p++] = (Nr(A) - 1) * w, w = 1;
            break;
          // @
          case 64:
            Br() === 45 && (A += da(dr())), u = Br(), l = d = Nr(E = A += z0(fa())), x++;
            break;
          // -
          case 45:
            y === 45 && Nr(A) == 2 && (f = 0);
        }
    }
  return i;
}
function Zu(e, t, r, o, n, i, a, s, c, p, l) {
  for (var d = n - 1, u = n === 0 ? i : [""], h = Ec(u), y = 0, f = 0, b = 0; y < o; ++y)
    for (var w = 0, x = ni(e, d + 1, d = I0(f = a[y])), E = e; w < h; ++w)
      (E = Dp(f > 0 ? u[w] + " " + x : mt(x, /&\f/g, u[w]))) && (c[b++] = E);
  return Qa(e, t, r, n === 0 ? _c : s, c, p, l);
}
function W0(e, t, r) {
  return Qa(e, t, r, Mp, Ka(F0()), ni(e, 2, -2), 0);
}
function qu(e, t, r, o) {
  return Qa(e, t, r, wc, ni(e, 0, o), ni(e, o + 1, -1), o);
}
function Jn(e, t) {
  for (var r = "", o = Ec(e), n = 0; n < o; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function V0(e, t, r, o) {
  switch (e.type) {
    case P0:
      if (e.children.length) break;
    case C0:
    case wc:
      return e.return = e.return || e.value;
    case Mp:
      return "";
    case Fp:
      return e.return = e.value + "{" + Jn(e.children, o) + "}";
    case _c:
      e.value = e.props.join(",");
  }
  return Nr(r = Jn(e.children, o)) ? e.return = e.value + "{" + r + "}" : "";
}
function Z0(e) {
  var t = Ec(e);
  return function(r, o, n, i) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](r, o, n, i) || "";
    return a;
  };
}
function q0(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function zp(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] === void 0 && (t[r] = e(r)), t[r];
  };
}
var Y0 = function(t, r, o) {
  for (var n = 0, i = 0; n = i, i = Br(), n === 38 && i === 12 && (r[o] = 1), !oi(i); )
    dr();
  return wi(t, cr);
}, G0 = function(t, r) {
  var o = -1, n = 44;
  do
    switch (oi(n)) {
      case 0:
        n === 38 && Br() === 12 && (r[o] = 1), t[o] += Y0(cr - 1, r, o);
        break;
      case 2:
        t[o] += da(n);
        break;
      case 4:
        if (n === 44) {
          t[++o] = Br() === 58 ? "&\f" : "", r[o] = t[o].length;
          break;
        }
      // fallthrough
      default:
        t[o] += Ka(n);
    }
  while (n = dr());
  return t;
}, K0 = function(t, r) {
  return Up(G0($p(t), r));
}, Yu = /* @__PURE__ */ new WeakMap(), X0 = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var r = t.value, o = t.parent, n = t.column === o.column && t.line === o.line; o.type !== "rule"; )
      if (o = o.parent, !o) return;
    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !Yu.get(o)) && !n) {
      Yu.set(t, !0);
      for (var i = [], a = K0(r, i), s = o.props, c = 0, p = 0; c < a.length; c++)
        for (var l = 0; l < s.length; l++, p++)
          t.props[p] = i[c] ? a[c].replace(/&\f/g, s[l]) : s[l] + " " + a[c];
    }
  }
}, Q0 = function(t) {
  if (t.type === "decl") {
    var r = t.value;
    // charcode for l
    r.charCodeAt(0) === 108 && // charcode for b
    r.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function Hp(e, t) {
  switch (L0(e, t)) {
    // color-adjust
    case 5103:
      return yt + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return yt + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return yt + e + Ca + e + Kt + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return yt + e + Kt + e + e;
    // order
    case 6165:
      return yt + e + Kt + "flex-" + e + e;
    // align-items
    case 5187:
      return yt + e + mt(e, /(\w+).+(:[^]+)/, yt + "box-$1$2" + Kt + "flex-$1$2") + e;
    // align-self
    case 5443:
      return yt + e + Kt + "flex-item-" + mt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return yt + e + Kt + "flex-line-pack" + mt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return yt + e + Kt + mt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return yt + e + Kt + mt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return yt + "box-" + mt(e, "-grow", "") + yt + e + Kt + mt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return yt + mt(e, /([^-])(transform)/g, "$1" + yt + "$2") + e;
    // cursor
    case 6187:
      return mt(mt(mt(e, /(zoom-|grab)/, yt + "$1"), /(image-set)/, yt + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return mt(e, /(image-set\([^]*)/, yt + "$1$`$1");
    // justify-content
    case 4968:
      return mt(mt(e, /(.+:)(flex-)?(.*)/, yt + "box-pack:$3" + Kt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + yt + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return mt(e, /(.+)-inline(.+)/, yt + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Nr(e) - 1 - t > 6) switch (Vt(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Vt(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return mt(e, /(.+:)(.+)-([^]+)/, "$1" + yt + "$2-$3$1" + Ca + (Vt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Cl(e, "stretch") ? Hp(mt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Vt(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Vt(e, Nr(e) - 3 - (~Cl(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return mt(e, ":", ":" + yt) + e;
        // (inline-)?fl(e)x
        case 101:
          return mt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + yt + (Vt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + yt + "$2$3$1" + Kt + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Vt(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return yt + e + Kt + mt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return yt + e + Kt + mt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return yt + e + Kt + mt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return yt + e + Kt + e + e;
  }
  return e;
}
var J0 = function(t, r, o, n) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case wc:
      t.return = Hp(t.value, t.length);
      break;
    case Fp:
      return Jn([No(t, {
        value: mt(t.value, "@", "@" + yt)
      })], n);
    case _c:
      if (t.length) return M0(t.props, function(i) {
        switch (j0(i, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Jn([No(t, {
              props: [mt(i, /:(read-\w+)/, ":" + Ca + "$1")]
            })], n);
          // :placeholder
          case "::placeholder":
            return Jn([No(t, {
              props: [mt(i, /:(plac\w+)/, ":" + yt + "input-$1")]
            }), No(t, {
              props: [mt(i, /:(plac\w+)/, ":" + Ca + "$1")]
            }), No(t, {
              props: [mt(i, /:(plac\w+)/, Kt + "input-$1")]
            })], n);
        }
        return "";
      });
  }
}, eb = [J0], tb = function(t) {
  var r = t.key;
  if (r === "css") {
    var o = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(o, function(f) {
      var b = f.getAttribute("data-emotion");
      b.indexOf(" ") !== -1 && (document.head.appendChild(f), f.setAttribute("data-s", ""));
    });
  }
  var n = t.stylisPlugins || eb, i = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
    function(f) {
      for (var b = f.getAttribute("data-emotion").split(" "), w = 1; w < b.length; w++)
        i[b[w]] = !0;
      s.push(f);
    }
  );
  var c, p = [X0, Q0];
  {
    var l, d = [V0, q0(function(f) {
      l.insert(f);
    })], u = Z0(p.concat(n, d)), h = function(b) {
      return Jn(H0(b), u);
    };
    c = function(b, w, x, E) {
      l = x, h(b ? b + "{" + w.styles + "}" : w.styles), E && (y.inserted[w.name] = !0);
    };
  }
  var y = {
    key: r,
    sheet: new k0({
      key: r,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: i,
    registered: {},
    insert: c
  };
  return y.sheet.hydrate(s), y;
}, Ui = { exports: {} }, bt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gu;
function rb() {
  if (Gu) return bt;
  Gu = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, o = e ? Symbol.for("react.fragment") : 60107, n = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, p = e ? Symbol.for("react.concurrent_mode") : 60111, l = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, u = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, x = e ? Symbol.for("react.scope") : 60119;
  function E(C) {
    if (typeof C == "object" && C !== null) {
      var R = C.$$typeof;
      switch (R) {
        case t:
          switch (C = C.type, C) {
            case c:
            case p:
            case o:
            case i:
            case n:
            case d:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case s:
                case l:
                case y:
                case h:
                case a:
                  return C;
                default:
                  return R;
              }
          }
        case r:
          return R;
      }
    }
  }
  function T(C) {
    return E(C) === p;
  }
  return bt.AsyncMode = c, bt.ConcurrentMode = p, bt.ContextConsumer = s, bt.ContextProvider = a, bt.Element = t, bt.ForwardRef = l, bt.Fragment = o, bt.Lazy = y, bt.Memo = h, bt.Portal = r, bt.Profiler = i, bt.StrictMode = n, bt.Suspense = d, bt.isAsyncMode = function(C) {
    return T(C) || E(C) === c;
  }, bt.isConcurrentMode = T, bt.isContextConsumer = function(C) {
    return E(C) === s;
  }, bt.isContextProvider = function(C) {
    return E(C) === a;
  }, bt.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === t;
  }, bt.isForwardRef = function(C) {
    return E(C) === l;
  }, bt.isFragment = function(C) {
    return E(C) === o;
  }, bt.isLazy = function(C) {
    return E(C) === y;
  }, bt.isMemo = function(C) {
    return E(C) === h;
  }, bt.isPortal = function(C) {
    return E(C) === r;
  }, bt.isProfiler = function(C) {
    return E(C) === i;
  }, bt.isStrictMode = function(C) {
    return E(C) === n;
  }, bt.isSuspense = function(C) {
    return E(C) === d;
  }, bt.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === o || C === p || C === i || C === n || C === d || C === u || typeof C == "object" && C !== null && (C.$$typeof === y || C.$$typeof === h || C.$$typeof === a || C.$$typeof === s || C.$$typeof === l || C.$$typeof === b || C.$$typeof === w || C.$$typeof === x || C.$$typeof === f);
  }, bt.typeOf = E, bt;
}
var vt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ku;
function nb() {
  return Ku || (Ku = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, o = e ? Symbol.for("react.fragment") : 60107, n = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, p = e ? Symbol.for("react.concurrent_mode") : 60111, l = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, u = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, x = e ? Symbol.for("react.scope") : 60119;
    function E(he) {
      return typeof he == "string" || typeof he == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      he === o || he === p || he === i || he === n || he === d || he === u || typeof he == "object" && he !== null && (he.$$typeof === y || he.$$typeof === h || he.$$typeof === a || he.$$typeof === s || he.$$typeof === l || he.$$typeof === b || he.$$typeof === w || he.$$typeof === x || he.$$typeof === f);
    }
    function T(he) {
      if (typeof he == "object" && he !== null) {
        var W = he.$$typeof;
        switch (W) {
          case t:
            var Y = he.type;
            switch (Y) {
              case c:
              case p:
              case o:
              case i:
              case n:
              case d:
                return Y;
              default:
                var se = Y && Y.$$typeof;
                switch (se) {
                  case s:
                  case l:
                  case y:
                  case h:
                  case a:
                    return se;
                  default:
                    return W;
                }
            }
          case r:
            return W;
        }
      }
    }
    var C = c, R = p, A = s, j = a, N = t, O = l, D = o, H = y, G = h, X = r, Q = i, M = n, k = d, $ = !1;
    function ne(he) {
      return $ || ($ = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), te(he) || T(he) === c;
    }
    function te(he) {
      return T(he) === p;
    }
    function de(he) {
      return T(he) === s;
    }
    function ae(he) {
      return T(he) === a;
    }
    function z(he) {
      return typeof he == "object" && he !== null && he.$$typeof === t;
    }
    function Z(he) {
      return T(he) === l;
    }
    function oe(he) {
      return T(he) === o;
    }
    function ye(he) {
      return T(he) === y;
    }
    function V(he) {
      return T(he) === h;
    }
    function q(he) {
      return T(he) === r;
    }
    function ee(he) {
      return T(he) === i;
    }
    function ue(he) {
      return T(he) === n;
    }
    function ge(he) {
      return T(he) === d;
    }
    vt.AsyncMode = C, vt.ConcurrentMode = R, vt.ContextConsumer = A, vt.ContextProvider = j, vt.Element = N, vt.ForwardRef = O, vt.Fragment = D, vt.Lazy = H, vt.Memo = G, vt.Portal = X, vt.Profiler = Q, vt.StrictMode = M, vt.Suspense = k, vt.isAsyncMode = ne, vt.isConcurrentMode = te, vt.isContextConsumer = de, vt.isContextProvider = ae, vt.isElement = z, vt.isForwardRef = Z, vt.isFragment = oe, vt.isLazy = ye, vt.isMemo = V, vt.isPortal = q, vt.isProfiler = ee, vt.isStrictMode = ue, vt.isSuspense = ge, vt.isValidElementType = E, vt.typeOf = T;
  }()), vt;
}
var Xu;
function Sc() {
  return Xu || (Xu = 1, process.env.NODE_ENV === "production" ? Ui.exports = rb() : Ui.exports = nb()), Ui.exports;
}
var Vs, Qu;
function ob() {
  if (Qu) return Vs;
  Qu = 1;
  var e = Sc(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, r = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, o = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, n = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, i = {};
  i[e.ForwardRef] = o, i[e.Memo] = n;
  function a(y) {
    return e.isMemo(y) ? n : i[y.$$typeof] || t;
  }
  var s = Object.defineProperty, c = Object.getOwnPropertyNames, p = Object.getOwnPropertySymbols, l = Object.getOwnPropertyDescriptor, d = Object.getPrototypeOf, u = Object.prototype;
  function h(y, f, b) {
    if (typeof f != "string") {
      if (u) {
        var w = d(f);
        w && w !== u && h(y, w, b);
      }
      var x = c(f);
      p && (x = x.concat(p(f)));
      for (var E = a(y), T = a(f), C = 0; C < x.length; ++C) {
        var R = x[C];
        if (!r[R] && !(b && b[R]) && !(T && T[R]) && !(E && E[R])) {
          var A = l(f, R);
          try {
            s(y, R, A);
          } catch {
          }
        }
      }
    }
    return y;
  }
  return Vs = h, Vs;
}
ob();
var ib = !0;
function Wp(e, t, r) {
  var o = "";
  return r.split(" ").forEach(function(n) {
    e[n] !== void 0 ? t.push(e[n] + ";") : n && (o += n + " ");
  }), o;
}
var Tc = function(t, r, o) {
  var n = t.key + "-" + r.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (o === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  ib === !1) && t.registered[n] === void 0 && (t.registered[n] = r.styles);
}, xc = function(t, r, o) {
  Tc(t, r, o);
  var n = t.key + "-" + r.name;
  if (t.inserted[r.name] === void 0) {
    var i = r;
    do
      t.insert(r === i ? "." + n : "", i, t.sheet, !0), i = i.next;
    while (i !== void 0);
  }
};
function ab(e) {
  for (var t = 0, r, o = 0, n = e.length; n >= 4; ++o, n -= 4)
    r = e.charCodeAt(o) & 255 | (e.charCodeAt(++o) & 255) << 8 | (e.charCodeAt(++o) & 255) << 16 | (e.charCodeAt(++o) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (n) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(o) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var sb = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, lb = !1, cb = /[A-Z]|^ms/g, ub = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Vp = function(t) {
  return t.charCodeAt(1) === 45;
}, Ju = function(t) {
  return t != null && typeof t != "boolean";
}, Zs = /* @__PURE__ */ zp(function(e) {
  return Vp(e) ? e : e.replace(cb, "-$&").toLowerCase();
}), ef = function(t, r) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof r == "string")
        return r.replace(ub, function(o, n, i) {
          return Lr = {
            name: n,
            styles: i,
            next: Lr
          }, n;
        });
  }
  return sb[t] !== 1 && !Vp(t) && typeof r == "number" && r !== 0 ? r + "px" : r;
}, fb = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function ii(e, t, r) {
  if (r == null)
    return "";
  var o = r;
  if (o.__emotion_styles !== void 0)
    return o;
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      var n = r;
      if (n.anim === 1)
        return Lr = {
          name: n.name,
          styles: n.styles,
          next: Lr
        }, n.name;
      var i = r;
      if (i.styles !== void 0) {
        var a = i.next;
        if (a !== void 0)
          for (; a !== void 0; )
            Lr = {
              name: a.name,
              styles: a.styles,
              next: Lr
            }, a = a.next;
        var s = i.styles + ";";
        return s;
      }
      return db(e, t, r);
    }
    case "function": {
      if (e !== void 0) {
        var c = Lr, p = r(e);
        return Lr = c, ii(e, t, p);
      }
      break;
    }
  }
  var l = r;
  if (t == null)
    return l;
  var d = t[l];
  return d !== void 0 ? d : l;
}
function db(e, t, r) {
  var o = "";
  if (Array.isArray(r))
    for (var n = 0; n < r.length; n++)
      o += ii(e, t, r[n]) + ";";
  else
    for (var i in r) {
      var a = r[i];
      if (typeof a != "object") {
        var s = a;
        t != null && t[s] !== void 0 ? o += i + "{" + t[s] + "}" : Ju(s) && (o += Zs(i) + ":" + ef(i, s) + ";");
      } else {
        if (i === "NO_COMPONENT_SELECTOR" && lb)
          throw new Error(fb);
        if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var c = 0; c < a.length; c++)
            Ju(a[c]) && (o += Zs(i) + ":" + ef(i, a[c]) + ";");
        else {
          var p = ii(e, t, a);
          switch (i) {
            case "animation":
            case "animationName": {
              o += Zs(i) + ":" + p + ";";
              break;
            }
            default:
              o += i + "{" + p + "}";
          }
        }
      }
    }
  return o;
}
var tf = /label:\s*([^\s;{]+)\s*(;|$)/g, Lr;
function Ei(e, t, r) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var o = !0, n = "";
  Lr = void 0;
  var i = e[0];
  if (i == null || i.raw === void 0)
    o = !1, n += ii(r, t, i);
  else {
    var a = i;
    n += a[0];
  }
  for (var s = 1; s < e.length; s++)
    if (n += ii(r, t, e[s]), o) {
      var c = i;
      n += c[s];
    }
  tf.lastIndex = 0;
  for (var p = "", l; (l = tf.exec(n)) !== null; )
    p += "-" + l[1];
  var d = ab(n) + p;
  return {
    name: d,
    styles: n,
    next: Lr
  };
}
var pb = function(t) {
  return t();
}, Zp = be.useInsertionEffect ? be.useInsertionEffect : !1, qp = Zp || pb, rf = Zp || be.useLayoutEffect, hb = !1, Yp = /* @__PURE__ */ be.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ tb({
    key: "css"
  }) : null
);
Yp.Provider;
var Rc = function(t) {
  return /* @__PURE__ */ Dm(function(r, o) {
    var n = mo(Yp);
    return t(r, n, o);
  });
}, Ja = /* @__PURE__ */ be.createContext({}), Oc = {}.hasOwnProperty, Il = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", yb = function(t, r) {
  var o = {};
  for (var n in r)
    Oc.call(r, n) && (o[n] = r[n]);
  return o[Il] = t, o;
}, mb = function(t) {
  var r = t.cache, o = t.serialized, n = t.isStringTag;
  return Tc(r, o, n), qp(function() {
    return xc(r, o, n);
  }), null;
}, gb = /* @__PURE__ */ Rc(function(e, t, r) {
  var o = e.css;
  typeof o == "string" && t.registered[o] !== void 0 && (o = t.registered[o]);
  var n = e[Il], i = [o], a = "";
  typeof e.className == "string" ? a = Wp(t.registered, i, e.className) : e.className != null && (a = e.className + " ");
  var s = Ei(i, void 0, be.useContext(Ja));
  a += t.key + "-" + s.name;
  var c = {};
  for (var p in e)
    Oc.call(e, p) && p !== "css" && p !== Il && !hb && (c[p] = e[p]);
  return c.className = a, r && (c.ref = r), /* @__PURE__ */ be.createElement(be.Fragment, null, /* @__PURE__ */ be.createElement(mb, {
    cache: t,
    serialized: s,
    isStringTag: typeof n == "string"
  }), /* @__PURE__ */ be.createElement(n, c));
}), bb = gb, nf = function(t, r) {
  var o = arguments;
  if (r == null || !Oc.call(r, "css"))
    return be.createElement.apply(void 0, o);
  var n = o.length, i = new Array(n);
  i[0] = bb, i[1] = yb(t, r);
  for (var a = 2; a < n; a++)
    i[a] = o[a];
  return be.createElement.apply(null, i);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(nf || (nf = {}));
var vb = /* @__PURE__ */ Rc(function(e, t) {
  var r = e.styles, o = Ei([r], void 0, be.useContext(Ja)), n = be.useRef();
  return rf(function() {
    var i = t.key + "-global", a = new t.sheet.constructor({
      key: i,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), s = !1, c = document.querySelector('style[data-emotion="' + i + " " + o.name + '"]');
    return t.sheet.tags.length && (a.before = t.sheet.tags[0]), c !== null && (s = !0, c.setAttribute("data-emotion", i), a.hydrate([c])), n.current = [a, s], function() {
      a.flush();
    };
  }, [t]), rf(function() {
    var i = n.current, a = i[0], s = i[1];
    if (s) {
      i[1] = !1;
      return;
    }
    if (o.next !== void 0 && xc(t, o.next, !0), a.tags.length) {
      var c = a.tags[a.tags.length - 1].nextElementSibling;
      a.before = c, a.flush();
    }
    t.insert("", o, a, !1);
  }, [t, o.name]), null;
});
function _b() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return Ei(t);
}
function Ac() {
  var e = _b.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var wb = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Eb = /* @__PURE__ */ zp(
  function(e) {
    return wb.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Sb = !1, Tb = Eb, xb = function(t) {
  return t !== "theme";
}, of = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? Tb : xb;
}, af = function(t, r, o) {
  var n;
  if (r) {
    var i = r.shouldForwardProp;
    n = t.__emotion_forwardProp && i ? function(a) {
      return t.__emotion_forwardProp(a) && i(a);
    } : i;
  }
  return typeof n != "function" && o && (n = t.__emotion_forwardProp), n;
}, Rb = function(t) {
  var r = t.cache, o = t.serialized, n = t.isStringTag;
  return Tc(r, o, n), qp(function() {
    return xc(r, o, n);
  }), null;
}, Ob = function e(t, r) {
  var o = t.__emotion_real === t, n = o && t.__emotion_base || t, i, a;
  r !== void 0 && (i = r.label, a = r.target);
  var s = af(t, r, o), c = s || of(n), p = !c("as");
  return function() {
    var l = arguments, d = o && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (i !== void 0 && d.push("label:" + i + ";"), l[0] == null || l[0].raw === void 0)
      d.push.apply(d, l);
    else {
      var u = l[0];
      d.push(u[0]);
      for (var h = l.length, y = 1; y < h; y++)
        d.push(l[y], u[y]);
    }
    var f = Rc(function(b, w, x) {
      var E = p && b.as || n, T = "", C = [], R = b;
      if (b.theme == null) {
        R = {};
        for (var A in b)
          R[A] = b[A];
        R.theme = be.useContext(Ja);
      }
      typeof b.className == "string" ? T = Wp(w.registered, C, b.className) : b.className != null && (T = b.className + " ");
      var j = Ei(d.concat(C), w.registered, R);
      T += w.key + "-" + j.name, a !== void 0 && (T += " " + a);
      var N = p && s === void 0 ? of(E) : c, O = {};
      for (var D in b)
        p && D === "as" || N(D) && (O[D] = b[D]);
      return O.className = T, x && (O.ref = x), /* @__PURE__ */ be.createElement(be.Fragment, null, /* @__PURE__ */ be.createElement(Rb, {
        cache: w,
        serialized: j,
        isStringTag: typeof E == "string"
      }), /* @__PURE__ */ be.createElement(E, O));
    });
    return f.displayName = i !== void 0 ? i : "Styled(" + (typeof n == "string" ? n : n.displayName || n.name || "Component") + ")", f.defaultProps = t.defaultProps, f.__emotion_real = f, f.__emotion_base = n, f.__emotion_styles = d, f.__emotion_forwardProp = s, Object.defineProperty(f, "toString", {
      value: function() {
        return a === void 0 && Sb ? "NO_COMPONENT_SELECTOR" : "." + a;
      }
    }), f.withComponent = function(b, w) {
      var x = e(b, ka({}, r, w, {
        shouldForwardProp: af(f, w, !0)
      }));
      return x.apply(void 0, d);
    }, f;
  };
}, Ab = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Nl = Ob.bind(null);
Ab.forEach(function(e) {
  Nl[e] = Nl(e);
});
var zi = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var qs, sf;
function kb() {
  if (sf) return qs;
  sf = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function o(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function n() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var c = Object.getOwnPropertyNames(a).map(function(l) {
        return a[l];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var p = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(l) {
        p[l] = l;
      }), Object.keys(Object.assign({}, p)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return qs = n() ? Object.assign : function(i, a) {
    for (var s, c = o(i), p, l = 1; l < arguments.length; l++) {
      s = Object(arguments[l]);
      for (var d in s)
        t.call(s, d) && (c[d] = s[d]);
      if (e) {
        p = e(s);
        for (var u = 0; u < p.length; u++)
          r.call(s, p[u]) && (c[p[u]] = s[p[u]]);
      }
    }
    return c;
  }, qs;
}
var Ys, lf;
function kc() {
  if (lf) return Ys;
  lf = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Ys = e, Ys;
}
var Gs, cf;
function Gp() {
  return cf || (cf = 1, Gs = Function.call.bind(Object.prototype.hasOwnProperty)), Gs;
}
var Ks, uf;
function Cb() {
  if (uf) return Ks;
  uf = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ kc(), r = {}, o = /* @__PURE__ */ Gp();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function n(i, a, s, c, p) {
    if (process.env.NODE_ENV !== "production") {
      for (var l in i)
        if (o(i, l)) {
          var d;
          try {
            if (typeof i[l] != "function") {
              var u = Error(
                (c || "React class") + ": " + s + " type `" + l + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[l] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw u.name = "Invariant Violation", u;
            }
            d = i[l](a, l, c, s, null, t);
          } catch (y) {
            d = y;
          }
          if (d && !(d instanceof Error) && e(
            (c || "React class") + ": type specification of " + s + " `" + l + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in r)) {
            r[d.message] = !0;
            var h = p ? p() : "";
            e(
              "Failed " + s + " type: " + d.message + (h ?? "")
            );
          }
        }
    }
  }
  return n.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, Ks = n, Ks;
}
var Xs, ff;
function Pb() {
  if (ff) return Xs;
  ff = 1;
  var e = Sc(), t = kb(), r = /* @__PURE__ */ kc(), o = /* @__PURE__ */ Gp(), n = /* @__PURE__ */ Cb(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var c = "Warning: " + s;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Xs = function(s, c) {
    var p = typeof Symbol == "function" && Symbol.iterator, l = "@@iterator";
    function d(te) {
      var de = te && (p && te[p] || te[l]);
      if (typeof de == "function")
        return de;
    }
    var u = "<<anonymous>>", h = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: x(),
      arrayOf: E,
      element: T(),
      elementType: C(),
      instanceOf: R,
      node: O(),
      objectOf: j,
      oneOf: A,
      oneOfType: N,
      shape: H,
      exact: G
    };
    function y(te, de) {
      return te === de ? te !== 0 || 1 / te === 1 / de : te !== te && de !== de;
    }
    function f(te, de) {
      this.message = te, this.data = de && typeof de == "object" ? de : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function b(te) {
      if (process.env.NODE_ENV !== "production")
        var de = {}, ae = 0;
      function z(oe, ye, V, q, ee, ue, ge) {
        if (q = q || u, ue = ue || V, ge !== r) {
          if (c) {
            var he = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw he.name = "Invariant Violation", he;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var W = q + ":" + V;
            !de[W] && // Avoid spamming the console because they are often not actionable except for lib authors
            ae < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + ue + "` prop on `" + q + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), de[W] = !0, ae++);
          }
        }
        return ye[V] == null ? oe ? ye[V] === null ? new f("The " + ee + " `" + ue + "` is marked as required " + ("in `" + q + "`, but its value is `null`.")) : new f("The " + ee + " `" + ue + "` is marked as required in " + ("`" + q + "`, but its value is `undefined`.")) : null : te(ye, V, q, ee, ue);
      }
      var Z = z.bind(null, !1);
      return Z.isRequired = z.bind(null, !0), Z;
    }
    function w(te) {
      function de(ae, z, Z, oe, ye, V) {
        var q = ae[z], ee = M(q);
        if (ee !== te) {
          var ue = k(q);
          return new f(
            "Invalid " + oe + " `" + ye + "` of type " + ("`" + ue + "` supplied to `" + Z + "`, expected ") + ("`" + te + "`."),
            { expectedType: te }
          );
        }
        return null;
      }
      return b(de);
    }
    function x() {
      return b(a);
    }
    function E(te) {
      function de(ae, z, Z, oe, ye) {
        if (typeof te != "function")
          return new f("Property `" + ye + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var V = ae[z];
        if (!Array.isArray(V)) {
          var q = M(V);
          return new f("Invalid " + oe + " `" + ye + "` of type " + ("`" + q + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var ee = 0; ee < V.length; ee++) {
          var ue = te(V, ee, Z, oe, ye + "[" + ee + "]", r);
          if (ue instanceof Error)
            return ue;
        }
        return null;
      }
      return b(de);
    }
    function T() {
      function te(de, ae, z, Z, oe) {
        var ye = de[ae];
        if (!s(ye)) {
          var V = M(ye);
          return new f("Invalid " + Z + " `" + oe + "` of type " + ("`" + V + "` supplied to `" + z + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(te);
    }
    function C() {
      function te(de, ae, z, Z, oe) {
        var ye = de[ae];
        if (!e.isValidElementType(ye)) {
          var V = M(ye);
          return new f("Invalid " + Z + " `" + oe + "` of type " + ("`" + V + "` supplied to `" + z + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(te);
    }
    function R(te) {
      function de(ae, z, Z, oe, ye) {
        if (!(ae[z] instanceof te)) {
          var V = te.name || u, q = ne(ae[z]);
          return new f("Invalid " + oe + " `" + ye + "` of type " + ("`" + q + "` supplied to `" + Z + "`, expected ") + ("instance of `" + V + "`."));
        }
        return null;
      }
      return b(de);
    }
    function A(te) {
      if (!Array.isArray(te))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function de(ae, z, Z, oe, ye) {
        for (var V = ae[z], q = 0; q < te.length; q++)
          if (y(V, te[q]))
            return null;
        var ee = JSON.stringify(te, function(ge, he) {
          var W = k(he);
          return W === "symbol" ? String(he) : he;
        });
        return new f("Invalid " + oe + " `" + ye + "` of value `" + String(V) + "` " + ("supplied to `" + Z + "`, expected one of " + ee + "."));
      }
      return b(de);
    }
    function j(te) {
      function de(ae, z, Z, oe, ye) {
        if (typeof te != "function")
          return new f("Property `" + ye + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var V = ae[z], q = M(V);
        if (q !== "object")
          return new f("Invalid " + oe + " `" + ye + "` of type " + ("`" + q + "` supplied to `" + Z + "`, expected an object."));
        for (var ee in V)
          if (o(V, ee)) {
            var ue = te(V, ee, Z, oe, ye + "." + ee, r);
            if (ue instanceof Error)
              return ue;
          }
        return null;
      }
      return b(de);
    }
    function N(te) {
      if (!Array.isArray(te))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var de = 0; de < te.length; de++) {
        var ae = te[de];
        if (typeof ae != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + $(ae) + " at index " + de + "."
          ), a;
      }
      function z(Z, oe, ye, V, q) {
        for (var ee = [], ue = 0; ue < te.length; ue++) {
          var ge = te[ue], he = ge(Z, oe, ye, V, q, r);
          if (he == null)
            return null;
          he.data && o(he.data, "expectedType") && ee.push(he.data.expectedType);
        }
        var W = ee.length > 0 ? ", expected one of type [" + ee.join(", ") + "]" : "";
        return new f("Invalid " + V + " `" + q + "` supplied to " + ("`" + ye + "`" + W + "."));
      }
      return b(z);
    }
    function O() {
      function te(de, ae, z, Z, oe) {
        return X(de[ae]) ? null : new f("Invalid " + Z + " `" + oe + "` supplied to " + ("`" + z + "`, expected a ReactNode."));
      }
      return b(te);
    }
    function D(te, de, ae, z, Z) {
      return new f(
        (te || "React class") + ": " + de + " type `" + ae + "." + z + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function H(te) {
      function de(ae, z, Z, oe, ye) {
        var V = ae[z], q = M(V);
        if (q !== "object")
          return new f("Invalid " + oe + " `" + ye + "` of type `" + q + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var ee in te) {
          var ue = te[ee];
          if (typeof ue != "function")
            return D(Z, oe, ye, ee, k(ue));
          var ge = ue(V, ee, Z, oe, ye + "." + ee, r);
          if (ge)
            return ge;
        }
        return null;
      }
      return b(de);
    }
    function G(te) {
      function de(ae, z, Z, oe, ye) {
        var V = ae[z], q = M(V);
        if (q !== "object")
          return new f("Invalid " + oe + " `" + ye + "` of type `" + q + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var ee = t({}, ae[z], te);
        for (var ue in ee) {
          var ge = te[ue];
          if (o(te, ue) && typeof ge != "function")
            return D(Z, oe, ye, ue, k(ge));
          if (!ge)
            return new f(
              "Invalid " + oe + " `" + ye + "` key `" + ue + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(ae[z], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(te), null, "  ")
            );
          var he = ge(V, ue, Z, oe, ye + "." + ue, r);
          if (he)
            return he;
        }
        return null;
      }
      return b(de);
    }
    function X(te) {
      switch (typeof te) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !te;
        case "object":
          if (Array.isArray(te))
            return te.every(X);
          if (te === null || s(te))
            return !0;
          var de = d(te);
          if (de) {
            var ae = de.call(te), z;
            if (de !== te.entries) {
              for (; !(z = ae.next()).done; )
                if (!X(z.value))
                  return !1;
            } else
              for (; !(z = ae.next()).done; ) {
                var Z = z.value;
                if (Z && !X(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Q(te, de) {
      return te === "symbol" ? !0 : de ? de["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && de instanceof Symbol : !1;
    }
    function M(te) {
      var de = typeof te;
      return Array.isArray(te) ? "array" : te instanceof RegExp ? "object" : Q(de, te) ? "symbol" : de;
    }
    function k(te) {
      if (typeof te > "u" || te === null)
        return "" + te;
      var de = M(te);
      if (de === "object") {
        if (te instanceof Date)
          return "date";
        if (te instanceof RegExp)
          return "regexp";
      }
      return de;
    }
    function $(te) {
      var de = k(te);
      switch (de) {
        case "array":
        case "object":
          return "an " + de;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + de;
        default:
          return de;
      }
    }
    function ne(te) {
      return !te.constructor || !te.constructor.name ? u : te.constructor.name;
    }
    return h.checkPropTypes = n, h.resetWarningCache = n.resetWarningCache, h.PropTypes = h, h;
  }, Xs;
}
var Qs, df;
function Ib() {
  if (df) return Qs;
  df = 1;
  var e = /* @__PURE__ */ kc();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, Qs = function() {
    function o(a, s, c, p, l, d) {
      if (d !== e) {
        var u = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw u.name = "Invariant Violation", u;
      }
    }
    o.isRequired = o;
    function n() {
      return o;
    }
    var i = {
      array: o,
      bigint: o,
      bool: o,
      func: o,
      number: o,
      object: o,
      string: o,
      symbol: o,
      any: o,
      arrayOf: n,
      element: o,
      elementType: o,
      instanceOf: n,
      node: o,
      objectOf: n,
      oneOf: n,
      oneOfType: n,
      shape: n,
      exact: n,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Qs;
}
var pf;
function Nb() {
  if (pf) return zi.exports;
  if (pf = 1, process.env.NODE_ENV !== "production") {
    var e = Sc(), t = !0;
    zi.exports = /* @__PURE__ */ Pb()(e.isElement, t);
  } else
    zi.exports = /* @__PURE__ */ Ib()();
  return zi.exports;
}
var Lb = /* @__PURE__ */ Nb();
const m = /* @__PURE__ */ Qm(Lb);
function jb(e) {
  return e == null || Object.keys(e).length === 0;
}
function Kp(e) {
  const {
    styles: t,
    defaultTheme: r = {}
  } = e, o = typeof t == "function" ? (n) => t(jb(n) ? r : n) : t;
  return /* @__PURE__ */ _e.jsx(vb, {
    styles: o
  });
}
process.env.NODE_ENV !== "production" && (Kp.propTypes = {
  defaultTheme: m.object,
  styles: m.oneOfType([m.array, m.string, m.object, m.func])
});
/**
 * @mui/styled-engine v6.2.0
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function Xp(e, t) {
  const r = Nl(e, t);
  return process.env.NODE_ENV !== "production" ? (...o) => {
    const n = typeof e == "string" ? `"${e}"` : "component";
    return o.length === 0 ? console.error([`MUI: Seems like you called \`styled(${n})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : o.some((i) => i === void 0) && console.error(`MUI: the styled(${n})(...args) API requires all its args to be defined.`), r(...o);
  } : r;
}
function Mb(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const hf = [];
function yf(e) {
  return hf[0] = e, Ei(hf);
}
function Mr(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Qp(e) {
  if (/* @__PURE__ */ be.isValidElement(e) || !Mr(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r] = Qp(e[r]);
  }), t;
}
function tr(e, t, r = {
  clone: !0
}) {
  const o = r.clone ? {
    ...e
  } : e;
  return Mr(e) && Mr(t) && Object.keys(t).forEach((n) => {
    /* @__PURE__ */ be.isValidElement(t[n]) ? o[n] = t[n] : Mr(t[n]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, n) && Mr(e[n]) ? o[n] = tr(e[n], t[n], r) : r.clone ? o[n] = Mr(t[n]) ? Qp(t[n]) : t[n] : o[n] = t[n];
  }), o;
}
const Fb = (e) => {
  const t = Object.keys(e).map((r) => ({
    key: r,
    val: e[r]
  })) || [];
  return t.sort((r, o) => r.val - o.val), t.reduce((r, o) => ({
    ...r,
    [o.key]: o.val
  }), {});
};
function Db(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: r = "px",
    step: o = 5,
    ...n
  } = e, i = Fb(t), a = Object.keys(i);
  function s(u) {
    return `@media (min-width:${typeof t[u] == "number" ? t[u] : u}${r})`;
  }
  function c(u) {
    return `@media (max-width:${(typeof t[u] == "number" ? t[u] : u) - o / 100}${r})`;
  }
  function p(u, h) {
    const y = a.indexOf(h);
    return `@media (min-width:${typeof t[u] == "number" ? t[u] : u}${r}) and (max-width:${(y !== -1 && typeof t[a[y]] == "number" ? t[a[y]] : h) - o / 100}${r})`;
  }
  function l(u) {
    return a.indexOf(u) + 1 < a.length ? p(u, a[a.indexOf(u) + 1]) : s(u);
  }
  function d(u) {
    const h = a.indexOf(u);
    return h === 0 ? s(a[1]) : h === a.length - 1 ? c(a[h]) : p(u, a[a.indexOf(u) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: a,
    values: i,
    up: s,
    down: c,
    between: p,
    only: l,
    not: d,
    unit: r,
    ...n
  };
}
function Bb(e, t) {
  if (!e.containerQueries)
    return t;
  const r = Object.keys(t).filter((o) => o.startsWith("@container")).sort((o, n) => {
    var a, s;
    const i = /min-width:\s*([0-9.]+)/;
    return +(((a = o.match(i)) == null ? void 0 : a[1]) || 0) - +(((s = n.match(i)) == null ? void 0 : s[1]) || 0);
  });
  return r.length ? r.reduce((o, n) => {
    const i = t[n];
    return delete o[n], o[n] = i, o;
  }, {
    ...t
  }) : t;
}
function $b(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((r) => t.startsWith(`@${r}`)) || !!t.match(/^@\d/));
}
function Ub(e, t) {
  const r = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!r) {
    if (process.env.NODE_ENV !== "production")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The provided shorthand ${`(${t})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : Hr(18, `(${t})`));
    return null;
  }
  const [, o, n] = r, i = Number.isNaN(+o) ? o || 0 : +o;
  return e.containerQueries(n).up(i);
}
function zb(e) {
  const t = (i, a) => i.replace("@media", a ? `@container ${a}` : "@container");
  function r(i, a) {
    i.up = (...s) => t(e.breakpoints.up(...s), a), i.down = (...s) => t(e.breakpoints.down(...s), a), i.between = (...s) => t(e.breakpoints.between(...s), a), i.only = (...s) => t(e.breakpoints.only(...s), a), i.not = (...s) => {
      const c = t(e.breakpoints.not(...s), a);
      return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c;
    };
  }
  const o = {}, n = (i) => (r(o, i), o);
  return r(n), {
    ...e,
    containerQueries: n
  };
}
const Hb = {
  borderRadius: 4
}, mn = process.env.NODE_ENV !== "production" ? m.oneOfType([m.number, m.string, m.object, m.array]) : {};
function Yo(e, t) {
  return t ? tr(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const es = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, mf = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${es[e]}px)`
}, Wb = {
  containerQueries: (e) => ({
    up: (t) => {
      let r = typeof t == "number" ? t : es[t] || t;
      return typeof r == "number" && (r = `${r}px`), e ? `@container ${e} (min-width:${r})` : `@container (min-width:${r})`;
    }
  })
};
function an(e, t, r) {
  const o = e.theme || {};
  if (Array.isArray(t)) {
    const i = o.breakpoints || mf;
    return t.reduce((a, s, c) => (a[i.up(i.keys[c])] = r(t[c]), a), {});
  }
  if (typeof t == "object") {
    const i = o.breakpoints || mf;
    return Object.keys(t).reduce((a, s) => {
      if ($b(i.keys, s)) {
        const c = Ub(o.containerQueries ? o : Wb, s);
        c && (a[c] = r(t[s], s));
      } else if (Object.keys(i.values || es).includes(s)) {
        const c = i.up(s);
        a[c] = r(t[s], s);
      } else {
        const c = s;
        a[c] = t[c];
      }
      return a;
    }, {});
  }
  return r(t);
}
function Vb(e = {}) {
  var r;
  return ((r = e.keys) == null ? void 0 : r.reduce((o, n) => {
    const i = e.up(n);
    return o[i] = {}, o;
  }, {})) || {};
}
function Zb(e, t) {
  return e.reduce((r, o) => {
    const n = r[o];
    return (!n || Object.keys(n).length === 0) && delete r[o], r;
  }, t);
}
function at(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : Hr(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function ts(e, t, r = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && r) {
    const o = `vars.${t}`.split(".").reduce((n, i) => n && n[i] ? n[i] : null, e);
    if (o != null)
      return o;
  }
  return t.split(".").reduce((o, n) => o && o[n] != null ? o[n] : null, e);
}
function Pa(e, t, r, o = r) {
  let n;
  return typeof e == "function" ? n = e(r) : Array.isArray(e) ? n = e[r] || o : n = ts(e, r) || o, t && (n = t(n, o, e)), n;
}
function Dt(e) {
  const {
    prop: t,
    cssProperty: r = e.prop,
    themeKey: o,
    transform: n
  } = e, i = (a) => {
    if (a[t] == null)
      return null;
    const s = a[t], c = a.theme, p = ts(c, o) || {};
    return an(a, s, (d) => {
      let u = Pa(p, n, d);
      return d === u && typeof d == "string" && (u = Pa(p, n, `${t}${d === "default" ? "" : at(d)}`, d)), r === !1 ? u : {
        [r]: u
      };
    });
  };
  return i.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: mn
  } : {}, i.filterProps = [t], i;
}
function qb(e) {
  const t = {};
  return (r) => (t[r] === void 0 && (t[r] = e(r)), t[r]);
}
const Yb = {
  m: "margin",
  p: "padding"
}, Gb = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, gf = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, Kb = qb((e) => {
  if (e.length > 2)
    if (gf[e])
      e = gf[e];
    else
      return [e];
  const [t, r] = e.split(""), o = Yb[t], n = Gb[r] || "";
  return Array.isArray(n) ? n.map((i) => o + i) : [o + n];
}), rs = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], ns = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], Xb = [...rs, ...ns];
function Si(e, t, r, o) {
  const n = ts(e, t, !0) ?? r;
  return typeof n == "number" || typeof n == "string" ? (i) => typeof i == "string" ? i : (process.env.NODE_ENV !== "production" && typeof i != "number" && console.error(`MUI: Expected ${o} argument to be a number or a string, got ${i}.`), typeof n == "string" ? `calc(${i} * ${n})` : n * i) : Array.isArray(n) ? (i) => {
    if (typeof i == "string")
      return i;
    const a = Math.abs(i);
    process.env.NODE_ENV !== "production" && (Number.isInteger(a) ? a > n.length - 1 && console.error([`MUI: The value provided (${a}) overflows.`, `The supported values are: ${JSON.stringify(n)}.`, `${a} > ${n.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`)));
    const s = n[a];
    return i >= 0 ? s : typeof s == "number" ? -s : `-${s}`;
  } : typeof n == "function" ? n : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${n}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function Cc(e) {
  return Si(e, "spacing", 8, "spacing");
}
function Ti(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function Qb(e, t) {
  return (r) => e.reduce((o, n) => (o[n] = Ti(t, r), o), {});
}
function Jb(e, t, r, o) {
  if (!t.includes(r))
    return null;
  const n = Kb(r), i = Qb(n, o), a = e[r];
  return an(e, a, i);
}
function Jp(e, t) {
  const r = Cc(e.theme);
  return Object.keys(e).map((o) => Jb(e, t, o, r)).reduce(Yo, {});
}
function Nt(e) {
  return Jp(e, rs);
}
Nt.propTypes = process.env.NODE_ENV !== "production" ? rs.reduce((e, t) => (e[t] = mn, e), {}) : {};
Nt.filterProps = rs;
function Lt(e) {
  return Jp(e, ns);
}
Lt.propTypes = process.env.NODE_ENV !== "production" ? ns.reduce((e, t) => (e[t] = mn, e), {}) : {};
Lt.filterProps = ns;
process.env.NODE_ENV !== "production" && Xb.reduce((e, t) => (e[t] = mn, e), {});
function eh(e = 8, t = Cc({
  spacing: e
})) {
  if (e.mui)
    return e;
  const r = (...o) => (process.env.NODE_ENV !== "production" && (o.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${o.length}`)), (o.length === 0 ? [1] : o).map((i) => {
    const a = t(i);
    return typeof a == "number" ? `${a}px` : a;
  }).join(" "));
  return r.mui = !0, r;
}
function os(...e) {
  const t = e.reduce((o, n) => (n.filterProps.forEach((i) => {
    o[i] = n;
  }), o), {}), r = (o) => Object.keys(o).reduce((n, i) => t[i] ? Yo(n, t[i](o)) : n, {});
  return r.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((o, n) => Object.assign(o, n.propTypes), {}) : {}, r.filterProps = e.reduce((o, n) => o.concat(n.filterProps), []), r;
}
function mr(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function Sr(e, t) {
  return Dt({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const ev = Sr("border", mr), tv = Sr("borderTop", mr), rv = Sr("borderRight", mr), nv = Sr("borderBottom", mr), ov = Sr("borderLeft", mr), iv = Sr("borderColor"), av = Sr("borderTopColor"), sv = Sr("borderRightColor"), lv = Sr("borderBottomColor"), cv = Sr("borderLeftColor"), uv = Sr("outline", mr), fv = Sr("outlineColor"), is = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Si(e.theme, "shape.borderRadius", 4, "borderRadius"), r = (o) => ({
      borderRadius: Ti(t, o)
    });
    return an(e, e.borderRadius, r);
  }
  return null;
};
is.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: mn
} : {};
is.filterProps = ["borderRadius"];
os(ev, tv, rv, nv, ov, iv, av, sv, lv, cv, is, uv, fv);
const as = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Si(e.theme, "spacing", 8, "gap"), r = (o) => ({
      gap: Ti(t, o)
    });
    return an(e, e.gap, r);
  }
  return null;
};
as.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: mn
} : {};
as.filterProps = ["gap"];
const ss = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Si(e.theme, "spacing", 8, "columnGap"), r = (o) => ({
      columnGap: Ti(t, o)
    });
    return an(e, e.columnGap, r);
  }
  return null;
};
ss.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: mn
} : {};
ss.filterProps = ["columnGap"];
const ls = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Si(e.theme, "spacing", 8, "rowGap"), r = (o) => ({
      rowGap: Ti(t, o)
    });
    return an(e, e.rowGap, r);
  }
  return null;
};
ls.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: mn
} : {};
ls.filterProps = ["rowGap"];
const dv = Dt({
  prop: "gridColumn"
}), pv = Dt({
  prop: "gridRow"
}), hv = Dt({
  prop: "gridAutoFlow"
}), yv = Dt({
  prop: "gridAutoColumns"
}), mv = Dt({
  prop: "gridAutoRows"
}), gv = Dt({
  prop: "gridTemplateColumns"
}), bv = Dt({
  prop: "gridTemplateRows"
}), vv = Dt({
  prop: "gridTemplateAreas"
}), _v = Dt({
  prop: "gridArea"
});
os(as, ss, ls, dv, pv, hv, yv, mv, gv, bv, vv, _v);
function eo(e, t) {
  return t === "grey" ? t : e;
}
const wv = Dt({
  prop: "color",
  themeKey: "palette",
  transform: eo
}), Ev = Dt({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: eo
}), Sv = Dt({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: eo
});
os(wv, Ev, Sv);
function ur(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const Tv = Dt({
  prop: "width",
  transform: ur
}), Pc = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (r) => {
      var n, i, a, s, c;
      const o = ((a = (i = (n = e.theme) == null ? void 0 : n.breakpoints) == null ? void 0 : i.values) == null ? void 0 : a[r]) || es[r];
      return o ? ((c = (s = e.theme) == null ? void 0 : s.breakpoints) == null ? void 0 : c.unit) !== "px" ? {
        maxWidth: `${o}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: o
      } : {
        maxWidth: ur(r)
      };
    };
    return an(e, e.maxWidth, t);
  }
  return null;
};
Pc.filterProps = ["maxWidth"];
const xv = Dt({
  prop: "minWidth",
  transform: ur
}), Rv = Dt({
  prop: "height",
  transform: ur
}), Ov = Dt({
  prop: "maxHeight",
  transform: ur
}), Av = Dt({
  prop: "minHeight",
  transform: ur
});
Dt({
  prop: "size",
  cssProperty: "width",
  transform: ur
});
Dt({
  prop: "size",
  cssProperty: "height",
  transform: ur
});
const kv = Dt({
  prop: "boxSizing"
});
os(Tv, Pc, xv, Rv, Ov, Av, kv);
const xi = {
  // borders
  border: {
    themeKey: "borders",
    transform: mr
  },
  borderTop: {
    themeKey: "borders",
    transform: mr
  },
  borderRight: {
    themeKey: "borders",
    transform: mr
  },
  borderBottom: {
    themeKey: "borders",
    transform: mr
  },
  borderLeft: {
    themeKey: "borders",
    transform: mr
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: mr
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: is
  },
  // palette
  color: {
    themeKey: "palette",
    transform: eo
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: eo
  },
  backgroundColor: {
    themeKey: "palette",
    transform: eo
  },
  // spacing
  p: {
    style: Lt
  },
  pt: {
    style: Lt
  },
  pr: {
    style: Lt
  },
  pb: {
    style: Lt
  },
  pl: {
    style: Lt
  },
  px: {
    style: Lt
  },
  py: {
    style: Lt
  },
  padding: {
    style: Lt
  },
  paddingTop: {
    style: Lt
  },
  paddingRight: {
    style: Lt
  },
  paddingBottom: {
    style: Lt
  },
  paddingLeft: {
    style: Lt
  },
  paddingX: {
    style: Lt
  },
  paddingY: {
    style: Lt
  },
  paddingInline: {
    style: Lt
  },
  paddingInlineStart: {
    style: Lt
  },
  paddingInlineEnd: {
    style: Lt
  },
  paddingBlock: {
    style: Lt
  },
  paddingBlockStart: {
    style: Lt
  },
  paddingBlockEnd: {
    style: Lt
  },
  m: {
    style: Nt
  },
  mt: {
    style: Nt
  },
  mr: {
    style: Nt
  },
  mb: {
    style: Nt
  },
  ml: {
    style: Nt
  },
  mx: {
    style: Nt
  },
  my: {
    style: Nt
  },
  margin: {
    style: Nt
  },
  marginTop: {
    style: Nt
  },
  marginRight: {
    style: Nt
  },
  marginBottom: {
    style: Nt
  },
  marginLeft: {
    style: Nt
  },
  marginX: {
    style: Nt
  },
  marginY: {
    style: Nt
  },
  marginInline: {
    style: Nt
  },
  marginInlineStart: {
    style: Nt
  },
  marginInlineEnd: {
    style: Nt
  },
  marginBlock: {
    style: Nt
  },
  marginBlockStart: {
    style: Nt
  },
  marginBlockEnd: {
    style: Nt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: as
  },
  rowGap: {
    style: ls
  },
  columnGap: {
    style: ss
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: ur
  },
  maxWidth: {
    style: Pc
  },
  minWidth: {
    transform: ur
  },
  height: {
    transform: ur
  },
  maxHeight: {
    transform: ur
  },
  minHeight: {
    transform: ur
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Cv(...e) {
  const t = e.reduce((o, n) => o.concat(Object.keys(n)), []), r = new Set(t);
  return e.every((o) => r.size === Object.keys(o).length);
}
function Pv(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Iv() {
  function e(r, o, n, i) {
    const a = {
      [r]: o,
      theme: n
    }, s = i[r];
    if (!s)
      return {
        [r]: o
      };
    const {
      cssProperty: c = r,
      themeKey: p,
      transform: l,
      style: d
    } = s;
    if (o == null)
      return null;
    if (p === "typography" && o === "inherit")
      return {
        [r]: o
      };
    const u = ts(n, p) || {};
    return d ? d(a) : an(a, o, (y) => {
      let f = Pa(u, l, y);
      return y === f && typeof y == "string" && (f = Pa(u, l, `${r}${y === "default" ? "" : at(y)}`, y)), c === !1 ? f : {
        [c]: f
      };
    });
  }
  function t(r) {
    const {
      sx: o,
      theme: n = {}
    } = r || {};
    if (!o)
      return null;
    const i = n.unstable_sxConfig ?? xi;
    function a(s) {
      let c = s;
      if (typeof s == "function")
        c = s(n);
      else if (typeof s != "object")
        return s;
      if (!c)
        return null;
      const p = Vb(n.breakpoints), l = Object.keys(p);
      let d = p;
      return Object.keys(c).forEach((u) => {
        const h = Pv(c[u], n);
        if (h != null)
          if (typeof h == "object")
            if (i[u])
              d = Yo(d, e(u, h, n, i));
            else {
              const y = an({
                theme: n
              }, h, (f) => ({
                [u]: f
              }));
              Cv(y, h) ? d[u] = t({
                sx: h,
                theme: n
              }) : d = Yo(d, y);
            }
          else
            d = Yo(d, e(u, h, n, i));
      }), Bb(n, Zb(l, d));
    }
    return Array.isArray(o) ? o.map(a) : a(o);
  }
  return t;
}
const Nn = Iv();
Nn.filterProps = ["sx"];
function Nv(e, t) {
  var o;
  const r = this;
  if (r.vars) {
    if (!((o = r.colorSchemes) != null && o[e]) || typeof r.getColorSchemeSelector != "function")
      return {};
    let n = r.getColorSchemeSelector(e);
    return n === "&" ? t : ((n.includes("data-") || n.includes(".")) && (n = `*:where(${n.replace(/\s*&$/, "")}) &`), {
      [n]: t
    });
  }
  return r.palette.mode === e ? t : {};
}
function Ic(e = {}, ...t) {
  const {
    breakpoints: r = {},
    palette: o = {},
    spacing: n,
    shape: i = {},
    ...a
  } = e, s = Db(r), c = eh(n);
  let p = tr({
    breakpoints: s,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...o
    },
    spacing: c,
    shape: {
      ...Hb,
      ...i
    }
  }, a);
  return p = zb(p), p.applyStyles = Nv, p = t.reduce((l, d) => tr(l, d), p), p.unstable_sxConfig = {
    ...xi,
    ...a == null ? void 0 : a.unstable_sxConfig
  }, p.unstable_sx = function(d) {
    return Nn({
      sx: d,
      theme: this
    });
  }, p;
}
function Lv(e) {
  return Object.keys(e).length === 0;
}
function jv(e = null) {
  const t = be.useContext(Ja);
  return !t || Lv(t) ? e : t;
}
const Mv = Ic();
function Nc(e = Mv) {
  return jv(e);
}
function th({
  styles: e,
  themeId: t,
  defaultTheme: r = {}
}) {
  const o = Nc(r), n = typeof e == "function" ? e(t && o[t] || o) : e;
  return /* @__PURE__ */ _e.jsx(Kp, {
    styles: n
  });
}
process.env.NODE_ENV !== "production" && (th.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  defaultTheme: m.object,
  /**
   * @ignore
   */
  styles: m.oneOfType([m.array, m.func, m.number, m.object, m.string, m.bool]),
  /**
   * @ignore
   */
  themeId: m.string
});
const Fv = (e) => {
  var o;
  const t = {
    systemProps: {},
    otherProps: {}
  }, r = ((o = e == null ? void 0 : e.theme) == null ? void 0 : o.unstable_sxConfig) ?? xi;
  return Object.keys(e).forEach((n) => {
    r[n] ? t.systemProps[n] = e[n] : t.otherProps[n] = e[n];
  }), t;
};
function rh(e) {
  const {
    sx: t,
    ...r
  } = e, {
    systemProps: o,
    otherProps: n
  } = Fv(r);
  let i;
  return Array.isArray(t) ? i = [o, ...t] : typeof t == "function" ? i = (...a) => {
    const s = t(...a);
    return Mr(s) ? {
      ...o,
      ...s
    } : o;
  } : i = {
    ...o,
    ...t
  }, {
    ...n,
    sx: i
  };
}
const bf = (e) => e, Dv = () => {
  let e = bf;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = bf;
    }
  };
}, nh = Dv();
function oh(e) {
  var t, r, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var n = e.length;
    for (t = 0; t < n; t++) e[t] && (r = oh(e[t])) && (o && (o += " "), o += r);
  } else for (r in e) e[r] && (o && (o += " "), o += r);
  return o;
}
function ot() {
  for (var e, t, r = 0, o = "", n = arguments.length; r < n; r++) (e = arguments[r]) && (t = oh(e)) && (o && (o += " "), o += t);
  return o;
}
function Bv(e = {}) {
  const {
    themeId: t,
    defaultTheme: r,
    defaultClassName: o = "MuiBox-root",
    generateClassName: n
  } = e, i = Xp("div", {
    shouldForwardProp: (s) => s !== "theme" && s !== "sx" && s !== "as"
  })(Nn);
  return /* @__PURE__ */ be.forwardRef(function(c, p) {
    const l = Nc(r), {
      className: d,
      component: u = "div",
      ...h
    } = rh(c);
    return /* @__PURE__ */ _e.jsx(i, {
      as: u,
      ref: p,
      className: ot(d, n ? n(o) : o),
      theme: t && l[t] || l,
      ...h
    });
  });
}
const $v = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function gt(e, t, r = "Mui") {
  const o = $v[t];
  return o ? `${r}-${o}` : `${nh.generate(e)}-${t}`;
}
function ht(e, t, r = "Mui") {
  const o = {};
  return t.forEach((n) => {
    o[n] = gt(e, n, r);
  }), o;
}
var Hi = { exports: {} }, Et = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vf;
function Uv() {
  if (vf) return Et;
  vf = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), n = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), l = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), u = Symbol.for("react.offscreen"), h = Symbol.for("react.client.reference");
  function y(f) {
    if (typeof f == "object" && f !== null) {
      var b = f.$$typeof;
      switch (b) {
        case e:
          switch (f = f.type, f) {
            case r:
            case n:
            case o:
            case c:
            case p:
              return f;
            default:
              switch (f = f && f.$$typeof, f) {
                case a:
                case s:
                case d:
                case l:
                  return f;
                case i:
                  return f;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return Et.ContextConsumer = i, Et.ContextProvider = a, Et.Element = e, Et.ForwardRef = s, Et.Fragment = r, Et.Lazy = d, Et.Memo = l, Et.Portal = t, Et.Profiler = n, Et.StrictMode = o, Et.Suspense = c, Et.SuspenseList = p, Et.isContextConsumer = function(f) {
    return y(f) === i;
  }, Et.isContextProvider = function(f) {
    return y(f) === a;
  }, Et.isElement = function(f) {
    return typeof f == "object" && f !== null && f.$$typeof === e;
  }, Et.isForwardRef = function(f) {
    return y(f) === s;
  }, Et.isFragment = function(f) {
    return y(f) === r;
  }, Et.isLazy = function(f) {
    return y(f) === d;
  }, Et.isMemo = function(f) {
    return y(f) === l;
  }, Et.isPortal = function(f) {
    return y(f) === t;
  }, Et.isProfiler = function(f) {
    return y(f) === n;
  }, Et.isStrictMode = function(f) {
    return y(f) === o;
  }, Et.isSuspense = function(f) {
    return y(f) === c;
  }, Et.isSuspenseList = function(f) {
    return y(f) === p;
  }, Et.isValidElementType = function(f) {
    return typeof f == "string" || typeof f == "function" || f === r || f === n || f === o || f === c || f === p || f === u || typeof f == "object" && f !== null && (f.$$typeof === d || f.$$typeof === l || f.$$typeof === a || f.$$typeof === i || f.$$typeof === s || f.$$typeof === h || f.getModuleId !== void 0);
  }, Et.typeOf = y, Et;
}
var St = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _f;
function zv() {
  return _f || (_f = 1, process.env.NODE_ENV !== "production" && function() {
    function e(f) {
      if (typeof f == "object" && f !== null) {
        var b = f.$$typeof;
        switch (b) {
          case t:
            switch (f = f.type, f) {
              case o:
              case i:
              case n:
              case p:
              case l:
                return f;
              default:
                switch (f = f && f.$$typeof, f) {
                  case s:
                  case c:
                  case u:
                  case d:
                    return f;
                  case a:
                    return f;
                  default:
                    return b;
                }
            }
          case r:
            return b;
        }
      }
    }
    var t = Symbol.for("react.transitional.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.for("react.client.reference");
    St.ContextConsumer = a, St.ContextProvider = s, St.Element = t, St.ForwardRef = c, St.Fragment = o, St.Lazy = u, St.Memo = d, St.Portal = r, St.Profiler = i, St.StrictMode = n, St.Suspense = p, St.SuspenseList = l, St.isContextConsumer = function(f) {
      return e(f) === a;
    }, St.isContextProvider = function(f) {
      return e(f) === s;
    }, St.isElement = function(f) {
      return typeof f == "object" && f !== null && f.$$typeof === t;
    }, St.isForwardRef = function(f) {
      return e(f) === c;
    }, St.isFragment = function(f) {
      return e(f) === o;
    }, St.isLazy = function(f) {
      return e(f) === u;
    }, St.isMemo = function(f) {
      return e(f) === d;
    }, St.isPortal = function(f) {
      return e(f) === r;
    }, St.isProfiler = function(f) {
      return e(f) === i;
    }, St.isStrictMode = function(f) {
      return e(f) === n;
    }, St.isSuspense = function(f) {
      return e(f) === p;
    }, St.isSuspenseList = function(f) {
      return e(f) === l;
    }, St.isValidElementType = function(f) {
      return typeof f == "string" || typeof f == "function" || f === o || f === i || f === n || f === p || f === l || f === h || typeof f == "object" && f !== null && (f.$$typeof === u || f.$$typeof === d || f.$$typeof === s || f.$$typeof === a || f.$$typeof === c || f.$$typeof === y || f.getModuleId !== void 0);
    }, St.typeOf = e;
  }()), St;
}
var wf;
function Hv() {
  return wf || (wf = 1, process.env.NODE_ENV === "production" ? Hi.exports = /* @__PURE__ */ Uv() : Hi.exports = /* @__PURE__ */ zv()), Hi.exports;
}
var Ef = /* @__PURE__ */ Hv();
function ih(e, t = "") {
  return e.displayName || e.name || t;
}
function Sf(e, t, r) {
  const o = ih(t);
  return e.displayName || (o !== "" ? `${r}(${o})` : r);
}
function Wv(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return ih(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case Ef.ForwardRef:
          return Sf(e, e.render, "ForwardRef");
        case Ef.Memo:
          return Sf(e, e.type, "memo");
        default:
          return;
      }
  }
}
function ah(e) {
  const {
    variants: t,
    ...r
  } = e, o = {
    variants: t,
    style: yf(r),
    isProcessed: !0
  };
  return o.style === r || t && t.forEach((n) => {
    typeof n.style != "function" && (n.style = yf(n.style));
  }), o;
}
const Vv = Ic();
function Js(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function Zv(e) {
  return e ? (t, r) => r[e] : null;
}
function qv(e, t, r) {
  e.theme = Xv(e.theme) ? r : e.theme[t] || e.theme;
}
function ha(e, t) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((o) => ha(e, o));
  if (Array.isArray(r == null ? void 0 : r.variants)) {
    let o;
    if (r.isProcessed)
      o = r.style;
    else {
      const {
        variants: n,
        ...i
      } = r;
      o = i;
    }
    return sh(e, r.variants, [o]);
  }
  return r != null && r.isProcessed ? r.style : r;
}
function sh(e, t, r = []) {
  var n;
  let o;
  e: for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    if (typeof a.props == "function") {
      if (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !a.props(o))
        continue;
    } else
      for (const s in a.props)
        if (e[s] !== a.props[s] && ((n = e.ownerState) == null ? void 0 : n[s]) !== a.props[s])
          continue e;
    typeof a.style == "function" ? (o ?? (o = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), r.push(a.style(o))) : r.push(a.style);
  }
  return r;
}
function Yv(e = {}) {
  const {
    themeId: t,
    defaultTheme: r = Vv,
    rootShouldForwardProp: o = Js,
    slotShouldForwardProp: n = Js
  } = e;
  function i(s) {
    qv(s, t, r);
  }
  return (s, c = {}) => {
    Mb(s, (C) => C.filter((R) => R !== Nn));
    const {
      name: p,
      slot: l,
      skipVariantsResolver: d,
      skipSx: u,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: h = Zv(lh(l)),
      ...y
    } = c, f = d !== void 0 ? d : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      l && l !== "Root" && l !== "root" || !1
    ), b = u || !1;
    let w = Js;
    l === "Root" || l === "root" ? w = o : l ? w = n : Qv(s) && (w = void 0);
    const x = Xp(s, {
      shouldForwardProp: w,
      label: Kv(p, l),
      ...y
    }), E = (C) => {
      if (typeof C == "function" && C.__emotion_real !== C)
        return function(A) {
          return ha(A, C);
        };
      if (Mr(C)) {
        const R = ah(C);
        return R.variants ? function(j) {
          return ha(j, R);
        } : R.style;
      }
      return C;
    }, T = (...C) => {
      const R = [], A = C.map(E), j = [];
      if (R.push(i), p && h && j.push(function(H) {
        var M, k;
        const X = (k = (M = H.theme.components) == null ? void 0 : M[p]) == null ? void 0 : k.styleOverrides;
        if (!X)
          return null;
        const Q = {};
        for (const $ in X)
          Q[$] = ha(H, X[$]);
        return h(H, Q);
      }), p && !f && j.push(function(H) {
        var Q, M;
        const G = H.theme, X = (M = (Q = G == null ? void 0 : G.components) == null ? void 0 : Q[p]) == null ? void 0 : M.variants;
        return X ? sh(H, X) : null;
      }), b || j.push(Nn), Array.isArray(A[0])) {
        const D = A.shift(), H = new Array(R.length).fill(""), G = new Array(j.length).fill("");
        let X;
        X = [...H, ...D, ...G], X.raw = [...H, ...D.raw, ...G], R.unshift(X);
      }
      const N = [...R, ...A, ...j], O = x(...N);
      return s.muiName && (O.muiName = s.muiName), process.env.NODE_ENV !== "production" && (O.displayName = Gv(p, l, s)), O;
    };
    return x.withConfig && (T.withConfig = x.withConfig), T;
  };
}
function Gv(e, t, r) {
  return e ? `${e}${at(t || "")}` : `Styled(${Wv(r)})`;
}
function Kv(e, t) {
  let r;
  return process.env.NODE_ENV !== "production" && e && (r = `${e}-${lh(t || "Root")}`), r;
}
function Xv(e) {
  for (const t in e)
    return !1;
  return !0;
}
function Qv(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function lh(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Ia(e, t) {
  const r = {
    ...t
  };
  for (const o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      const n = o;
      if (n === "components" || n === "slots")
        r[n] = {
          ...e[n],
          ...r[n]
        };
      else if (n === "componentsProps" || n === "slotProps") {
        const i = e[n], a = t[n];
        if (!a)
          r[n] = i || {};
        else if (!i)
          r[n] = a;
        else {
          r[n] = {
            ...a
          };
          for (const s in i)
            if (Object.prototype.hasOwnProperty.call(i, s)) {
              const c = s;
              r[n][c] = Ia(i[c], a[c]);
            }
        }
      } else r[n] === void 0 && (r[n] = e[n]);
    }
  return r;
}
const Wr = typeof window < "u" ? be.useLayoutEffect : be.useEffect;
function Jv(e, t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, r));
}
function Lc(e, t = 0, r = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > r) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${r}].`), Jv(e, t, r);
}
function e_(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let r = e.match(t);
  return r && r[0].length === 1 && (r = r.map((o) => o + o)), r ? `rgb${r.length === 4 ? "a" : ""}(${r.map((o, n) => n < 3 ? parseInt(o, 16) : Math.round(parseInt(o, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function hn(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return hn(e_(e));
  const t = e.indexOf("("), r = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(r))
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : Hr(9, e));
  let o = e.substring(t + 1, e.length - 1), n;
  if (r === "color") {
    if (o = o.split(" "), n = o.shift(), o.length === 4 && o[3].charAt(0) === "/" && (o[3] = o[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(n))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${n}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : Hr(10, n));
  } else
    o = o.split(",");
  return o = o.map((i) => parseFloat(i)), {
    type: r,
    values: o,
    colorSpace: n
  };
}
const t_ = (e) => {
  const t = hn(e);
  return t.values.slice(0, 3).map((r, o) => t.type.includes("hsl") && o !== 0 ? `${r}%` : r).join(" ");
}, Ho = (e, t) => {
  try {
    return t_(e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), e;
  }
};
function cs(e) {
  const {
    type: t,
    colorSpace: r
  } = e;
  let {
    values: o
  } = e;
  return t.includes("rgb") ? o = o.map((n, i) => i < 3 ? parseInt(n, 10) : n) : t.includes("hsl") && (o[1] = `${o[1]}%`, o[2] = `${o[2]}%`), t.includes("color") ? o = `${r} ${o.join(" ")}` : o = `${o.join(", ")}`, `${t}(${o})`;
}
function ch(e) {
  e = hn(e);
  const {
    values: t
  } = e, r = t[0], o = t[1] / 100, n = t[2] / 100, i = o * Math.min(n, 1 - n), a = (p, l = (p + r / 30) % 12) => n - i * Math.max(Math.min(l - 3, 9 - l, 1), -1);
  let s = "rgb";
  const c = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
  return e.type === "hsla" && (s += "a", c.push(t[3])), cs({
    type: s,
    values: c
  });
}
function Ll(e) {
  e = hn(e);
  let t = e.type === "hsl" || e.type === "hsla" ? hn(ch(e)).values : e.values;
  return t = t.map((r) => (e.type !== "color" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function Tf(e, t) {
  const r = Ll(e), o = Ll(t);
  return (Math.max(r, o) + 0.05) / (Math.min(r, o) + 0.05);
}
function Qt(e, t) {
  return e = hn(e), t = Lc(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, cs(e);
}
function Wi(e, t, r) {
  try {
    return Qt(e, t);
  } catch {
    return e;
  }
}
function jc(e, t) {
  if (e = hn(e), t = Lc(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let r = 0; r < 3; r += 1)
      e.values[r] *= 1 - t;
  return cs(e);
}
function Ot(e, t, r) {
  try {
    return jc(e, t);
  } catch {
    return e;
  }
}
function Mc(e, t) {
  if (e = hn(e), t = Lc(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let r = 0; r < 3; r += 1)
      e.values[r] += (255 - e.values[r]) * t;
  else if (e.type.includes("color"))
    for (let r = 0; r < 3; r += 1)
      e.values[r] += (1 - e.values[r]) * t;
  return cs(e);
}
function At(e, t, r) {
  try {
    return Mc(e, t);
  } catch {
    return e;
  }
}
function r_(e, t = 0.15) {
  return Ll(e) > 0.5 ? jc(e, t) : Mc(e, t);
}
function Vi(e, t, r) {
  try {
    return r_(e, t);
  } catch {
    return e;
  }
}
function gn(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...o) {
    return e(...o) || t(...o);
  };
}
function n_(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function uh(e, t, r, o, n) {
  const i = e[t], a = n || t;
  if (i == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  const c = i.type;
  return typeof c == "function" && !n_(c) && (s = "Did you accidentally use a plain function component for an element instead?"), s !== void 0 ? new Error(`Invalid ${o} \`${a}\` supplied to \`${r}\`. Expected an element that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const bo = gn(m.element, uh);
bo.isRequired = gn(m.element.isRequired, uh);
function o_(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function i_(e, t, r, o, n) {
  const i = e[t], a = n || t;
  if (i == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  return typeof i == "function" && !o_(i) && (s = "Did you accidentally provide a plain function component instead?"), s !== void 0 ? new Error(`Invalid ${o} \`${a}\` supplied to \`${r}\`. Expected an element type that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const us = gn(m.elementType, i_), a_ = "exact-prop: ​";
function fh(e) {
  return process.env.NODE_ENV === "production" ? e : {
    ...e,
    [a_]: (t) => {
      const r = Object.keys(t).filter((o) => !e.hasOwnProperty(o));
      return r.length > 0 ? new Error(`The following props are not supported: ${r.map((o) => `\`${o}\``).join(", ")}. Please remove them.`) : null;
    }
  };
}
function sn(e, t, r, o, n) {
  if (process.env.NODE_ENV === "production")
    return null;
  const i = e[t], a = n || t;
  return i == null ? null : i && i.nodeType !== 1 ? new Error(`Invalid ${o} \`${a}\` supplied to \`${r}\`. Expected an HTMLElement.`) : null;
}
const Ar = m.oneOfType([m.func, m.object]);
function xf(...e) {
  return e.reduce((t, r) => r == null ? t : function(...n) {
    t.apply(this, n), r.apply(this, n);
  }, () => {
  });
}
function dh(e, t = 166) {
  let r;
  function o(...n) {
    const i = () => {
      e.apply(this, n);
    };
    clearTimeout(r), r = setTimeout(i, t);
  }
  return o.clear = () => {
    clearTimeout(r);
  }, o;
}
function Go(e, t) {
  var r, o, n;
  return /* @__PURE__ */ be.isValidElement(e) && t.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? ((n = (o = (r = e.type) == null ? void 0 : r._payload) == null ? void 0 : o.value) == null ? void 0 : n.muiName)
  ) !== -1;
}
function pr(e) {
  return e && e.ownerDocument || document;
}
function ln(e) {
  return pr(e).defaultView || window;
}
function jl(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
let Rf = 0;
function s_(e) {
  const [t, r] = be.useState(e), o = e || t;
  return be.useEffect(() => {
    t == null && (Rf += 1, r(`mui-${Rf}`));
  }, [t]), o;
}
const l_ = {
  ...be
}, Of = l_.useId;
function Fc(e) {
  if (Of !== void 0) {
    const t = Of();
    return e ?? t;
  }
  return s_(e);
}
function Ml({
  controlled: e,
  default: t,
  name: r,
  state: o = "value"
}) {
  const {
    current: n
  } = be.useRef(e !== void 0), [i, a] = be.useState(t), s = n ? e : i;
  if (process.env.NODE_ENV !== "production") {
    be.useEffect(() => {
      n !== (e !== void 0) && console.error([`MUI: A component is changing the ${n ? "" : "un"}controlled ${o} state of ${r} to be ${n ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [o, r, e]);
    const {
      current: p
    } = be.useRef(t);
    be.useEffect(() => {
      !n && !Object.is(p, t) && console.error([`MUI: A component is changing the default ${o} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const c = be.useCallback((p) => {
    n || a(p);
  }, []);
  return [s, c];
}
function dn(e) {
  const t = be.useRef(e);
  return Wr(() => {
    t.current = e;
  }), be.useRef((...r) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...r)
  )).current;
}
function Mt(...e) {
  return be.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((r) => {
      jl(r, t);
    });
  }, e);
}
const Af = {};
function ph(e, t) {
  const r = be.useRef(Af);
  return r.current === Af && (r.current = e(t)), r;
}
const c_ = [];
function u_(e) {
  be.useEffect(e, c_);
}
class fs {
  constructor() {
    Kr(this, "currentId", null);
    Kr(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Kr(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new fs();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, r) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, r();
    }, t);
  }
}
function Kn() {
  const e = ph(fs.create).current;
  return u_(e.disposeEffect), e;
}
function Na(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
    process.env.NODE_ENV !== "production" && !/jsdom/.test(window.navigator.userAgent) && console.warn(["MUI: The `:focus-visible` pseudo class is not supported in this browser.", "Some components rely on this feature to work properly."].join(`
`));
  }
  return !1;
}
function hh(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function f_(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function yh(e, t, r, o) {
  const n = e[t];
  if (n == null || !Number.isInteger(n)) {
    const i = f_(n);
    return new RangeError(`Invalid ${o} \`${t}\` of type \`${i}\` supplied to \`${r}\`, expected \`integer\`.`);
  }
  return null;
}
function mh(e, t, ...r) {
  return e[t] === void 0 ? null : yh(e, t, ...r);
}
function Fl() {
  return null;
}
mh.isRequired = yh;
Fl.isRequired = Fl;
const gh = process.env.NODE_ENV === "production" ? Fl : mh;
function _t(e, t, r = void 0) {
  const o = {};
  for (const n in e) {
    const i = e[n];
    let a = "", s = !0;
    for (let c = 0; c < i.length; c += 1) {
      const p = i[c];
      p && (a += (s === !0 ? "" : " ") + t(p), s = !1, r && r[p] && (a += " " + r[p]));
    }
    o[n] = a;
  }
  return o;
}
function d_(e) {
  return typeof e == "string";
}
function bh(e, t, r) {
  return e === void 0 || d_(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...r
    }
  };
}
function vh(e, t = []) {
  if (e === void 0)
    return {};
  const r = {};
  return Object.keys(e).filter((o) => o.match(/^on[A-Z]/) && typeof e[o] == "function" && !t.includes(o)).forEach((o) => {
    r[o] = e[o];
  }), r;
}
function kf(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((r) => !(r.match(/^on[A-Z]/) && typeof e[r] == "function")).forEach((r) => {
    t[r] = e[r];
  }), t;
}
function _h(e) {
  const {
    getSlotProps: t,
    additionalProps: r,
    externalSlotProps: o,
    externalForwardedProps: n,
    className: i
  } = e;
  if (!t) {
    const h = ot(r == null ? void 0 : r.className, i, n == null ? void 0 : n.className, o == null ? void 0 : o.className), y = {
      ...r == null ? void 0 : r.style,
      ...n == null ? void 0 : n.style,
      ...o == null ? void 0 : o.style
    }, f = {
      ...r,
      ...n,
      ...o
    };
    return h.length > 0 && (f.className = h), Object.keys(y).length > 0 && (f.style = y), {
      props: f,
      internalRef: void 0
    };
  }
  const a = vh({
    ...n,
    ...o
  }), s = kf(o), c = kf(n), p = t(a), l = ot(p == null ? void 0 : p.className, r == null ? void 0 : r.className, i, n == null ? void 0 : n.className, o == null ? void 0 : o.className), d = {
    ...p == null ? void 0 : p.style,
    ...r == null ? void 0 : r.style,
    ...n == null ? void 0 : n.style,
    ...o == null ? void 0 : o.style
  }, u = {
    ...p,
    ...r,
    ...c,
    ...s
  };
  return l.length > 0 && (u.className = l), Object.keys(d).length > 0 && (u.style = d), {
    props: u,
    internalRef: p.ref
  };
}
function wh(e, t, r) {
  return typeof e == "function" ? e(t, r) : e;
}
function Dl(e) {
  var d;
  const {
    elementType: t,
    externalSlotProps: r,
    ownerState: o,
    skipResolvingSlotProps: n = !1,
    ...i
  } = e, a = n ? {} : wh(r, o), {
    props: s,
    internalRef: c
  } = _h({
    ...i,
    externalSlotProps: a
  }), p = Mt(c, a == null ? void 0 : a.ref, (d = e.additionalProps) == null ? void 0 : d.ref);
  return bh(t, {
    ...s,
    ref: p
  }, o);
}
function vo(e) {
  var t;
  return parseInt(be.version, 10) >= 19 ? ((t = e == null ? void 0 : e.props) == null ? void 0 : t.ref) || null : (e == null ? void 0 : e.ref) || null;
}
const p_ = /* @__PURE__ */ be.createContext();
process.env.NODE_ENV !== "production" && (m.node, m.bool);
const Dc = () => be.useContext(p_) ?? !1, h_ = /* @__PURE__ */ be.createContext(void 0);
process.env.NODE_ENV !== "production" && (m.node, m.object);
function y_(e) {
  const {
    theme: t,
    name: r,
    props: o
  } = e;
  if (!t || !t.components || !t.components[r])
    return o;
  const n = t.components[r];
  return n.defaultProps ? Ia(n.defaultProps, o) : !n.styleOverrides && !n.variants ? Ia(n, o) : o;
}
function m_({
  props: e,
  name: t
}) {
  const r = be.useContext(h_);
  return y_({
    props: e,
    name: t,
    theme: {
      components: r
    }
  });
}
const Cf = {
  theme: void 0
};
function g_(e) {
  let t, r;
  return function(n) {
    let i = t;
    return (i === void 0 || n.theme !== r) && (Cf.theme = n.theme, i = ah(e(Cf)), t = i, r = n.theme), i;
  };
}
function b_(e = "") {
  function t(...o) {
    if (!o.length)
      return "";
    const n = o[0];
    return typeof n == "string" && !n.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${n}${t(...o.slice(1))})` : `, ${n}`;
  }
  return (o, ...n) => `var(--${e ? `${e}-` : ""}${o}${t(...n)})`;
}
const Pf = (e, t, r, o = []) => {
  let n = e;
  t.forEach((i, a) => {
    a === t.length - 1 ? Array.isArray(n) ? n[Number(i)] = r : n && typeof n == "object" && (n[i] = r) : n && typeof n == "object" && (n[i] || (n[i] = o.includes(i) ? [] : {}), n = n[i]);
  });
}, v_ = (e, t, r) => {
  function o(n, i = [], a = []) {
    Object.entries(n).forEach(([s, c]) => {
      (!r || r && !r([...i, s])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? o(c, [...i, s], Array.isArray(c) ? [...a, s] : a) : t([...i, s], c, a));
    });
  }
  o(e);
}, __ = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((o) => e.includes(o)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function el(e, t) {
  const {
    prefix: r,
    shouldSkipGeneratingVar: o
  } = t || {}, n = {}, i = {}, a = {};
  return v_(
    e,
    (s, c, p) => {
      if ((typeof c == "string" || typeof c == "number") && (!o || !o(s, c))) {
        const l = `--${r ? `${r}-` : ""}${s.join("-")}`, d = __(s, c);
        Object.assign(n, {
          [l]: d
        }), Pf(i, s, `var(${l})`, p), Pf(a, s, `var(${l}, ${d})`, p);
      }
    },
    (s) => s[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: n,
    vars: i,
    varsWithDefaults: a
  };
}
function w_(e, t = {}) {
  const {
    getSelector: r = b,
    disableCssColorScheme: o,
    colorSchemeSelector: n
  } = t, {
    colorSchemes: i = {},
    components: a,
    defaultColorScheme: s = "light",
    ...c
  } = e, {
    vars: p,
    css: l,
    varsWithDefaults: d
  } = el(c, t);
  let u = d;
  const h = {}, {
    [s]: y,
    ...f
  } = i;
  if (Object.entries(f || {}).forEach(([E, T]) => {
    const {
      vars: C,
      css: R,
      varsWithDefaults: A
    } = el(T, t);
    u = tr(u, A), h[E] = {
      css: R,
      vars: C
    };
  }), y) {
    const {
      css: E,
      vars: T,
      varsWithDefaults: C
    } = el(y, t);
    u = tr(u, C), h[s] = {
      css: E,
      vars: T
    };
  }
  function b(E, T) {
    var R, A;
    let C = n;
    if (n === "class" && (C = ".%s"), n === "data" && (C = "[data-%s]"), n != null && n.startsWith("data-") && !n.includes("%s") && (C = `[${n}="%s"]`), E) {
      if (C === "media")
        return e.defaultColorScheme === E ? ":root" : {
          [`@media (prefers-color-scheme: ${((A = (R = i[E]) == null ? void 0 : R.palette) == null ? void 0 : A.mode) || E})`]: {
            ":root": T
          }
        };
      if (C)
        return e.defaultColorScheme === E ? `:root, ${C.replace("%s", String(E))}` : C.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: u,
    generateThemeVars: () => {
      let E = {
        ...p
      };
      return Object.entries(h).forEach(([, {
        vars: T
      }]) => {
        E = tr(E, T);
      }), E;
    },
    generateStyleSheets: () => {
      var j, N;
      const E = [], T = e.defaultColorScheme || "light";
      function C(O, D) {
        Object.keys(D).length && E.push(typeof O == "string" ? {
          [O]: {
            ...D
          }
        } : O);
      }
      C(r(void 0, {
        ...l
      }), l);
      const {
        [T]: R,
        ...A
      } = h;
      if (R) {
        const {
          css: O
        } = R, D = (N = (j = i[T]) == null ? void 0 : j.palette) == null ? void 0 : N.mode, H = !o && D ? {
          colorScheme: D,
          ...O
        } : {
          ...O
        };
        C(r(T, {
          ...H
        }), H);
      }
      return Object.entries(A).forEach(([O, {
        css: D
      }]) => {
        var X, Q;
        const H = (Q = (X = i[O]) == null ? void 0 : X.palette) == null ? void 0 : Q.mode, G = !o && H ? {
          colorScheme: H,
          ...D
        } : {
          ...D
        };
        C(r(O, {
          ...G
        }), G);
      }), E;
    }
  };
}
function E_(e) {
  return function(r) {
    return e === "media" ? (process.env.NODE_ENV !== "production" && r !== "light" && r !== "dark" && console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${r}'.`), `@media (prefers-color-scheme: ${r})`) : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${r}"] &` : e === "class" ? `.${r} &` : e === "data" ? `[data-${r}] &` : `${e.replace("%s", r)} &` : "&";
  };
}
function Eh() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: ri.white,
      default: ri.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const S_ = Eh();
function Sh() {
  return {
    text: {
      primary: ri.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: ri.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const If = Sh();
function Nf(e, t, r, o) {
  const n = o.light || o, i = o.dark || o * 1.5;
  e[t] || (e.hasOwnProperty(r) ? e[t] = e[r] : t === "light" ? e.light = Mc(e.main, n) : t === "dark" && (e.dark = jc(e.main, i)));
}
function T_(e = "light") {
  return e === "dark" ? {
    main: Bn[200],
    light: Bn[50],
    dark: Bn[400]
  } : {
    main: Bn[700],
    light: Bn[400],
    dark: Bn[800]
  };
}
function x_(e = "light") {
  return e === "dark" ? {
    main: Dn[200],
    light: Dn[50],
    dark: Dn[400]
  } : {
    main: Dn[500],
    light: Dn[300],
    dark: Dn[700]
  };
}
function R_(e = "light") {
  return e === "dark" ? {
    main: Fn[500],
    light: Fn[300],
    dark: Fn[700]
  } : {
    main: Fn[700],
    light: Fn[400],
    dark: Fn[800]
  };
}
function O_(e = "light") {
  return e === "dark" ? {
    main: $n[400],
    light: $n[300],
    dark: $n[700]
  } : {
    main: $n[700],
    light: $n[500],
    dark: $n[900]
  };
}
function A_(e = "light") {
  return e === "dark" ? {
    main: Un[400],
    light: Un[300],
    dark: Un[700]
  } : {
    main: Un[800],
    light: Un[500],
    dark: Un[900]
  };
}
function k_(e = "light") {
  return e === "dark" ? {
    main: Io[400],
    light: Io[300],
    dark: Io[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Io[500],
    dark: Io[900]
  };
}
function Bc(e) {
  const {
    mode: t = "light",
    contrastThreshold: r = 3,
    tonalOffset: o = 0.2,
    ...n
  } = e, i = e.primary || T_(t), a = e.secondary || x_(t), s = e.error || R_(t), c = e.info || O_(t), p = e.success || A_(t), l = e.warning || k_(t);
  function d(f) {
    const b = Tf(f, If.text.primary) >= r ? If.text.primary : S_.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const w = Tf(f, b);
      w < 3 && console.error([`MUI: The contrast ratio of ${w}:1 for ${b} on ${f}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return b;
  }
  const u = ({
    color: f,
    name: b,
    mainShade: w = 500,
    lightShade: x = 300,
    darkShade: E = 700
  }) => {
    if (f = {
      ...f
    }, !f.main && f[w] && (f.main = f[w]), !f.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${b ? ` (${b})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${w}\` property.` : Hr(11, b ? ` (${b})` : "", w));
    if (typeof f.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${b ? ` (${b})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(f.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : Hr(12, b ? ` (${b})` : "", JSON.stringify(f.main)));
    return Nf(f, "light", x, o), Nf(f, "dark", E, o), f.contrastText || (f.contrastText = d(f.main)), f;
  };
  let h;
  return t === "light" ? h = Eh() : t === "dark" && (h = Sh()), process.env.NODE_ENV !== "production" && (h || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), tr({
    // A collection of common colors.
    common: {
      ...ri
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: u({
      color: i,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: u({
      color: a,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: u({
      color: s,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: u({
      color: l,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: u({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: u({
      color: p,
      name: "success"
    }),
    // The grey colors.
    grey: x0,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: r,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: d,
    // Generate a rich color object.
    augmentColor: u,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: o,
    // The light and dark mode object.
    ...h
  }, n);
}
function C_(e) {
  const t = {};
  return Object.entries(e).forEach((o) => {
    const [n, i] = o;
    typeof i == "object" && (t[n] = `${i.fontStyle ? `${i.fontStyle} ` : ""}${i.fontVariant ? `${i.fontVariant} ` : ""}${i.fontWeight ? `${i.fontWeight} ` : ""}${i.fontStretch ? `${i.fontStretch} ` : ""}${i.fontSize || ""}${i.lineHeight ? `/${i.lineHeight} ` : ""}${i.fontFamily || ""}`);
  }), t;
}
function P_(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function I_(e) {
  return Math.round(e * 1e5) / 1e5;
}
const Lf = {
  textTransform: "uppercase"
}, jf = '"Roboto", "Helvetica", "Arial", sans-serif';
function N_(e, t) {
  const {
    fontFamily: r = jf,
    // The default font size of the Material Specification.
    fontSize: o = 14,
    // px
    fontWeightLight: n = 300,
    fontWeightRegular: i = 400,
    fontWeightMedium: a = 500,
    fontWeightBold: s = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: c = 16,
    // Apply the CSS properties to all the variants.
    allVariants: p,
    pxToRem: l,
    ...d
  } = typeof t == "function" ? t(e) : t;
  process.env.NODE_ENV !== "production" && (typeof o != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof c != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const u = o / 14, h = l || ((b) => `${b / c * u}rem`), y = (b, w, x, E, T) => ({
    fontFamily: r,
    fontWeight: b,
    fontSize: h(w),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: x,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...r === jf ? {
      letterSpacing: `${I_(E / w)}em`
    } : {},
    ...T,
    ...p
  }), f = {
    h1: y(n, 96, 1.167, -1.5),
    h2: y(n, 60, 1.2, -0.5),
    h3: y(i, 48, 1.167, 0),
    h4: y(i, 34, 1.235, 0.25),
    h5: y(i, 24, 1.334, 0),
    h6: y(a, 20, 1.6, 0.15),
    subtitle1: y(i, 16, 1.75, 0.15),
    subtitle2: y(a, 14, 1.57, 0.1),
    body1: y(i, 16, 1.5, 0.15),
    body2: y(i, 14, 1.43, 0.15),
    button: y(a, 14, 1.75, 0.4, Lf),
    caption: y(i, 12, 1.66, 0.4),
    overline: y(i, 12, 2.66, 1, Lf),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return tr({
    htmlFontSize: c,
    pxToRem: h,
    fontFamily: r,
    fontSize: o,
    fontWeightLight: n,
    fontWeightRegular: i,
    fontWeightMedium: a,
    fontWeightBold: s,
    ...f
  }, d, {
    clone: !1
    // No need to clone deep
  });
}
const L_ = 0.2, j_ = 0.14, M_ = 0.12;
function Pt(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${L_})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${j_})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${M_})`].join(",");
}
const F_ = ["none", Pt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Pt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Pt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Pt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Pt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Pt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Pt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Pt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Pt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Pt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Pt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Pt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Pt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Pt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Pt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Pt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Pt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Pt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Pt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Pt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Pt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Pt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Pt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Pt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], D_ = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, B_ = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function Mf(e) {
  return `${Math.round(e)}ms`;
}
function $_(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function U_(e) {
  const t = {
    ...D_,
    ...e.easing
  }, r = {
    ...B_,
    ...e.duration
  };
  return {
    getAutoHeightDuration: $_,
    create: (n = ["all"], i = {}) => {
      const {
        duration: a = r.standard,
        easing: s = t.easeInOut,
        delay: c = 0,
        ...p
      } = i;
      if (process.env.NODE_ENV !== "production") {
        const l = (u) => typeof u == "string", d = (u) => !Number.isNaN(parseFloat(u));
        !l(n) && !Array.isArray(n) && console.error('MUI: Argument "props" must be a string or Array.'), !d(a) && !l(a) && console.error(`MUI: Argument "duration" must be a number or a string but found ${a}.`), l(s) || console.error('MUI: Argument "easing" must be a string.'), !d(c) && !l(c) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof i != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(p).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(p).join(",")}].`);
      }
      return (Array.isArray(n) ? n : [n]).map((l) => `${l} ${typeof a == "string" ? a : Mf(a)} ${s} ${typeof c == "string" ? c : Mf(c)}`).join(",");
    },
    ...e,
    easing: t,
    duration: r
  };
}
const z_ = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function H_(e) {
  return Mr(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function Th(e = {}) {
  const t = {
    ...e
  };
  function r(o) {
    const n = Object.entries(o);
    for (let i = 0; i < n.length; i++) {
      const [a, s] = n[i];
      !H_(s) || a.startsWith("unstable_") ? delete o[a] : Mr(s) && (o[a] = {
        ...s
      }, r(o[a]));
    }
  }
  return r(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Bl(e = {}, ...t) {
  const {
    breakpoints: r,
    mixins: o = {},
    spacing: n,
    palette: i = {},
    transitions: a = {},
    typography: s = {},
    shape: c,
    ...p
  } = e;
  if (e.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : Hr(20));
  const l = Bc(i), d = Ic(e);
  let u = tr(d, {
    mixins: P_(d.breakpoints, o),
    palette: l,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: F_.slice(),
    typography: N_(l, s),
    transitions: U_(a),
    zIndex: {
      ...z_
    }
  });
  if (u = tr(u, p), u = t.reduce((h, y) => tr(h, y), u), process.env.NODE_ENV !== "production") {
    const h = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], y = (f, b) => {
      let w;
      for (w in f) {
        const x = f[w];
        if (h.includes(w) && Object.keys(x).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const E = gt("", w);
            console.error([`MUI: The \`${b}\` component increases the CSS specificity of the \`${w}\` internal state.`, "You can not override it like this: ", JSON.stringify(f, null, 2), "", `Instead, you need to use the '&.${E}' syntax:`, JSON.stringify({
              root: {
                [`&.${E}`]: x
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          f[w] = {};
        }
      }
    };
    Object.keys(u.components).forEach((f) => {
      const b = u.components[f].styleOverrides;
      b && f.startsWith("Mui") && y(b, f);
    });
  }
  return u.unstable_sxConfig = {
    ...xi,
    ...p == null ? void 0 : p.unstable_sxConfig
  }, u.unstable_sx = function(y) {
    return Nn({
      sx: y,
      theme: this
    });
  }, u.toRuntimeSource = Th, u;
}
function $l(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const W_ = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const r = $l(t);
  return `linear-gradient(rgba(255 255 255 / ${r}), rgba(255 255 255 / ${r}))`;
});
function xh(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function Rh(e) {
  return e === "dark" ? W_ : [];
}
function V_(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: r,
    overlays: o,
    ...n
  } = e, i = Bc(t);
  return {
    palette: i,
    opacity: {
      ...xh(i.mode),
      ...r
    },
    overlays: o || Rh(i.mode),
    ...n
  };
}
function Z_(e) {
  var t;
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));
}
const q_ = (e) => [...[...Array(25)].map((t, r) => `--${e ? `${e}-` : ""}overlays-${r}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], Y_ = (e) => (t, r) => {
  const o = e.rootSelector || ":root", n = e.colorSchemeSelector;
  let i = n;
  if (n === "class" && (i = ".%s"), n === "data" && (i = "[data-%s]"), n != null && n.startsWith("data-") && !n.includes("%s") && (i = `[${n}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const a = {};
      return q_(e.cssVarPrefix).forEach((s) => {
        a[s] = r[s], delete r[s];
      }), i === "media" ? {
        [o]: r,
        "@media (prefers-color-scheme: dark)": {
          [o]: a
        }
      } : i ? {
        [i.replace("%s", t)]: a,
        [`${o}, ${i.replace("%s", t)}`]: r
      } : {
        [o]: {
          ...r,
          ...a
        }
      };
    }
    if (i && i !== "media")
      return `${o}, ${i.replace("%s", String(t))}`;
  } else if (t) {
    if (i === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [o]: r
        }
      };
    if (i)
      return i.replace("%s", String(t));
  }
  return o;
};
function G_(e, t) {
  t.forEach((r) => {
    e[r] || (e[r] = {});
  });
}
function Ne(e, t, r) {
  !e[t] && r && (e[t] = r);
}
function Wo(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : ch(e);
}
function Qr(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Ho(Wo(e[t]), `MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`));
}
function K_(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Cr = (e) => {
  try {
    return e();
  } catch {
  }
}, X_ = (e = "mui") => b_(e);
function tl(e, t, r, o) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const n = o === "dark" ? "dark" : "light";
  if (!r) {
    e[o] = V_({
      ...t,
      palette: {
        mode: n,
        ...t == null ? void 0 : t.palette
      }
    });
    return;
  }
  const {
    palette: i,
    ...a
  } = Bl({
    ...r,
    palette: {
      mode: n,
      ...t == null ? void 0 : t.palette
    }
  });
  return e[o] = {
    ...t,
    palette: i,
    opacity: {
      ...xh(n),
      ...t == null ? void 0 : t.opacity
    },
    overlays: (t == null ? void 0 : t.overlays) || Rh(n)
  }, a;
}
function Q_(e = {}, ...t) {
  const {
    colorSchemes: r = {
      light: !0
    },
    defaultColorScheme: o,
    disableCssColorScheme: n = !1,
    cssVarPrefix: i = "mui",
    shouldSkipGeneratingVar: a = Z_,
    colorSchemeSelector: s = r.light && r.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...p
  } = e, l = Object.keys(r)[0], d = o || (r.light && l !== "light" ? "light" : l), u = X_(i), {
    [d]: h,
    light: y,
    dark: f,
    ...b
  } = r, w = {
    ...b
  };
  let x = h;
  if ((d === "dark" && !("dark" in r) || d === "light" && !("light" in r)) && (x = !0), !x)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`colorSchemes.${d}\` option is either missing or invalid.` : Hr(21, d));
  const E = tl(w, x, p, d);
  y && !w.light && tl(w, y, void 0, "light"), f && !w.dark && tl(w, f, void 0, "dark");
  let T = {
    defaultColorScheme: d,
    ...E,
    cssVarPrefix: i,
    colorSchemeSelector: s,
    rootSelector: c,
    getCssVar: u,
    colorSchemes: w,
    font: {
      ...C_(E.typography),
      ...E.font
    },
    spacing: K_(p.spacing)
  };
  Object.keys(T.colorSchemes).forEach((N) => {
    const O = T.colorSchemes[N].palette, D = (H) => {
      const G = H.split("-"), X = G[1], Q = G[2];
      return u(H, O[X][Q]);
    };
    if (O.mode === "light" && (Ne(O.common, "background", "#fff"), Ne(O.common, "onBackground", "#000")), O.mode === "dark" && (Ne(O.common, "background", "#000"), Ne(O.common, "onBackground", "#fff")), G_(O, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), O.mode === "light") {
      Ne(O.Alert, "errorColor", Ot(O.error.light, 0.6)), Ne(O.Alert, "infoColor", Ot(O.info.light, 0.6)), Ne(O.Alert, "successColor", Ot(O.success.light, 0.6)), Ne(O.Alert, "warningColor", Ot(O.warning.light, 0.6)), Ne(O.Alert, "errorFilledBg", D("palette-error-main")), Ne(O.Alert, "infoFilledBg", D("palette-info-main")), Ne(O.Alert, "successFilledBg", D("palette-success-main")), Ne(O.Alert, "warningFilledBg", D("palette-warning-main")), Ne(O.Alert, "errorFilledColor", Cr(() => O.getContrastText(O.error.main))), Ne(O.Alert, "infoFilledColor", Cr(() => O.getContrastText(O.info.main))), Ne(O.Alert, "successFilledColor", Cr(() => O.getContrastText(O.success.main))), Ne(O.Alert, "warningFilledColor", Cr(() => O.getContrastText(O.warning.main))), Ne(O.Alert, "errorStandardBg", At(O.error.light, 0.9)), Ne(O.Alert, "infoStandardBg", At(O.info.light, 0.9)), Ne(O.Alert, "successStandardBg", At(O.success.light, 0.9)), Ne(O.Alert, "warningStandardBg", At(O.warning.light, 0.9)), Ne(O.Alert, "errorIconColor", D("palette-error-main")), Ne(O.Alert, "infoIconColor", D("palette-info-main")), Ne(O.Alert, "successIconColor", D("palette-success-main")), Ne(O.Alert, "warningIconColor", D("palette-warning-main")), Ne(O.AppBar, "defaultBg", D("palette-grey-100")), Ne(O.Avatar, "defaultBg", D("palette-grey-400")), Ne(O.Button, "inheritContainedBg", D("palette-grey-300")), Ne(O.Button, "inheritContainedHoverBg", D("palette-grey-A100")), Ne(O.Chip, "defaultBorder", D("palette-grey-400")), Ne(O.Chip, "defaultAvatarColor", D("palette-grey-700")), Ne(O.Chip, "defaultIconColor", D("palette-grey-700")), Ne(O.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Ne(O.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Ne(O.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Ne(O.LinearProgress, "primaryBg", At(O.primary.main, 0.62)), Ne(O.LinearProgress, "secondaryBg", At(O.secondary.main, 0.62)), Ne(O.LinearProgress, "errorBg", At(O.error.main, 0.62)), Ne(O.LinearProgress, "infoBg", At(O.info.main, 0.62)), Ne(O.LinearProgress, "successBg", At(O.success.main, 0.62)), Ne(O.LinearProgress, "warningBg", At(O.warning.main, 0.62)), Ne(O.Skeleton, "bg", `rgba(${D("palette-text-primaryChannel")} / 0.11)`), Ne(O.Slider, "primaryTrack", At(O.primary.main, 0.62)), Ne(O.Slider, "secondaryTrack", At(O.secondary.main, 0.62)), Ne(O.Slider, "errorTrack", At(O.error.main, 0.62)), Ne(O.Slider, "infoTrack", At(O.info.main, 0.62)), Ne(O.Slider, "successTrack", At(O.success.main, 0.62)), Ne(O.Slider, "warningTrack", At(O.warning.main, 0.62));
      const H = Vi(O.background.default, 0.8);
      Ne(O.SnackbarContent, "bg", H), Ne(O.SnackbarContent, "color", Cr(() => O.getContrastText(H))), Ne(O.SpeedDialAction, "fabHoverBg", Vi(O.background.paper, 0.15)), Ne(O.StepConnector, "border", D("palette-grey-400")), Ne(O.StepContent, "border", D("palette-grey-400")), Ne(O.Switch, "defaultColor", D("palette-common-white")), Ne(O.Switch, "defaultDisabledColor", D("palette-grey-100")), Ne(O.Switch, "primaryDisabledColor", At(O.primary.main, 0.62)), Ne(O.Switch, "secondaryDisabledColor", At(O.secondary.main, 0.62)), Ne(O.Switch, "errorDisabledColor", At(O.error.main, 0.62)), Ne(O.Switch, "infoDisabledColor", At(O.info.main, 0.62)), Ne(O.Switch, "successDisabledColor", At(O.success.main, 0.62)), Ne(O.Switch, "warningDisabledColor", At(O.warning.main, 0.62)), Ne(O.TableCell, "border", At(Wi(O.divider, 1), 0.88)), Ne(O.Tooltip, "bg", Wi(O.grey[700], 0.92));
    }
    if (O.mode === "dark") {
      Ne(O.Alert, "errorColor", At(O.error.light, 0.6)), Ne(O.Alert, "infoColor", At(O.info.light, 0.6)), Ne(O.Alert, "successColor", At(O.success.light, 0.6)), Ne(O.Alert, "warningColor", At(O.warning.light, 0.6)), Ne(O.Alert, "errorFilledBg", D("palette-error-dark")), Ne(O.Alert, "infoFilledBg", D("palette-info-dark")), Ne(O.Alert, "successFilledBg", D("palette-success-dark")), Ne(O.Alert, "warningFilledBg", D("palette-warning-dark")), Ne(O.Alert, "errorFilledColor", Cr(() => O.getContrastText(O.error.dark))), Ne(O.Alert, "infoFilledColor", Cr(() => O.getContrastText(O.info.dark))), Ne(O.Alert, "successFilledColor", Cr(() => O.getContrastText(O.success.dark))), Ne(O.Alert, "warningFilledColor", Cr(() => O.getContrastText(O.warning.dark))), Ne(O.Alert, "errorStandardBg", Ot(O.error.light, 0.9)), Ne(O.Alert, "infoStandardBg", Ot(O.info.light, 0.9)), Ne(O.Alert, "successStandardBg", Ot(O.success.light, 0.9)), Ne(O.Alert, "warningStandardBg", Ot(O.warning.light, 0.9)), Ne(O.Alert, "errorIconColor", D("palette-error-main")), Ne(O.Alert, "infoIconColor", D("palette-info-main")), Ne(O.Alert, "successIconColor", D("palette-success-main")), Ne(O.Alert, "warningIconColor", D("palette-warning-main")), Ne(O.AppBar, "defaultBg", D("palette-grey-900")), Ne(O.AppBar, "darkBg", D("palette-background-paper")), Ne(O.AppBar, "darkColor", D("palette-text-primary")), Ne(O.Avatar, "defaultBg", D("palette-grey-600")), Ne(O.Button, "inheritContainedBg", D("palette-grey-800")), Ne(O.Button, "inheritContainedHoverBg", D("palette-grey-700")), Ne(O.Chip, "defaultBorder", D("palette-grey-700")), Ne(O.Chip, "defaultAvatarColor", D("palette-grey-300")), Ne(O.Chip, "defaultIconColor", D("palette-grey-300")), Ne(O.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Ne(O.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Ne(O.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Ne(O.LinearProgress, "primaryBg", Ot(O.primary.main, 0.5)), Ne(O.LinearProgress, "secondaryBg", Ot(O.secondary.main, 0.5)), Ne(O.LinearProgress, "errorBg", Ot(O.error.main, 0.5)), Ne(O.LinearProgress, "infoBg", Ot(O.info.main, 0.5)), Ne(O.LinearProgress, "successBg", Ot(O.success.main, 0.5)), Ne(O.LinearProgress, "warningBg", Ot(O.warning.main, 0.5)), Ne(O.Skeleton, "bg", `rgba(${D("palette-text-primaryChannel")} / 0.13)`), Ne(O.Slider, "primaryTrack", Ot(O.primary.main, 0.5)), Ne(O.Slider, "secondaryTrack", Ot(O.secondary.main, 0.5)), Ne(O.Slider, "errorTrack", Ot(O.error.main, 0.5)), Ne(O.Slider, "infoTrack", Ot(O.info.main, 0.5)), Ne(O.Slider, "successTrack", Ot(O.success.main, 0.5)), Ne(O.Slider, "warningTrack", Ot(O.warning.main, 0.5));
      const H = Vi(O.background.default, 0.98);
      Ne(O.SnackbarContent, "bg", H), Ne(O.SnackbarContent, "color", Cr(() => O.getContrastText(H))), Ne(O.SpeedDialAction, "fabHoverBg", Vi(O.background.paper, 0.15)), Ne(O.StepConnector, "border", D("palette-grey-600")), Ne(O.StepContent, "border", D("palette-grey-600")), Ne(O.Switch, "defaultColor", D("palette-grey-300")), Ne(O.Switch, "defaultDisabledColor", D("palette-grey-600")), Ne(O.Switch, "primaryDisabledColor", Ot(O.primary.main, 0.55)), Ne(O.Switch, "secondaryDisabledColor", Ot(O.secondary.main, 0.55)), Ne(O.Switch, "errorDisabledColor", Ot(O.error.main, 0.55)), Ne(O.Switch, "infoDisabledColor", Ot(O.info.main, 0.55)), Ne(O.Switch, "successDisabledColor", Ot(O.success.main, 0.55)), Ne(O.Switch, "warningDisabledColor", Ot(O.warning.main, 0.55)), Ne(O.TableCell, "border", Ot(Wi(O.divider, 1), 0.68)), Ne(O.Tooltip, "bg", Wi(O.grey[700], 0.92));
    }
    Qr(O.background, "default"), Qr(O.background, "paper"), Qr(O.common, "background"), Qr(O.common, "onBackground"), Qr(O, "divider"), Object.keys(O).forEach((H) => {
      const G = O[H];
      H !== "tonalOffset" && G && typeof G == "object" && (G.main && Ne(O[H], "mainChannel", Ho(Wo(G.main))), G.light && Ne(O[H], "lightChannel", Ho(Wo(G.light))), G.dark && Ne(O[H], "darkChannel", Ho(Wo(G.dark))), G.contrastText && Ne(O[H], "contrastTextChannel", Ho(Wo(G.contrastText))), H === "text" && (Qr(O[H], "primary"), Qr(O[H], "secondary")), H === "action" && (G.active && Qr(O[H], "active"), G.selected && Qr(O[H], "selected")));
    });
  }), T = t.reduce((N, O) => tr(N, O), T);
  const C = {
    prefix: i,
    disableCssColorScheme: n,
    shouldSkipGeneratingVar: a,
    getSelector: Y_(T)
  }, {
    vars: R,
    generateThemeVars: A,
    generateStyleSheets: j
  } = w_(T, C);
  return T.vars = R, Object.entries(T.colorSchemes[T.defaultColorScheme]).forEach(([N, O]) => {
    T[N] = O;
  }), T.generateThemeVars = A, T.generateStyleSheets = j, T.generateSpacing = function() {
    return eh(p.spacing, Cc(this));
  }, T.getColorSchemeSelector = E_(s), T.spacing = T.generateSpacing(), T.shouldSkipGeneratingVar = a, T.unstable_sxConfig = {
    ...xi,
    ...p == null ? void 0 : p.unstable_sxConfig
  }, T.unstable_sx = function(O) {
    return Nn({
      sx: O,
      theme: this
    });
  }, T.toRuntimeSource = Th, T;
}
function Ff(e, t, r) {
  e.colorSchemes && r && (e.colorSchemes[t] = {
    ...r !== !0 && r,
    palette: Bc({
      ...r === !0 ? {} : r.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function Oh(e = {}, ...t) {
  const {
    palette: r,
    cssVariables: o = !1,
    colorSchemes: n = r ? void 0 : {
      light: !0
    },
    defaultColorScheme: i = r == null ? void 0 : r.mode,
    ...a
  } = e, s = i || "light", c = n == null ? void 0 : n[s], p = {
    ...n,
    ...r ? {
      [s]: {
        ...typeof c != "boolean" && c,
        palette: r
      }
    } : void 0
  };
  if (o === !1) {
    if (!("colorSchemes" in e))
      return Bl(e, ...t);
    let l = r;
    "palette" in e || p[s] && (p[s] !== !0 ? l = p[s].palette : s === "dark" && (l = {
      mode: "dark"
    }));
    const d = Bl({
      ...e,
      palette: l
    }, ...t);
    return d.defaultColorScheme = s, d.colorSchemes = p, d.palette.mode === "light" && (d.colorSchemes.light = {
      ...p.light !== !0 && p.light,
      palette: d.palette
    }, Ff(d, "dark", p.dark)), d.palette.mode === "dark" && (d.colorSchemes.dark = {
      ...p.dark !== !0 && p.dark,
      palette: d.palette
    }, Ff(d, "light", p.light)), d;
  }
  return !r && !("light" in p) && s === "light" && (p.light = !0), Q_({
    ...a,
    colorSchemes: p,
    defaultColorScheme: s,
    ...typeof o != "boolean" && o
  }, ...t);
}
const $c = Oh();
function ds() {
  const e = Nc($c);
  return process.env.NODE_ENV !== "production" && be.useDebugValue(e), e[Ga] || e;
}
function Ah(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Tr = (e) => Ah(e) && e !== "classes", tt = Yv({
  themeId: Ga,
  defaultTheme: $c,
  rootShouldForwardProp: Tr
});
function kh(e) {
  return /* @__PURE__ */ _e.jsx(th, {
    ...e,
    defaultTheme: $c,
    themeId: Ga
  });
}
process.env.NODE_ENV !== "production" && (kh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The styles you want to apply globally.
   */
  styles: m.oneOfType([m.array, m.func, m.number, m.object, m.string, m.bool])
});
function J_(e) {
  return function(r) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ _e.jsx(kh, {
        styles: typeof e == "function" ? (o) => e({
          theme: o,
          ...r
        }) : e
      })
    );
  };
}
function e1() {
  return rh;
}
const Ct = g_;
process.env.NODE_ENV !== "production" && (m.node, m.object.isRequired);
function wt(e) {
  return m_(e);
}
function t1(e) {
  return gt("MuiSvgIcon", e);
}
ht("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const r1 = (e) => {
  const {
    color: t,
    fontSize: r,
    classes: o
  } = e, n = {
    root: ["root", t !== "inherit" && `color${at(t)}`, `fontSize${at(r)}`]
  };
  return _t(n, t1, o);
}, n1 = tt("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.color !== "inherit" && t[`color${at(r.color)}`], t[`fontSize${at(r.fontSize)}`]];
  }
})(Ct(({
  theme: e
}) => {
  var t, r, o, n, i, a, s, c, p, l, d, u, h, y;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (n = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : n.call(t, "fill", {
      duration: (o = (r = (e.vars ?? e).transitions) == null ? void 0 : r.duration) == null ? void 0 : o.shorter
    }),
    variants: [
      {
        props: (f) => !f.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((a = (i = e.typography) == null ? void 0 : i.pxToRem) == null ? void 0 : a.call(i, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((c = (s = e.typography) == null ? void 0 : s.pxToRem) == null ? void 0 : c.call(s, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((l = (p = e.typography) == null ? void 0 : p.pxToRem) == null ? void 0 : l.call(p, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, f]) => f && f.main).map(([f]) => {
        var b, w;
        return {
          props: {
            color: f
          },
          style: {
            color: (w = (b = (e.vars ?? e).palette) == null ? void 0 : b[f]) == null ? void 0 : w.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (u = (d = (e.vars ?? e).palette) == null ? void 0 : d.action) == null ? void 0 : u.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (y = (h = (e.vars ?? e).palette) == null ? void 0 : h.action) == null ? void 0 : y.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
})), ai = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: n,
    className: i,
    color: a = "inherit",
    component: s = "svg",
    fontSize: c = "medium",
    htmlColor: p,
    inheritViewBox: l = !1,
    titleAccess: d,
    viewBox: u = "0 0 24 24",
    ...h
  } = o, y = /* @__PURE__ */ be.isValidElement(n) && n.type === "svg", f = {
    ...o,
    color: a,
    component: s,
    fontSize: c,
    instanceFontSize: t.fontSize,
    inheritViewBox: l,
    viewBox: u,
    hasSvgAsChild: y
  }, b = {};
  l || (b.viewBox = u);
  const w = r1(f);
  return /* @__PURE__ */ _e.jsxs(n1, {
    as: s,
    className: ot(w.root, i),
    focusable: "false",
    color: p,
    "aria-hidden": d ? void 0 : !0,
    role: d ? "img" : void 0,
    ref: r,
    ...b,
    ...h,
    ...y && n.props,
    ownerState: f,
    children: [y ? n.props.children : n, d ? /* @__PURE__ */ _e.jsx("title", {
      children: d
    }) : null]
  });
});
process.env.NODE_ENV !== "production" && (ai.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Node passed into the SVG element.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: m.oneOfType([m.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), m.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: m.oneOfType([m.oneOf(["inherit", "large", "medium", "small"]), m.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: m.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: m.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: m.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: m.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: m.string
});
ai && (ai.muiName = "SvgIcon");
function Zr(e, t) {
  function r(o, n) {
    return /* @__PURE__ */ _e.jsx(ai, {
      "data-testid": `${t}Icon`,
      ref: n,
      ...o,
      children: e
    });
  }
  return process.env.NODE_ENV !== "production" && (r.displayName = `${t}Icon`), r.muiName = ai.muiName, /* @__PURE__ */ be.memo(/* @__PURE__ */ be.forwardRef(r));
}
var Zi = { exports: {} }, Tt = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Df;
function o1() {
  if (Df) return Tt;
  Df = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), n = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), l = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), u = Symbol.for("react.offscreen"), h = Symbol.for("react.client.reference");
  function y(f) {
    if (typeof f == "object" && f !== null) {
      var b = f.$$typeof;
      switch (b) {
        case e:
          switch (f = f.type, f) {
            case r:
            case n:
            case o:
            case c:
            case p:
              return f;
            default:
              switch (f = f && f.$$typeof, f) {
                case a:
                case s:
                case d:
                case l:
                  return f;
                case i:
                  return f;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return Tt.ContextConsumer = i, Tt.ContextProvider = a, Tt.Element = e, Tt.ForwardRef = s, Tt.Fragment = r, Tt.Lazy = d, Tt.Memo = l, Tt.Portal = t, Tt.Profiler = n, Tt.StrictMode = o, Tt.Suspense = c, Tt.SuspenseList = p, Tt.isContextConsumer = function(f) {
    return y(f) === i;
  }, Tt.isContextProvider = function(f) {
    return y(f) === a;
  }, Tt.isElement = function(f) {
    return typeof f == "object" && f !== null && f.$$typeof === e;
  }, Tt.isForwardRef = function(f) {
    return y(f) === s;
  }, Tt.isFragment = function(f) {
    return y(f) === r;
  }, Tt.isLazy = function(f) {
    return y(f) === d;
  }, Tt.isMemo = function(f) {
    return y(f) === l;
  }, Tt.isPortal = function(f) {
    return y(f) === t;
  }, Tt.isProfiler = function(f) {
    return y(f) === n;
  }, Tt.isStrictMode = function(f) {
    return y(f) === o;
  }, Tt.isSuspense = function(f) {
    return y(f) === c;
  }, Tt.isSuspenseList = function(f) {
    return y(f) === p;
  }, Tt.isValidElementType = function(f) {
    return typeof f == "string" || typeof f == "function" || f === r || f === n || f === o || f === c || f === p || f === u || typeof f == "object" && f !== null && (f.$$typeof === d || f.$$typeof === l || f.$$typeof === a || f.$$typeof === i || f.$$typeof === s || f.$$typeof === h || f.getModuleId !== void 0);
  }, Tt.typeOf = y, Tt;
}
var xt = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bf;
function i1() {
  return Bf || (Bf = 1, process.env.NODE_ENV !== "production" && function() {
    function e(f) {
      if (typeof f == "object" && f !== null) {
        var b = f.$$typeof;
        switch (b) {
          case t:
            switch (f = f.type, f) {
              case o:
              case i:
              case n:
              case p:
              case l:
                return f;
              default:
                switch (f = f && f.$$typeof, f) {
                  case s:
                  case c:
                  case u:
                  case d:
                    return f;
                  case a:
                    return f;
                  default:
                    return b;
                }
            }
          case r:
            return b;
        }
      }
    }
    var t = Symbol.for("react.transitional.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.for("react.client.reference");
    xt.ContextConsumer = a, xt.ContextProvider = s, xt.Element = t, xt.ForwardRef = c, xt.Fragment = o, xt.Lazy = u, xt.Memo = d, xt.Portal = r, xt.Profiler = i, xt.StrictMode = n, xt.Suspense = p, xt.SuspenseList = l, xt.isContextConsumer = function(f) {
      return e(f) === a;
    }, xt.isContextProvider = function(f) {
      return e(f) === s;
    }, xt.isElement = function(f) {
      return typeof f == "object" && f !== null && f.$$typeof === t;
    }, xt.isForwardRef = function(f) {
      return e(f) === c;
    }, xt.isFragment = function(f) {
      return e(f) === o;
    }, xt.isLazy = function(f) {
      return e(f) === u;
    }, xt.isMemo = function(f) {
      return e(f) === d;
    }, xt.isPortal = function(f) {
      return e(f) === r;
    }, xt.isProfiler = function(f) {
      return e(f) === i;
    }, xt.isStrictMode = function(f) {
      return e(f) === n;
    }, xt.isSuspense = function(f) {
      return e(f) === p;
    }, xt.isSuspenseList = function(f) {
      return e(f) === l;
    }, xt.isValidElementType = function(f) {
      return typeof f == "string" || typeof f == "function" || f === o || f === i || f === n || f === p || f === l || f === h || typeof f == "object" && f !== null && (f.$$typeof === u || f.$$typeof === d || f.$$typeof === s || f.$$typeof === a || f.$$typeof === c || f.$$typeof === y || f.getModuleId !== void 0);
    }, xt.typeOf = e;
  }()), xt;
}
var $f;
function a1() {
  return $f || ($f = 1, process.env.NODE_ENV === "production" ? Zi.exports = /* @__PURE__ */ o1() : Zi.exports = /* @__PURE__ */ i1()), Zi.exports;
}
var Uc = /* @__PURE__ */ a1();
function Ch(e, t) {
  if (e == null) return {};
  var r = {};
  for (var o in e) if ({}.hasOwnProperty.call(e, o)) {
    if (t.includes(o)) continue;
    r[o] = e[o];
  }
  return r;
}
function Ul(e, t) {
  return Ul = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, o) {
    return r.__proto__ = o, r;
  }, Ul(e, t);
}
function Ph(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ul(e, t);
}
const Uf = {
  disabled: !1
};
var s1 = process.env.NODE_ENV !== "production" ? m.oneOfType([m.number, m.shape({
  enter: m.number,
  exit: m.number,
  appear: m.number
}).isRequired]) : null;
process.env.NODE_ENV !== "production" && m.oneOfType([m.string, m.shape({
  enter: m.string,
  exit: m.string,
  active: m.string
}), m.shape({
  enter: m.string,
  enterDone: m.string,
  enterActive: m.string,
  exit: m.string,
  exitDone: m.string,
  exitActive: m.string
})]);
const La = qt.createContext(null);
var l1 = function(t) {
  return t.scrollTop;
}, Vo = "unmounted", En = "exited", Sn = "entering", Yn = "entered", zl = "exiting", qr = /* @__PURE__ */ function(e) {
  Ph(t, e);
  function t(o, n) {
    var i;
    i = e.call(this, o, n) || this;
    var a = n, s = a && !a.isMounting ? o.enter : o.appear, c;
    return i.appearStatus = null, o.in ? s ? (c = En, i.appearStatus = Sn) : c = Yn : o.unmountOnExit || o.mountOnEnter ? c = Vo : c = En, i.state = {
      status: c
    }, i.nextCallback = null, i;
  }
  t.getDerivedStateFromProps = function(n, i) {
    var a = n.in;
    return a && i.status === Vo ? {
      status: En
    } : null;
  };
  var r = t.prototype;
  return r.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, r.componentDidUpdate = function(n) {
    var i = null;
    if (n !== this.props) {
      var a = this.state.status;
      this.props.in ? a !== Sn && a !== Yn && (i = Sn) : (a === Sn || a === Yn) && (i = zl);
    }
    this.updateStatus(!1, i);
  }, r.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, r.getTimeouts = function() {
    var n = this.props.timeout, i, a, s;
    return i = a = s = n, n != null && typeof n != "number" && (i = n.exit, a = n.enter, s = n.appear !== void 0 ? n.appear : a), {
      exit: i,
      enter: a,
      appear: s
    };
  }, r.updateStatus = function(n, i) {
    if (n === void 0 && (n = !1), i !== null)
      if (this.cancelNextCallback(), i === Sn) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var a = this.props.nodeRef ? this.props.nodeRef.current : Mi.findDOMNode(this);
          a && l1(a);
        }
        this.performEnter(n);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === En && this.setState({
      status: Vo
    });
  }, r.performEnter = function(n) {
    var i = this, a = this.props.enter, s = this.context ? this.context.isMounting : n, c = this.props.nodeRef ? [s] : [Mi.findDOMNode(this), s], p = c[0], l = c[1], d = this.getTimeouts(), u = s ? d.appear : d.enter;
    if (!n && !a || Uf.disabled) {
      this.safeSetState({
        status: Yn
      }, function() {
        i.props.onEntered(p);
      });
      return;
    }
    this.props.onEnter(p, l), this.safeSetState({
      status: Sn
    }, function() {
      i.props.onEntering(p, l), i.onTransitionEnd(u, function() {
        i.safeSetState({
          status: Yn
        }, function() {
          i.props.onEntered(p, l);
        });
      });
    });
  }, r.performExit = function() {
    var n = this, i = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : Mi.findDOMNode(this);
    if (!i || Uf.disabled) {
      this.safeSetState({
        status: En
      }, function() {
        n.props.onExited(s);
      });
      return;
    }
    this.props.onExit(s), this.safeSetState({
      status: zl
    }, function() {
      n.props.onExiting(s), n.onTransitionEnd(a.exit, function() {
        n.safeSetState({
          status: En
        }, function() {
          n.props.onExited(s);
        });
      });
    });
  }, r.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, r.safeSetState = function(n, i) {
    i = this.setNextCallback(i), this.setState(n, i);
  }, r.setNextCallback = function(n) {
    var i = this, a = !0;
    return this.nextCallback = function(s) {
      a && (a = !1, i.nextCallback = null, n(s));
    }, this.nextCallback.cancel = function() {
      a = !1;
    }, this.nextCallback;
  }, r.onTransitionEnd = function(n, i) {
    this.setNextCallback(i);
    var a = this.props.nodeRef ? this.props.nodeRef.current : Mi.findDOMNode(this), s = n == null && !this.props.addEndListener;
    if (!a || s) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var c = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], p = c[0], l = c[1];
      this.props.addEndListener(p, l);
    }
    n != null && setTimeout(this.nextCallback, n);
  }, r.render = function() {
    var n = this.state.status;
    if (n === Vo)
      return null;
    var i = this.props, a = i.children;
    i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef;
    var s = Ch(i, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ qt.createElement(La.Provider, {
        value: null
      }, typeof a == "function" ? a(n, s) : qt.cloneElement(qt.Children.only(a), s))
    );
  }, t;
}(qt.Component);
qr.contextType = La;
qr.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: m.shape({
    current: typeof Element > "u" ? m.any : function(e, t, r, o, n, i) {
      var a = e[t];
      return m.instanceOf(a && "ownerDocument" in a ? a.ownerDocument.defaultView.Element : Element)(e, t, r, o, n, i);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: m.oneOfType([m.func.isRequired, m.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: m.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: m.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: m.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: m.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: m.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: m.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var r = s1;
    t.addEndListener || (r = r.isRequired);
    for (var o = arguments.length, n = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
      n[i - 1] = arguments[i];
    return r.apply(void 0, [t].concat(n));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: m.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: m.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: m.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: m.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: m.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: m.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: m.func
} : {};
function zn() {
}
qr.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: zn,
  onEntering: zn,
  onEntered: zn,
  onExit: zn,
  onExiting: zn,
  onExited: zn
};
qr.UNMOUNTED = Vo;
qr.EXITED = En;
qr.ENTERING = Sn;
qr.ENTERED = Yn;
qr.EXITING = zl;
function c1(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function zc(e, t) {
  var r = function(i) {
    return t && la(i) ? t(i) : i;
  }, o = /* @__PURE__ */ Object.create(null);
  return e && Bm.map(e, function(n) {
    return n;
  }).forEach(function(n) {
    o[n.key] = r(n);
  }), o;
}
function u1(e, t) {
  e = e || {}, t = t || {};
  function r(l) {
    return l in t ? t[l] : e[l];
  }
  var o = /* @__PURE__ */ Object.create(null), n = [];
  for (var i in e)
    i in t ? n.length && (o[i] = n, n = []) : n.push(i);
  var a, s = {};
  for (var c in t) {
    if (o[c])
      for (a = 0; a < o[c].length; a++) {
        var p = o[c][a];
        s[o[c][a]] = r(p);
      }
    s[c] = r(c);
  }
  for (a = 0; a < n.length; a++)
    s[n[a]] = r(n[a]);
  return s;
}
function Rn(e, t, r) {
  return r[t] != null ? r[t] : e.props[t];
}
function f1(e, t) {
  return zc(e.children, function(r) {
    return ca(r, {
      onExited: t.bind(null, r),
      in: !0,
      appear: Rn(r, "appear", e),
      enter: Rn(r, "enter", e),
      exit: Rn(r, "exit", e)
    });
  });
}
function d1(e, t, r) {
  var o = zc(e.children), n = u1(t, o);
  return Object.keys(n).forEach(function(i) {
    var a = n[i];
    if (la(a)) {
      var s = i in t, c = i in o, p = t[i], l = la(p) && !p.props.in;
      c && (!s || l) ? n[i] = ca(a, {
        onExited: r.bind(null, a),
        in: !0,
        exit: Rn(a, "exit", e),
        enter: Rn(a, "enter", e)
      }) : !c && s && !l ? n[i] = ca(a, {
        in: !1
      }) : c && s && la(p) && (n[i] = ca(a, {
        onExited: r.bind(null, a),
        in: p.props.in,
        exit: Rn(a, "exit", e),
        enter: Rn(a, "enter", e)
      }));
    }
  }), n;
}
var p1 = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, h1 = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, Hc = /* @__PURE__ */ function(e) {
  Ph(t, e);
  function t(o, n) {
    var i;
    i = e.call(this, o, n) || this;
    var a = i.handleExited.bind(c1(i));
    return i.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: a,
      firstRender: !0
    }, i;
  }
  var r = t.prototype;
  return r.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, r.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(n, i) {
    var a = i.children, s = i.handleExited, c = i.firstRender;
    return {
      children: c ? f1(n, s) : d1(n, a, s),
      firstRender: !1
    };
  }, r.handleExited = function(n, i) {
    var a = zc(this.props.children);
    n.key in a || (n.props.onExited && n.props.onExited(i), this.mounted && this.setState(function(s) {
      var c = ka({}, s.children);
      return delete c[n.key], {
        children: c
      };
    }));
  }, r.render = function() {
    var n = this.props, i = n.component, a = n.childFactory, s = Ch(n, ["component", "childFactory"]), c = this.state.contextValue, p = p1(this.state.children).map(a);
    return delete s.appear, delete s.enter, delete s.exit, i === null ? /* @__PURE__ */ qt.createElement(La.Provider, {
      value: c
    }, p) : /* @__PURE__ */ qt.createElement(La.Provider, {
      value: c
    }, /* @__PURE__ */ qt.createElement(i, s, p));
  }, t;
}(qt.Component);
Hc.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: m.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: m.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: m.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: m.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: m.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: m.func
} : {};
Hc.defaultProps = h1;
const Ih = (e) => e.scrollTop;
function ja(e, t) {
  const {
    timeout: r,
    easing: o,
    style: n = {}
  } = e;
  return {
    duration: n.transitionDuration ?? (typeof r == "number" ? r : r[t.mode] || 0),
    easing: n.transitionTimingFunction ?? (typeof o == "object" ? o[t.mode] : o),
    delay: n.transitionDelay
  };
}
function y1(e) {
  return gt("MuiPaper", e);
}
ht("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const m1 = (e) => {
  const {
    square: t,
    elevation: r,
    variant: o,
    classes: n
  } = e, i = {
    root: ["root", o, !t && "rounded", o === "elevation" && `elevation${r}`]
  };
  return _t(i, y1, n);
}, g1 = tt("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, t[r.variant], !r.square && t.rounded, r.variant === "elevation" && t[`elevation${r.elevation}`]];
  }
})(Ct(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), Nh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  var h;
  const o = wt({
    props: t,
    name: "MuiPaper"
  }), n = ds(), {
    className: i,
    component: a = "div",
    elevation: s = 1,
    square: c = !1,
    variant: p = "elevation",
    ...l
  } = o, d = {
    ...o,
    component: a,
    elevation: s,
    square: c,
    variant: p
  }, u = m1(d);
  return process.env.NODE_ENV !== "production" && n.shadows[s] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${s}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${s}]\` is defined.`].join(`
`)), /* @__PURE__ */ _e.jsx(g1, {
    as: a,
    ownerState: d,
    className: ot(u.root, i),
    ref: r,
    ...l,
    style: {
      ...p === "elevation" && {
        "--Paper-shadow": (n.vars || n).shadows[s],
        ...n.vars && {
          "--Paper-overlay": (h = n.vars.overlays) == null ? void 0 : h[s]
        },
        ...!n.vars && n.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${Qt("#fff", $l(s))}, ${Qt("#fff", $l(s))})`
        }
      },
      ...l.style
    }
  });
});
process.env.NODE_ENV !== "production" && (Nh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: gn(gh, (e) => {
    const {
      elevation: t,
      variant: r
    } = e;
    return t > 0 && r === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${r}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: m.bool,
  /**
   * @ignore
   */
  style: m.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: m.oneOfType([m.oneOf(["elevation", "outlined"]), m.string])
});
function Zt(e, t) {
  const {
    className: r,
    elementType: o,
    ownerState: n,
    externalForwardedProps: i,
    internalForwardedProps: a,
    ...s
  } = t, {
    component: c,
    slots: p = {
      [e]: void 0
    },
    slotProps: l = {
      [e]: void 0
    },
    ...d
  } = i, u = p[e] || o, h = wh(l[e], n), {
    props: {
      component: y,
      ...f
    },
    internalRef: b
  } = _h({
    className: r,
    ...s,
    externalForwardedProps: e === "root" ? d : void 0,
    externalSlotProps: h
  }), w = Mt(b, h == null ? void 0 : h.ref, t.ref), x = e === "root" ? y || c : y, E = bh(u, {
    ...e === "root" && !c && !p[e] && a,
    ...e !== "root" && !p[e] && a,
    ...f,
    ...x && {
      as: x
    },
    ref: w
  }, n);
  return [u, E];
}
class Ma {
  constructor() {
    Kr(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new Ma();
  }
  static use() {
    const t = ph(Ma.create).current, [r, o] = be.useState(!1);
    return t.shouldMount = r, t.setShouldMount = o, be.useEffect(t.mountEffect, [r]), t;
  }
  mount() {
    return this.mounted || (this.mounted = v1(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => {
      var r;
      return (r = this.ref.current) == null ? void 0 : r.start(...t);
    });
  }
  stop(...t) {
    this.mount().then(() => {
      var r;
      return (r = this.ref.current) == null ? void 0 : r.stop(...t);
    });
  }
  pulsate(...t) {
    this.mount().then(() => {
      var r;
      return (r = this.ref.current) == null ? void 0 : r.pulsate(...t);
    });
  }
}
function b1() {
  return Ma.use();
}
function v1() {
  let e, t;
  const r = new Promise((o, n) => {
    e = o, t = n;
  });
  return r.resolve = e, r.reject = t, r;
}
function Lh(e) {
  const {
    className: t,
    classes: r,
    pulsate: o = !1,
    rippleX: n,
    rippleY: i,
    rippleSize: a,
    in: s,
    onExited: c,
    timeout: p
  } = e, [l, d] = be.useState(!1), u = ot(t, r.ripple, r.rippleVisible, o && r.ripplePulsate), h = {
    width: a,
    height: a,
    top: -(a / 2) + i,
    left: -(a / 2) + n
  }, y = ot(r.child, l && r.childLeaving, o && r.childPulsate);
  return !s && !l && d(!0), be.useEffect(() => {
    if (!s && c != null) {
      const f = setTimeout(c, p);
      return () => {
        clearTimeout(f);
      };
    }
  }, [c, s, p]), /* @__PURE__ */ _e.jsx("span", {
    className: u,
    style: h,
    children: /* @__PURE__ */ _e.jsx("span", {
      className: y
    })
  });
}
process.env.NODE_ENV !== "production" && (Lh.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object.isRequired,
  className: m.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: m.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: m.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: m.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: m.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: m.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: m.number,
  /**
   * exit delay
   */
  timeout: m.number.isRequired
});
const yr = ht("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Hl = 550, _1 = 80, w1 = Ac`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, E1 = Ac`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, S1 = Ac`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, T1 = tt("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), x1 = tt(Lh, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${yr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${w1};
    animation-duration: ${Hl}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${yr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${yr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${yr.childLeaving} {
    opacity: 0;
    animation-name: ${E1};
    animation-duration: ${Hl}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${yr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${S1};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, jh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: n = !1,
    classes: i = {},
    className: a,
    ...s
  } = o, [c, p] = be.useState([]), l = be.useRef(0), d = be.useRef(null);
  be.useEffect(() => {
    d.current && (d.current(), d.current = null);
  }, [c]);
  const u = be.useRef(!1), h = Kn(), y = be.useRef(null), f = be.useRef(null), b = be.useCallback((T) => {
    const {
      pulsate: C,
      rippleX: R,
      rippleY: A,
      rippleSize: j,
      cb: N
    } = T;
    p((O) => [...O, /* @__PURE__ */ _e.jsx(x1, {
      classes: {
        ripple: ot(i.ripple, yr.ripple),
        rippleVisible: ot(i.rippleVisible, yr.rippleVisible),
        ripplePulsate: ot(i.ripplePulsate, yr.ripplePulsate),
        child: ot(i.child, yr.child),
        childLeaving: ot(i.childLeaving, yr.childLeaving),
        childPulsate: ot(i.childPulsate, yr.childPulsate)
      },
      timeout: Hl,
      pulsate: C,
      rippleX: R,
      rippleY: A,
      rippleSize: j
    }, l.current)]), l.current += 1, d.current = N;
  }, [i]), w = be.useCallback((T = {}, C = {}, R = () => {
  }) => {
    const {
      pulsate: A = !1,
      center: j = n || C.pulsate,
      fakeElement: N = !1
      // For test purposes
    } = C;
    if ((T == null ? void 0 : T.type) === "mousedown" && u.current) {
      u.current = !1;
      return;
    }
    (T == null ? void 0 : T.type) === "touchstart" && (u.current = !0);
    const O = N ? null : f.current, D = O ? O.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let H, G, X;
    if (j || T === void 0 || T.clientX === 0 && T.clientY === 0 || !T.clientX && !T.touches)
      H = Math.round(D.width / 2), G = Math.round(D.height / 2);
    else {
      const {
        clientX: Q,
        clientY: M
      } = T.touches && T.touches.length > 0 ? T.touches[0] : T;
      H = Math.round(Q - D.left), G = Math.round(M - D.top);
    }
    if (j)
      X = Math.sqrt((2 * D.width ** 2 + D.height ** 2) / 3), X % 2 === 0 && (X += 1);
    else {
      const Q = Math.max(Math.abs((O ? O.clientWidth : 0) - H), H) * 2 + 2, M = Math.max(Math.abs((O ? O.clientHeight : 0) - G), G) * 2 + 2;
      X = Math.sqrt(Q ** 2 + M ** 2);
    }
    T != null && T.touches ? y.current === null && (y.current = () => {
      b({
        pulsate: A,
        rippleX: H,
        rippleY: G,
        rippleSize: X,
        cb: R
      });
    }, h.start(_1, () => {
      y.current && (y.current(), y.current = null);
    })) : b({
      pulsate: A,
      rippleX: H,
      rippleY: G,
      rippleSize: X,
      cb: R
    });
  }, [n, b, h]), x = be.useCallback(() => {
    w({}, {
      pulsate: !0
    });
  }, [w]), E = be.useCallback((T, C) => {
    if (h.clear(), (T == null ? void 0 : T.type) === "touchend" && y.current) {
      y.current(), y.current = null, h.start(0, () => {
        E(T, C);
      });
      return;
    }
    y.current = null, p((R) => R.length > 0 ? R.slice(1) : R), d.current = C;
  }, [h]);
  return be.useImperativeHandle(r, () => ({
    pulsate: x,
    start: w,
    stop: E
  }), [x, w, E]), /* @__PURE__ */ _e.jsx(T1, {
    className: ot(yr.root, i.root, a),
    ref: f,
    ...s,
    children: /* @__PURE__ */ _e.jsx(Hc, {
      component: null,
      exit: !0,
      children: c
    })
  });
});
process.env.NODE_ENV !== "production" && (jh.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: m.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string
});
function R1(e) {
  return gt("MuiButtonBase", e);
}
const O1 = ht("MuiButtonBase", ["root", "disabled", "focusVisible"]), A1 = (e) => {
  const {
    disabled: t,
    focusVisible: r,
    focusVisibleClassName: o,
    classes: n
  } = e, a = _t({
    root: ["root", t && "disabled", r && "focusVisible"]
  }, R1, n);
  return r && o && (a.root += ` ${o}`), a;
}, k1 = tt("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${O1.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), ps = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: n,
    centerRipple: i = !1,
    children: a,
    className: s,
    component: c = "button",
    disabled: p = !1,
    disableRipple: l = !1,
    disableTouchRipple: d = !1,
    focusRipple: u = !1,
    focusVisibleClassName: h,
    LinkComponent: y = "a",
    onBlur: f,
    onClick: b,
    onContextMenu: w,
    onDragLeave: x,
    onFocus: E,
    onFocusVisible: T,
    onKeyDown: C,
    onKeyUp: R,
    onMouseDown: A,
    onMouseLeave: j,
    onMouseUp: N,
    onTouchEnd: O,
    onTouchMove: D,
    onTouchStart: H,
    tabIndex: G = 0,
    TouchRippleProps: X,
    touchRippleRef: Q,
    type: M,
    ...k
  } = o, $ = be.useRef(null), ne = b1(), te = Mt(ne.ref, Q), [de, ae] = be.useState(!1);
  p && de && ae(!1), be.useImperativeHandle(n, () => ({
    focusVisible: () => {
      ae(!0), $.current.focus();
    }
  }), []);
  const z = ne.shouldMount && !l && !p;
  be.useEffect(() => {
    de && u && !l && ne.pulsate();
  }, [l, u, de, ne]);
  const Z = Jr(ne, "start", A, d), oe = Jr(ne, "stop", w, d), ye = Jr(ne, "stop", x, d), V = Jr(ne, "stop", N, d), q = Jr(ne, "stop", (S) => {
    de && S.preventDefault(), j && j(S);
  }, d), ee = Jr(ne, "start", H, d), ue = Jr(ne, "stop", O, d), ge = Jr(ne, "stop", D, d), he = Jr(ne, "stop", (S) => {
    Na(S.target) || ae(!1), f && f(S);
  }, !1), W = dn((S) => {
    $.current || ($.current = S.currentTarget), Na(S.target) && (ae(!0), T && T(S)), E && E(S);
  }), Y = () => {
    const S = $.current;
    return c && c !== "button" && !(S.tagName === "A" && S.href);
  }, se = dn((S) => {
    u && !S.repeat && de && S.key === " " && ne.stop(S, () => {
      ne.start(S);
    }), S.target === S.currentTarget && Y() && S.key === " " && S.preventDefault(), C && C(S), S.target === S.currentTarget && Y() && S.key === "Enter" && !p && (S.preventDefault(), b && b(S));
  }), Te = dn((S) => {
    u && S.key === " " && de && !S.defaultPrevented && ne.stop(S, () => {
      ne.pulsate(S);
    }), R && R(S), b && S.target === S.currentTarget && Y() && S.key === " " && !S.defaultPrevented && b(S);
  });
  let Oe = c;
  Oe === "button" && (k.href || k.to) && (Oe = y);
  const B = {};
  Oe === "button" ? (B.type = M === void 0 ? "button" : M, B.disabled = p) : (!k.href && !k.to && (B.role = "button"), p && (B["aria-disabled"] = p));
  const U = Mt(r, $), _ = {
    ...o,
    centerRipple: i,
    component: c,
    disabled: p,
    disableRipple: l,
    disableTouchRipple: d,
    focusRipple: u,
    tabIndex: G,
    focusVisible: de
  }, v = A1(_);
  return /* @__PURE__ */ _e.jsxs(k1, {
    as: Oe,
    className: ot(v.root, s),
    ownerState: _,
    onBlur: he,
    onClick: b,
    onContextMenu: oe,
    onFocus: W,
    onKeyDown: se,
    onKeyUp: Te,
    onMouseDown: Z,
    onMouseLeave: q,
    onMouseUp: V,
    onDragLeave: ye,
    onTouchEnd: ue,
    onTouchMove: ge,
    onTouchStart: ee,
    ref: U,
    tabIndex: p ? -1 : G,
    type: M,
    ...B,
    ...k,
    children: [a, z ? /* @__PURE__ */ _e.jsx(jh, {
      ref: te,
      center: i,
      ...X
    }) : null]
  });
});
function Jr(e, t, r, o = !1) {
  return dn((n) => (r && r(n), o || e[t](n), !0));
}
process.env.NODE_ENV !== "production" && (ps.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: Ar,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: m.bool,
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: us,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: m.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: m.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: m.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: m.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: m.string,
  /**
   * @ignore
   */
  href: m.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: m.elementType,
  /**
   * @ignore
   */
  onBlur: m.func,
  /**
   * @ignore
   */
  onClick: m.func,
  /**
   * @ignore
   */
  onContextMenu: m.func,
  /**
   * @ignore
   */
  onDragLeave: m.func,
  /**
   * @ignore
   */
  onFocus: m.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: m.func,
  /**
   * @ignore
   */
  onKeyDown: m.func,
  /**
   * @ignore
   */
  onKeyUp: m.func,
  /**
   * @ignore
   */
  onMouseDown: m.func,
  /**
   * @ignore
   */
  onMouseLeave: m.func,
  /**
   * @ignore
   */
  onMouseUp: m.func,
  /**
   * @ignore
   */
  onTouchEnd: m.func,
  /**
   * @ignore
   */
  onTouchMove: m.func,
  /**
   * @ignore
   */
  onTouchStart: m.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * @default 0
   */
  tabIndex: m.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: m.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: m.oneOfType([m.func, m.shape({
    current: m.shape({
      pulsate: m.func.isRequired,
      start: m.func.isRequired,
      stop: m.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: m.oneOfType([m.oneOf(["button", "reset", "submit"]), m.string])
});
function C1(e) {
  return typeof e.main == "string";
}
function P1(e, t = []) {
  if (!C1(e))
    return !1;
  for (const r of t)
    if (!e.hasOwnProperty(r) || typeof e[r] != "string")
      return !1;
  return !0;
}
function yn(e = []) {
  return ([, t]) => t && P1(t, e);
}
function I1(e) {
  return gt("MuiIconButton", e);
}
const N1 = ht("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), L1 = (e) => {
  const {
    classes: t,
    disabled: r,
    color: o,
    edge: n,
    size: i
  } = e, a = {
    root: ["root", r && "disabled", o !== "default" && `color${at(o)}`, n && `edge${at(n)}`, `size${at(i)}`]
  };
  return _t(a, I1, t);
}, j1 = tt(ps, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.color !== "default" && t[`color${at(r.color)}`], r.edge && t[`edge${at(r.edge)}`], t[`size${at(r.size)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: (t) => !t.disableRipple,
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt(e.palette.action.active, e.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), Ct(({
  theme: e
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(e.palette).filter(yn()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette).filter(yn()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }
  }],
  [`&.${N1.disabled}`]: {
    backgroundColor: "transparent",
    color: (e.vars || e).palette.action.disabled
  }
}))), ya = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: n = !1,
    children: i,
    className: a,
    color: s = "default",
    disabled: c = !1,
    disableFocusRipple: p = !1,
    size: l = "medium",
    ...d
  } = o, u = {
    ...o,
    edge: n,
    color: s,
    disabled: c,
    disableFocusRipple: p,
    size: l
  }, h = L1(u);
  return /* @__PURE__ */ _e.jsx(j1, {
    className: ot(h.root, a),
    centerRipple: !0,
    focusRipple: !p,
    disabled: c,
    ref: r,
    ...d,
    ownerState: u,
    children: i
  });
});
process.env.NODE_ENV !== "production" && (ya.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The icon to display.
   */
  children: gn(m.node, (e) => be.Children.toArray(e.children).some((r) => /* @__PURE__ */ be.isValidElement(r) && r.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
`)) : null),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'default'
   */
  color: m.oneOfType([m.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), m.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: m.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: m.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: m.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: m.oneOf(["end", "start", !1]),
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: m.oneOfType([m.oneOf(["small", "medium", "large"]), m.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function M1(e) {
  return gt("MuiTypography", e);
}
const zf = ht("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), F1 = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, D1 = e1(), B1 = (e) => {
  const {
    align: t,
    gutterBottom: r,
    noWrap: o,
    paragraph: n,
    variant: i,
    classes: a
  } = e, s = {
    root: ["root", i, e.align !== "inherit" && `align${at(t)}`, r && "gutterBottom", o && "noWrap", n && "paragraph"]
  };
  return _t(s, M1, a);
}, $1 = tt("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.variant && t[r.variant], r.align !== "inherit" && t[`align${at(r.align)}`], r.noWrap && t.noWrap, r.gutterBottom && t.gutterBottom, r.paragraph && t.paragraph];
  }
})(Ct(({
  theme: e
}) => {
  var t;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([r, o]) => r !== "inherit" && o && typeof o == "object").map(([r, o]) => ({
      props: {
        variant: r
      },
      style: o
    })), ...Object.entries(e.palette).filter(yn()).map(([r]) => ({
      props: {
        color: r
      },
      style: {
        color: (e.vars || e).palette[r].main
      }
    })), ...Object.entries(((t = e.palette) == null ? void 0 : t.text) || {}).filter(([, r]) => typeof r == "string").map(([r]) => ({
      props: {
        color: `text${at(r)}`
      },
      style: {
        color: (e.vars || e).palette.text[r]
      }
    })), {
      props: ({
        ownerState: r
      }) => r.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: r
      }) => r.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: r
      }) => r.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: r
      }) => r.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
})), Hf = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Fr = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    color: o,
    ...n
  } = wt({
    props: t,
    name: "MuiTypography"
  }), i = !F1[o], a = D1({
    ...n,
    ...i && {
      color: o
    }
  }), {
    align: s = "inherit",
    className: c,
    component: p,
    gutterBottom: l = !1,
    noWrap: d = !1,
    paragraph: u = !1,
    variant: h = "body1",
    variantMapping: y = Hf,
    ...f
  } = a, b = {
    ...a,
    align: s,
    color: o,
    className: c,
    component: p,
    gutterBottom: l,
    noWrap: d,
    paragraph: u,
    variant: h,
    variantMapping: y
  }, w = p || (u ? "p" : y[h] || Hf[h]) || "span", x = B1(b);
  return /* @__PURE__ */ _e.jsx($1, {
    as: w,
    ref: r,
    className: ot(x.root, c),
    ...f,
    ownerState: b,
    style: {
      ...s !== "inherit" && {
        "--Typography-textAlign": s
      },
      ...f.style
    }
  });
});
process.env.NODE_ENV !== "production" && (Fr.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: m.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary", "success", "error", "info", "warning", "textPrimary", "textSecondary", "textDisabled"]), m.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: m.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: m.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   * @deprecated Use the `component` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  paragraph: m.bool,
  /**
   * @ignore
   */
  style: m.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: m.oneOfType([m.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), m.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: m.object
});
var ir = "top", _r = "bottom", wr = "right", ar = "left", Wc = "auto", Ri = [ir, _r, wr, ar], ao = "start", si = "end", U1 = "clippingParents", Mh = "viewport", Lo = "popper", z1 = "reference", Wf = /* @__PURE__ */ Ri.reduce(function(e, t) {
  return e.concat([t + "-" + ao, t + "-" + si]);
}, []), Fh = /* @__PURE__ */ [].concat(Ri, [Wc]).reduce(function(e, t) {
  return e.concat([t, t + "-" + ao, t + "-" + si]);
}, []), H1 = "beforeRead", W1 = "read", V1 = "afterRead", Z1 = "beforeMain", q1 = "main", Y1 = "afterMain", G1 = "beforeWrite", K1 = "write", X1 = "afterWrite", Q1 = [H1, W1, V1, Z1, q1, Y1, G1, K1, X1];
function Vr(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function hr(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Ln(e) {
  var t = hr(e).Element;
  return e instanceof t || e instanceof Element;
}
function gr(e) {
  var t = hr(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function Vc(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = hr(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function J1(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(r) {
    var o = t.styles[r] || {}, n = t.attributes[r] || {}, i = t.elements[r];
    !gr(i) || !Vr(i) || (Object.assign(i.style, o), Object.keys(n).forEach(function(a) {
      var s = n[a];
      s === !1 ? i.removeAttribute(a) : i.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}
function ew(e) {
  var t = e.state, r = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var n = t.elements[o], i = t.attributes[o] || {}, a = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : r[o]), s = a.reduce(function(c, p) {
        return c[p] = "", c;
      }, {});
      !gr(n) || !Vr(n) || (Object.assign(n.style, s), Object.keys(i).forEach(function(c) {
        n.removeAttribute(c);
      }));
    });
  };
}
const tw = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: J1,
  effect: ew,
  requires: ["computeStyles"]
};
function $r(e) {
  return e.split("-")[0];
}
var kn = Math.max, Fa = Math.min, so = Math.round;
function Wl() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Dh() {
  return !/^((?!chrome|android).)*safari/i.test(Wl());
}
function lo(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var o = e.getBoundingClientRect(), n = 1, i = 1;
  t && gr(e) && (n = e.offsetWidth > 0 && so(o.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && so(o.height) / e.offsetHeight || 1);
  var a = Ln(e) ? hr(e) : window, s = a.visualViewport, c = !Dh() && r, p = (o.left + (c && s ? s.offsetLeft : 0)) / n, l = (o.top + (c && s ? s.offsetTop : 0)) / i, d = o.width / n, u = o.height / i;
  return {
    width: d,
    height: u,
    top: l,
    right: p + d,
    bottom: l + u,
    left: p,
    x: p,
    y: l
  };
}
function Zc(e) {
  var t = lo(e), r = e.offsetWidth, o = e.offsetHeight;
  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: r,
    height: o
  };
}
function Bh(e, t) {
  var r = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (r && Vc(r)) {
    var o = t;
    do {
      if (o && e.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function cn(e) {
  return hr(e).getComputedStyle(e);
}
function rw(e) {
  return ["table", "td", "th"].indexOf(Vr(e)) >= 0;
}
function bn(e) {
  return ((Ln(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function hs(e) {
  return Vr(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (Vc(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    bn(e)
  );
}
function Vf(e) {
  return !gr(e) || // https://github.com/popperjs/popper-core/issues/837
  cn(e).position === "fixed" ? null : e.offsetParent;
}
function nw(e) {
  var t = /firefox/i.test(Wl()), r = /Trident/i.test(Wl());
  if (r && gr(e)) {
    var o = cn(e);
    if (o.position === "fixed")
      return null;
  }
  var n = hs(e);
  for (Vc(n) && (n = n.host); gr(n) && ["html", "body"].indexOf(Vr(n)) < 0; ) {
    var i = cn(n);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || t && i.willChange === "filter" || t && i.filter && i.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Oi(e) {
  for (var t = hr(e), r = Vf(e); r && rw(r) && cn(r).position === "static"; )
    r = Vf(r);
  return r && (Vr(r) === "html" || Vr(r) === "body" && cn(r).position === "static") ? t : r || nw(e) || t;
}
function qc(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Ko(e, t, r) {
  return kn(e, Fa(t, r));
}
function ow(e, t, r) {
  var o = Ko(e, t, r);
  return o > r ? r : o;
}
function $h() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Uh(e) {
  return Object.assign({}, $h(), e);
}
function zh(e, t) {
  return t.reduce(function(r, o) {
    return r[o] = e, r;
  }, {});
}
var iw = function(t, r) {
  return t = typeof t == "function" ? t(Object.assign({}, r.rects, {
    placement: r.placement
  })) : t, Uh(typeof t != "number" ? t : zh(t, Ri));
};
function aw(e) {
  var t, r = e.state, o = e.name, n = e.options, i = r.elements.arrow, a = r.modifiersData.popperOffsets, s = $r(r.placement), c = qc(s), p = [ar, wr].indexOf(s) >= 0, l = p ? "height" : "width";
  if (!(!i || !a)) {
    var d = iw(n.padding, r), u = Zc(i), h = c === "y" ? ir : ar, y = c === "y" ? _r : wr, f = r.rects.reference[l] + r.rects.reference[c] - a[c] - r.rects.popper[l], b = a[c] - r.rects.reference[c], w = Oi(i), x = w ? c === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0, E = f / 2 - b / 2, T = d[h], C = x - u[l] - d[y], R = x / 2 - u[l] / 2 + E, A = Ko(T, R, C), j = c;
    r.modifiersData[o] = (t = {}, t[j] = A, t.centerOffset = A - R, t);
  }
}
function sw(e) {
  var t = e.state, r = e.options, o = r.element, n = o === void 0 ? "[data-popper-arrow]" : o;
  n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || Bh(t.elements.popper, n) && (t.elements.arrow = n));
}
const lw = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: aw,
  effect: sw,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function co(e) {
  return e.split("-")[1];
}
var cw = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function uw(e, t) {
  var r = e.x, o = e.y, n = t.devicePixelRatio || 1;
  return {
    x: so(r * n) / n || 0,
    y: so(o * n) / n || 0
  };
}
function Zf(e) {
  var t, r = e.popper, o = e.popperRect, n = e.placement, i = e.variation, a = e.offsets, s = e.position, c = e.gpuAcceleration, p = e.adaptive, l = e.roundOffsets, d = e.isFixed, u = a.x, h = u === void 0 ? 0 : u, y = a.y, f = y === void 0 ? 0 : y, b = typeof l == "function" ? l({
    x: h,
    y: f
  }) : {
    x: h,
    y: f
  };
  h = b.x, f = b.y;
  var w = a.hasOwnProperty("x"), x = a.hasOwnProperty("y"), E = ar, T = ir, C = window;
  if (p) {
    var R = Oi(r), A = "clientHeight", j = "clientWidth";
    if (R === hr(r) && (R = bn(r), cn(R).position !== "static" && s === "absolute" && (A = "scrollHeight", j = "scrollWidth")), R = R, n === ir || (n === ar || n === wr) && i === si) {
      T = _r;
      var N = d && R === C && C.visualViewport ? C.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        R[A]
      );
      f -= N - o.height, f *= c ? 1 : -1;
    }
    if (n === ar || (n === ir || n === _r) && i === si) {
      E = wr;
      var O = d && R === C && C.visualViewport ? C.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        R[j]
      );
      h -= O - o.width, h *= c ? 1 : -1;
    }
  }
  var D = Object.assign({
    position: s
  }, p && cw), H = l === !0 ? uw({
    x: h,
    y: f
  }, hr(r)) : {
    x: h,
    y: f
  };
  if (h = H.x, f = H.y, c) {
    var G;
    return Object.assign({}, D, (G = {}, G[T] = x ? "0" : "", G[E] = w ? "0" : "", G.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + f + "px)" : "translate3d(" + h + "px, " + f + "px, 0)", G));
  }
  return Object.assign({}, D, (t = {}, t[T] = x ? f + "px" : "", t[E] = w ? h + "px" : "", t.transform = "", t));
}
function fw(e) {
  var t = e.state, r = e.options, o = r.gpuAcceleration, n = o === void 0 ? !0 : o, i = r.adaptive, a = i === void 0 ? !0 : i, s = r.roundOffsets, c = s === void 0 ? !0 : s, p = {
    placement: $r(t.placement),
    variation: co(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Zf(Object.assign({}, p, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: c
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Zf(Object.assign({}, p, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const dw = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: fw,
  data: {}
};
var qi = {
  passive: !0
};
function pw(e) {
  var t = e.state, r = e.instance, o = e.options, n = o.scroll, i = n === void 0 ? !0 : n, a = o.resize, s = a === void 0 ? !0 : a, c = hr(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return i && p.forEach(function(l) {
    l.addEventListener("scroll", r.update, qi);
  }), s && c.addEventListener("resize", r.update, qi), function() {
    i && p.forEach(function(l) {
      l.removeEventListener("scroll", r.update, qi);
    }), s && c.removeEventListener("resize", r.update, qi);
  };
}
const hw = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: pw,
  data: {}
};
var yw = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function ma(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return yw[t];
  });
}
var mw = {
  start: "end",
  end: "start"
};
function qf(e) {
  return e.replace(/start|end/g, function(t) {
    return mw[t];
  });
}
function Yc(e) {
  var t = hr(e), r = t.pageXOffset, o = t.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: o
  };
}
function Gc(e) {
  return lo(bn(e)).left + Yc(e).scrollLeft;
}
function gw(e, t) {
  var r = hr(e), o = bn(e), n = r.visualViewport, i = o.clientWidth, a = o.clientHeight, s = 0, c = 0;
  if (n) {
    i = n.width, a = n.height;
    var p = Dh();
    (p || !p && t === "fixed") && (s = n.offsetLeft, c = n.offsetTop);
  }
  return {
    width: i,
    height: a,
    x: s + Gc(e),
    y: c
  };
}
function bw(e) {
  var t, r = bn(e), o = Yc(e), n = (t = e.ownerDocument) == null ? void 0 : t.body, i = kn(r.scrollWidth, r.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), a = kn(r.scrollHeight, r.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), s = -o.scrollLeft + Gc(e), c = -o.scrollTop;
  return cn(n || r).direction === "rtl" && (s += kn(r.clientWidth, n ? n.clientWidth : 0) - i), {
    width: i,
    height: a,
    x: s,
    y: c
  };
}
function Kc(e) {
  var t = cn(e), r = t.overflow, o = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + n + o);
}
function Hh(e) {
  return ["html", "body", "#document"].indexOf(Vr(e)) >= 0 ? e.ownerDocument.body : gr(e) && Kc(e) ? e : Hh(hs(e));
}
function Xo(e, t) {
  var r;
  t === void 0 && (t = []);
  var o = Hh(e), n = o === ((r = e.ownerDocument) == null ? void 0 : r.body), i = hr(o), a = n ? [i].concat(i.visualViewport || [], Kc(o) ? o : []) : o, s = t.concat(a);
  return n ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(Xo(hs(a)))
  );
}
function Vl(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function vw(e, t) {
  var r = lo(e, !1, t === "fixed");
  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;
}
function Yf(e, t, r) {
  return t === Mh ? Vl(gw(e, r)) : Ln(t) ? vw(t, r) : Vl(bw(bn(e)));
}
function _w(e) {
  var t = Xo(hs(e)), r = ["absolute", "fixed"].indexOf(cn(e).position) >= 0, o = r && gr(e) ? Oi(e) : e;
  return Ln(o) ? t.filter(function(n) {
    return Ln(n) && Bh(n, o) && Vr(n) !== "body";
  }) : [];
}
function ww(e, t, r, o) {
  var n = t === "clippingParents" ? _w(e) : [].concat(t), i = [].concat(n, [r]), a = i[0], s = i.reduce(function(c, p) {
    var l = Yf(e, p, o);
    return c.top = kn(l.top, c.top), c.right = Fa(l.right, c.right), c.bottom = Fa(l.bottom, c.bottom), c.left = kn(l.left, c.left), c;
  }, Yf(e, a, o));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function Wh(e) {
  var t = e.reference, r = e.element, o = e.placement, n = o ? $r(o) : null, i = o ? co(o) : null, a = t.x + t.width / 2 - r.width / 2, s = t.y + t.height / 2 - r.height / 2, c;
  switch (n) {
    case ir:
      c = {
        x: a,
        y: t.y - r.height
      };
      break;
    case _r:
      c = {
        x: a,
        y: t.y + t.height
      };
      break;
    case wr:
      c = {
        x: t.x + t.width,
        y: s
      };
      break;
    case ar:
      c = {
        x: t.x - r.width,
        y: s
      };
      break;
    default:
      c = {
        x: t.x,
        y: t.y
      };
  }
  var p = n ? qc(n) : null;
  if (p != null) {
    var l = p === "y" ? "height" : "width";
    switch (i) {
      case ao:
        c[p] = c[p] - (t[l] / 2 - r[l] / 2);
        break;
      case si:
        c[p] = c[p] + (t[l] / 2 - r[l] / 2);
        break;
    }
  }
  return c;
}
function li(e, t) {
  t === void 0 && (t = {});
  var r = t, o = r.placement, n = o === void 0 ? e.placement : o, i = r.strategy, a = i === void 0 ? e.strategy : i, s = r.boundary, c = s === void 0 ? U1 : s, p = r.rootBoundary, l = p === void 0 ? Mh : p, d = r.elementContext, u = d === void 0 ? Lo : d, h = r.altBoundary, y = h === void 0 ? !1 : h, f = r.padding, b = f === void 0 ? 0 : f, w = Uh(typeof b != "number" ? b : zh(b, Ri)), x = u === Lo ? z1 : Lo, E = e.rects.popper, T = e.elements[y ? x : u], C = ww(Ln(T) ? T : T.contextElement || bn(e.elements.popper), c, l, a), R = lo(e.elements.reference), A = Wh({
    reference: R,
    element: E,
    strategy: "absolute",
    placement: n
  }), j = Vl(Object.assign({}, E, A)), N = u === Lo ? j : R, O = {
    top: C.top - N.top + w.top,
    bottom: N.bottom - C.bottom + w.bottom,
    left: C.left - N.left + w.left,
    right: N.right - C.right + w.right
  }, D = e.modifiersData.offset;
  if (u === Lo && D) {
    var H = D[n];
    Object.keys(O).forEach(function(G) {
      var X = [wr, _r].indexOf(G) >= 0 ? 1 : -1, Q = [ir, _r].indexOf(G) >= 0 ? "y" : "x";
      O[G] += H[Q] * X;
    });
  }
  return O;
}
function Ew(e, t) {
  t === void 0 && (t = {});
  var r = t, o = r.placement, n = r.boundary, i = r.rootBoundary, a = r.padding, s = r.flipVariations, c = r.allowedAutoPlacements, p = c === void 0 ? Fh : c, l = co(o), d = l ? s ? Wf : Wf.filter(function(y) {
    return co(y) === l;
  }) : Ri, u = d.filter(function(y) {
    return p.indexOf(y) >= 0;
  });
  u.length === 0 && (u = d);
  var h = u.reduce(function(y, f) {
    return y[f] = li(e, {
      placement: f,
      boundary: n,
      rootBoundary: i,
      padding: a
    })[$r(f)], y;
  }, {});
  return Object.keys(h).sort(function(y, f) {
    return h[y] - h[f];
  });
}
function Sw(e) {
  if ($r(e) === Wc)
    return [];
  var t = ma(e);
  return [qf(e), t, qf(t)];
}
function Tw(e) {
  var t = e.state, r = e.options, o = e.name;
  if (!t.modifiersData[o]._skip) {
    for (var n = r.mainAxis, i = n === void 0 ? !0 : n, a = r.altAxis, s = a === void 0 ? !0 : a, c = r.fallbackPlacements, p = r.padding, l = r.boundary, d = r.rootBoundary, u = r.altBoundary, h = r.flipVariations, y = h === void 0 ? !0 : h, f = r.allowedAutoPlacements, b = t.options.placement, w = $r(b), x = w === b, E = c || (x || !y ? [ma(b)] : Sw(b)), T = [b].concat(E).reduce(function(Z, oe) {
      return Z.concat($r(oe) === Wc ? Ew(t, {
        placement: oe,
        boundary: l,
        rootBoundary: d,
        padding: p,
        flipVariations: y,
        allowedAutoPlacements: f
      }) : oe);
    }, []), C = t.rects.reference, R = t.rects.popper, A = /* @__PURE__ */ new Map(), j = !0, N = T[0], O = 0; O < T.length; O++) {
      var D = T[O], H = $r(D), G = co(D) === ao, X = [ir, _r].indexOf(H) >= 0, Q = X ? "width" : "height", M = li(t, {
        placement: D,
        boundary: l,
        rootBoundary: d,
        altBoundary: u,
        padding: p
      }), k = X ? G ? wr : ar : G ? _r : ir;
      C[Q] > R[Q] && (k = ma(k));
      var $ = ma(k), ne = [];
      if (i && ne.push(M[H] <= 0), s && ne.push(M[k] <= 0, M[$] <= 0), ne.every(function(Z) {
        return Z;
      })) {
        N = D, j = !1;
        break;
      }
      A.set(D, ne);
    }
    if (j)
      for (var te = y ? 3 : 1, de = function(oe) {
        var ye = T.find(function(V) {
          var q = A.get(V);
          if (q)
            return q.slice(0, oe).every(function(ee) {
              return ee;
            });
        });
        if (ye)
          return N = ye, "break";
      }, ae = te; ae > 0; ae--) {
        var z = de(ae);
        if (z === "break") break;
      }
    t.placement !== N && (t.modifiersData[o]._skip = !0, t.placement = N, t.reset = !0);
  }
}
const xw = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Tw,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Gf(e, t, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - r.y,
    right: e.right - t.width + r.x,
    bottom: e.bottom - t.height + r.y,
    left: e.left - t.width - r.x
  };
}
function Kf(e) {
  return [ir, wr, _r, ar].some(function(t) {
    return e[t] >= 0;
  });
}
function Rw(e) {
  var t = e.state, r = e.name, o = t.rects.reference, n = t.rects.popper, i = t.modifiersData.preventOverflow, a = li(t, {
    elementContext: "reference"
  }), s = li(t, {
    altBoundary: !0
  }), c = Gf(a, o), p = Gf(s, n, i), l = Kf(c), d = Kf(p);
  t.modifiersData[r] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: p,
    isReferenceHidden: l,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": l,
    "data-popper-escaped": d
  });
}
const Ow = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Rw
};
function Aw(e, t, r) {
  var o = $r(e), n = [ar, ir].indexOf(o) >= 0 ? -1 : 1, i = typeof r == "function" ? r(Object.assign({}, t, {
    placement: e
  })) : r, a = i[0], s = i[1];
  return a = a || 0, s = (s || 0) * n, [ar, wr].indexOf(o) >= 0 ? {
    x: s,
    y: a
  } : {
    x: a,
    y: s
  };
}
function kw(e) {
  var t = e.state, r = e.options, o = e.name, n = r.offset, i = n === void 0 ? [0, 0] : n, a = Fh.reduce(function(l, d) {
    return l[d] = Aw(d, t.rects, i), l;
  }, {}), s = a[t.placement], c = s.x, p = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += p), t.modifiersData[o] = a;
}
const Cw = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: kw
};
function Pw(e) {
  var t = e.state, r = e.name;
  t.modifiersData[r] = Wh({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const Iw = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Pw,
  data: {}
};
function Nw(e) {
  return e === "x" ? "y" : "x";
}
function Lw(e) {
  var t = e.state, r = e.options, o = e.name, n = r.mainAxis, i = n === void 0 ? !0 : n, a = r.altAxis, s = a === void 0 ? !1 : a, c = r.boundary, p = r.rootBoundary, l = r.altBoundary, d = r.padding, u = r.tether, h = u === void 0 ? !0 : u, y = r.tetherOffset, f = y === void 0 ? 0 : y, b = li(t, {
    boundary: c,
    rootBoundary: p,
    padding: d,
    altBoundary: l
  }), w = $r(t.placement), x = co(t.placement), E = !x, T = qc(w), C = Nw(T), R = t.modifiersData.popperOffsets, A = t.rects.reference, j = t.rects.popper, N = typeof f == "function" ? f(Object.assign({}, t.rects, {
    placement: t.placement
  })) : f, O = typeof N == "number" ? {
    mainAxis: N,
    altAxis: N
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, N), D = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, H = {
    x: 0,
    y: 0
  };
  if (R) {
    if (i) {
      var G, X = T === "y" ? ir : ar, Q = T === "y" ? _r : wr, M = T === "y" ? "height" : "width", k = R[T], $ = k + b[X], ne = k - b[Q], te = h ? -j[M] / 2 : 0, de = x === ao ? A[M] : j[M], ae = x === ao ? -j[M] : -A[M], z = t.elements.arrow, Z = h && z ? Zc(z) : {
        width: 0,
        height: 0
      }, oe = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : $h(), ye = oe[X], V = oe[Q], q = Ko(0, A[M], Z[M]), ee = E ? A[M] / 2 - te - q - ye - O.mainAxis : de - q - ye - O.mainAxis, ue = E ? -A[M] / 2 + te + q + V + O.mainAxis : ae + q + V + O.mainAxis, ge = t.elements.arrow && Oi(t.elements.arrow), he = ge ? T === "y" ? ge.clientTop || 0 : ge.clientLeft || 0 : 0, W = (G = D == null ? void 0 : D[T]) != null ? G : 0, Y = k + ee - W - he, se = k + ue - W, Te = Ko(h ? Fa($, Y) : $, k, h ? kn(ne, se) : ne);
      R[T] = Te, H[T] = Te - k;
    }
    if (s) {
      var Oe, B = T === "x" ? ir : ar, U = T === "x" ? _r : wr, _ = R[C], v = C === "y" ? "height" : "width", S = _ + b[B], P = _ - b[U], J = [ir, ar].indexOf(w) !== -1, ve = (Oe = D == null ? void 0 : D[C]) != null ? Oe : 0, Re = J ? S : _ - A[v] - j[v] - ve + O.altAxis, je = J ? _ + A[v] + j[v] - ve - O.altAxis : P, qe = h && J ? ow(Re, _, je) : Ko(h ? Re : S, _, h ? je : P);
      R[C] = qe, H[C] = qe - _;
    }
    t.modifiersData[o] = H;
  }
}
const jw = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Lw,
  requiresIfExists: ["offset"]
};
function Mw(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Fw(e) {
  return e === hr(e) || !gr(e) ? Yc(e) : Mw(e);
}
function Dw(e) {
  var t = e.getBoundingClientRect(), r = so(t.width) / e.offsetWidth || 1, o = so(t.height) / e.offsetHeight || 1;
  return r !== 1 || o !== 1;
}
function Bw(e, t, r) {
  r === void 0 && (r = !1);
  var o = gr(t), n = gr(t) && Dw(t), i = bn(t), a = lo(e, n, r), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (o || !o && !r) && ((Vr(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Kc(i)) && (s = Fw(t)), gr(t) ? (c = lo(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : i && (c.x = Gc(i))), {
    x: a.left + s.scrollLeft - c.x,
    y: a.top + s.scrollTop - c.y,
    width: a.width,
    height: a.height
  };
}
function $w(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), o = [];
  e.forEach(function(i) {
    t.set(i.name, i);
  });
  function n(i) {
    r.add(i.name);
    var a = [].concat(i.requires || [], i.requiresIfExists || []);
    a.forEach(function(s) {
      if (!r.has(s)) {
        var c = t.get(s);
        c && n(c);
      }
    }), o.push(i);
  }
  return e.forEach(function(i) {
    r.has(i.name) || n(i);
  }), o;
}
function Uw(e) {
  var t = $w(e);
  return Q1.reduce(function(r, o) {
    return r.concat(t.filter(function(n) {
      return n.phase === o;
    }));
  }, []);
}
function zw(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(r) {
      Promise.resolve().then(function() {
        t = void 0, r(e());
      });
    })), t;
  };
}
function Hw(e) {
  var t = e.reduce(function(r, o) {
    var n = r[o.name];
    return r[o.name] = n ? Object.assign({}, n, o, {
      options: Object.assign({}, n.options, o.options),
      data: Object.assign({}, n.data, o.data)
    }) : o, r;
  }, {});
  return Object.keys(t).map(function(r) {
    return t[r];
  });
}
var Xf = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Qf() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function Ww(e) {
  e === void 0 && (e = {});
  var t = e, r = t.defaultModifiers, o = r === void 0 ? [] : r, n = t.defaultOptions, i = n === void 0 ? Xf : n;
  return function(s, c, p) {
    p === void 0 && (p = i);
    var l = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Xf, i),
      modifiersData: {},
      elements: {
        reference: s,
        popper: c
      },
      attributes: {},
      styles: {}
    }, d = [], u = !1, h = {
      state: l,
      setOptions: function(w) {
        var x = typeof w == "function" ? w(l.options) : w;
        f(), l.options = Object.assign({}, i, l.options, x), l.scrollParents = {
          reference: Ln(s) ? Xo(s) : s.contextElement ? Xo(s.contextElement) : [],
          popper: Xo(c)
        };
        var E = Uw(Hw([].concat(o, l.options.modifiers)));
        return l.orderedModifiers = E.filter(function(T) {
          return T.enabled;
        }), y(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!u) {
          var w = l.elements, x = w.reference, E = w.popper;
          if (Qf(x, E)) {
            l.rects = {
              reference: Bw(x, Oi(E), l.options.strategy === "fixed"),
              popper: Zc(E)
            }, l.reset = !1, l.placement = l.options.placement, l.orderedModifiers.forEach(function(O) {
              return l.modifiersData[O.name] = Object.assign({}, O.data);
            });
            for (var T = 0; T < l.orderedModifiers.length; T++) {
              if (l.reset === !0) {
                l.reset = !1, T = -1;
                continue;
              }
              var C = l.orderedModifiers[T], R = C.fn, A = C.options, j = A === void 0 ? {} : A, N = C.name;
              typeof R == "function" && (l = R({
                state: l,
                options: j,
                name: N,
                instance: h
              }) || l);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: zw(function() {
        return new Promise(function(b) {
          h.forceUpdate(), b(l);
        });
      }),
      destroy: function() {
        f(), u = !0;
      }
    };
    if (!Qf(s, c))
      return h;
    h.setOptions(p).then(function(b) {
      !u && p.onFirstUpdate && p.onFirstUpdate(b);
    });
    function y() {
      l.orderedModifiers.forEach(function(b) {
        var w = b.name, x = b.options, E = x === void 0 ? {} : x, T = b.effect;
        if (typeof T == "function") {
          var C = T({
            state: l,
            name: w,
            instance: h,
            options: E
          }), R = function() {
          };
          d.push(C || R);
        }
      });
    }
    function f() {
      d.forEach(function(b) {
        return b();
      }), d = [];
    }
    return h;
  };
}
var Vw = [hw, Iw, dw, tw, Cw, xw, jw, lw, Ow], Zw = /* @__PURE__ */ Ww({
  defaultModifiers: Vw
});
function qw(e) {
  return typeof e == "function" ? e() : e;
}
const ci = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    children: o,
    container: n,
    disablePortal: i = !1
  } = t, [a, s] = be.useState(null), c = Mt(/* @__PURE__ */ be.isValidElement(o) ? vo(o) : null, r);
  if (Wr(() => {
    i || s(qw(n) || document.body);
  }, [n, i]), Wr(() => {
    if (a && !i)
      return jl(r, a), () => {
        jl(r, null);
      };
  }, [r, a, i]), i) {
    if (/* @__PURE__ */ be.isValidElement(o)) {
      const p = {
        ref: c
      };
      return /* @__PURE__ */ be.cloneElement(o, p);
    }
    return o;
  }
  return a && /* @__PURE__ */ Xm.createPortal(o, a);
});
process.env.NODE_ENV !== "production" && (ci.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The children to render into the `container`.
   */
  children: m.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: m.oneOfType([sn, m.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: m.bool
});
process.env.NODE_ENV !== "production" && (ci.propTypes = fh(ci.propTypes));
function Yw(e) {
  return gt("MuiPopper", e);
}
ht("MuiPopper", ["root"]);
function Gw(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function Da(e) {
  return typeof e == "function" ? e() : e;
}
function ys(e) {
  return e.nodeType !== void 0;
}
function Kw(e) {
  return !ys(e);
}
const Xw = (e) => {
  const {
    classes: t
  } = e;
  return _t({
    root: ["root"]
  }, Yw, t);
}, Qw = {}, Jw = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    anchorEl: o,
    children: n,
    direction: i,
    disablePortal: a,
    modifiers: s,
    open: c,
    placement: p,
    popperOptions: l,
    popperRef: d,
    slotProps: u = {},
    slots: h = {},
    TransitionProps: y,
    // @ts-ignore internal logic
    ownerState: f,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...b
  } = t, w = be.useRef(null), x = Mt(w, r), E = be.useRef(null), T = Mt(E, d), C = be.useRef(T);
  Wr(() => {
    C.current = T;
  }, [T]), be.useImperativeHandle(d, () => E.current, []);
  const R = Gw(p, i), [A, j] = be.useState(R), [N, O] = be.useState(Da(o));
  be.useEffect(() => {
    E.current && E.current.forceUpdate();
  }), be.useEffect(() => {
    o && O(Da(o));
  }, [o]), Wr(() => {
    if (!N || !c)
      return;
    const Q = ($) => {
      j($.placement);
    };
    if (process.env.NODE_ENV !== "production" && N && ys(N) && N.nodeType === 1) {
      const $ = N.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && $.top === 0 && $.left === 0 && $.right === 0 && $.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let M = [{
      name: "preventOverflow",
      options: {
        altBoundary: a
      }
    }, {
      name: "flip",
      options: {
        altBoundary: a
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: $
      }) => {
        Q($);
      }
    }];
    s != null && (M = M.concat(s)), l && l.modifiers != null && (M = M.concat(l.modifiers));
    const k = Zw(N, w.current, {
      placement: R,
      ...l,
      modifiers: M
    });
    return C.current(k), () => {
      k.destroy(), C.current(null);
    };
  }, [N, a, s, c, l, R]);
  const D = {
    placement: A
  };
  y !== null && (D.TransitionProps = y);
  const H = Xw(t), G = h.root ?? "div", X = Dl({
    elementType: G,
    externalSlotProps: u.root,
    externalForwardedProps: b,
    additionalProps: {
      role: "tooltip",
      ref: x
    },
    ownerState: t,
    className: H.root
  });
  return /* @__PURE__ */ _e.jsx(G, {
    ...X,
    children: typeof n == "function" ? n(D) : n
  });
}), Vh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    anchorEl: o,
    children: n,
    container: i,
    direction: a = "ltr",
    disablePortal: s = !1,
    keepMounted: c = !1,
    modifiers: p,
    open: l,
    placement: d = "bottom",
    popperOptions: u = Qw,
    popperRef: h,
    style: y,
    transition: f = !1,
    slotProps: b = {},
    slots: w = {},
    ...x
  } = t, [E, T] = be.useState(!0), C = () => {
    T(!1);
  }, R = () => {
    T(!0);
  };
  if (!c && !l && (!f || E))
    return null;
  let A;
  if (i)
    A = i;
  else if (o) {
    const O = Da(o);
    A = O && ys(O) ? pr(O).body : pr(null).body;
  }
  const j = !l && c && (!f || E) ? "none" : void 0, N = f ? {
    in: l,
    onEnter: C,
    onExited: R
  } : void 0;
  return /* @__PURE__ */ _e.jsx(ci, {
    disablePortal: s,
    container: A,
    children: /* @__PURE__ */ _e.jsx(Jw, {
      anchorEl: o,
      direction: a,
      disablePortal: s,
      modifiers: p,
      ref: r,
      open: f ? !E : l,
      placement: d,
      popperOptions: u,
      popperRef: h,
      slotProps: b,
      slots: w,
      ...x,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: j,
        ...y
      },
      TransitionProps: N,
      children: n
    })
  });
});
process.env.NODE_ENV !== "production" && (Vh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: gn(m.oneOfType([sn, m.object, m.func]), (e) => {
    if (e.open) {
      const t = Da(e.anchorEl);
      if (t && ys(t) && t.nodeType === 1) {
        const r = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || Kw(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: m.oneOfType([m.node, m.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: m.oneOfType([sn, m.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: m.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: m.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: m.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: m.arrayOf(m.shape({
    data: m.object,
    effect: m.func,
    enabled: m.bool,
    fn: m.func,
    name: m.any,
    options: m.object,
    phase: m.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: m.arrayOf(m.string),
    requiresIfExists: m.arrayOf(m.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: m.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: m.shape({
    modifiers: m.array,
    onFirstUpdate: m.func,
    placement: m.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: m.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: Ar,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: m.shape({
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: m.shape({
    root: m.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: m.bool
});
const eE = tt(Vh, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), Xc = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = Dc(), n = wt({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: i,
    component: a,
    components: s,
    componentsProps: c,
    container: p,
    disablePortal: l,
    keepMounted: d,
    modifiers: u,
    open: h,
    placement: y,
    popperOptions: f,
    popperRef: b,
    transition: w,
    slots: x,
    slotProps: E,
    ...T
  } = n, C = (x == null ? void 0 : x.root) ?? (s == null ? void 0 : s.Root), R = {
    anchorEl: i,
    container: p,
    disablePortal: l,
    keepMounted: d,
    modifiers: u,
    open: h,
    placement: y,
    popperOptions: f,
    popperRef: b,
    transition: w,
    ...T
  };
  return /* @__PURE__ */ _e.jsx(eE, {
    as: a,
    direction: o ? "rtl" : "ltr",
    slots: {
      root: C
    },
    slotProps: E ?? c,
    ...R,
    ref: r
  });
});
process.env.NODE_ENV !== "production" && (Xc.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: m.oneOfType([sn, m.object, m.func]),
  /**
   * Popper render function or node.
   */
  children: m.oneOfType([m.node, m.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: m.shape({
    Root: m.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: m.shape({
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: m.oneOfType([sn, m.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: m.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: m.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: m.arrayOf(m.shape({
    data: m.object,
    effect: m.func,
    enabled: m.bool,
    fn: m.func,
    name: m.any,
    options: m.object,
    phase: m.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: m.arrayOf(m.string),
    requiresIfExists: m.arrayOf(m.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: m.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: m.shape({
    modifiers: m.array,
    onFirstUpdate: m.func,
    placement: m.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: m.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: Ar,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: m.shape({
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: m.shape({
    root: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: m.bool
});
function Yi(e) {
  return parseInt(e, 10) || 0;
}
const tE = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function rE(e) {
  return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflowing;
}
const Zh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    onChange: o,
    maxRows: n,
    minRows: i = 1,
    style: a,
    value: s,
    ...c
  } = t, {
    current: p
  } = be.useRef(s != null), l = be.useRef(null), d = Mt(r, l), u = be.useRef(null), h = be.useRef(null), y = be.useCallback(() => {
    const w = l.current, E = ln(w).getComputedStyle(w);
    if (E.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    const T = h.current;
    T.style.width = E.width, T.value = w.value || t.placeholder || "x", T.value.slice(-1) === `
` && (T.value += " ");
    const C = E.boxSizing, R = Yi(E.paddingBottom) + Yi(E.paddingTop), A = Yi(E.borderBottomWidth) + Yi(E.borderTopWidth), j = T.scrollHeight;
    T.value = "x";
    const N = T.scrollHeight;
    let O = j;
    i && (O = Math.max(Number(i) * N, O)), n && (O = Math.min(Number(n) * N, O)), O = Math.max(O, N);
    const D = O + (C === "border-box" ? R + A : 0), H = Math.abs(O - j) <= 1;
    return {
      outerHeightStyle: D,
      overflowing: H
    };
  }, [n, i, t.placeholder]), f = be.useCallback(() => {
    const w = y();
    if (rE(w))
      return;
    const x = w.outerHeightStyle, E = l.current;
    u.current !== x && (u.current = x, E.style.height = `${x}px`), E.style.overflow = w.overflowing ? "hidden" : "";
  }, [y]);
  Wr(() => {
    const w = () => {
      f();
    };
    let x;
    const E = () => {
      cancelAnimationFrame(x), x = requestAnimationFrame(() => {
        w();
      });
    }, T = dh(w), C = l.current, R = ln(C);
    R.addEventListener("resize", T);
    let A;
    return typeof ResizeObserver < "u" && (A = new ResizeObserver(process.env.NODE_ENV === "test" ? E : w), A.observe(C)), () => {
      T.clear(), cancelAnimationFrame(x), R.removeEventListener("resize", T), A && A.disconnect();
    };
  }, [y, f]), Wr(() => {
    f();
  });
  const b = (w) => {
    p || f(), o && o(w);
  };
  return /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [/* @__PURE__ */ _e.jsx("textarea", {
      value: s,
      onChange: b,
      ref: d,
      rows: i,
      style: a,
      ...c
    }), /* @__PURE__ */ _e.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: h,
      tabIndex: -1,
      style: {
        ...tE.shadow,
        ...a,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
process.env.NODE_ENV !== "production" && (Zh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  className: m.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * @ignore
   */
  onChange: m.func,
  /**
   * @ignore
   */
  placeholder: m.string,
  /**
   * @ignore
   */
  style: m.object,
  /**
   * @ignore
   */
  value: m.oneOfType([m.arrayOf(m.string), m.number, m.string])
});
function ui(e) {
  return typeof e == "string";
}
function _o({
  props: e,
  states: t,
  muiFormControl: r
}) {
  return t.reduce((o, n) => (o[n] = e[n], r && typeof e[n] > "u" && (o[n] = r[n]), o), {});
}
const ms = /* @__PURE__ */ be.createContext(void 0);
process.env.NODE_ENV !== "production" && (ms.displayName = "FormControlContext");
function wo() {
  return be.useContext(ms);
}
function Jf(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function Ba(e, t = !1) {
  return e && (Jf(e.value) && e.value !== "" || t && Jf(e.defaultValue) && e.defaultValue !== "");
}
function nE(e) {
  return e.startAdornment;
}
function oE(e) {
  return gt("MuiInputBase", e);
}
const uo = ht("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var ed;
const gs = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.formControl && t.formControl, r.startAdornment && t.adornedStart, r.endAdornment && t.adornedEnd, r.error && t.error, r.size === "small" && t.sizeSmall, r.multiline && t.multiline, r.color && t[`color${at(r.color)}`], r.fullWidth && t.fullWidth, r.hiddenLabel && t.hiddenLabel];
}, bs = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.input, r.size === "small" && t.inputSizeSmall, r.multiline && t.inputMultiline, r.type === "search" && t.inputTypeSearch, r.startAdornment && t.inputAdornedStart, r.endAdornment && t.inputAdornedEnd, r.hiddenLabel && t.inputHiddenLabel];
}, iE = (e) => {
  const {
    classes: t,
    color: r,
    disabled: o,
    error: n,
    endAdornment: i,
    focused: a,
    formControl: s,
    fullWidth: c,
    hiddenLabel: p,
    multiline: l,
    readOnly: d,
    size: u,
    startAdornment: h,
    type: y
  } = e, f = {
    root: ["root", `color${at(r)}`, o && "disabled", n && "error", c && "fullWidth", a && "focused", s && "formControl", u && u !== "medium" && `size${at(u)}`, l && "multiline", h && "adornedStart", i && "adornedEnd", p && "hiddenLabel", d && "readOnly"],
    input: ["input", o && "disabled", y === "search" && "inputTypeSearch", l && "inputMultiline", u === "small" && "inputSizeSmall", p && "inputHiddenLabel", h && "inputAdornedStart", i && "inputAdornedEnd", d && "readOnly"]
  };
  return _t(f, oE, t);
}, vs = tt("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: gs
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${uo.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: r
    }) => t.multiline && r === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), _s = tt("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: bs
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", r = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, o = {
    opacity: "0 !important"
  }, n = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": r,
    "&::-moz-placeholder": r,
    // Firefox 19+
    "&::-ms-input-placeholder": r,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${uo.formControl} &`]: {
      "&::-webkit-input-placeholder": o,
      "&::-moz-placeholder": o,
      // Firefox 19+
      "&::-ms-input-placeholder": o,
      // Edge
      "&:focus::-webkit-input-placeholder": n,
      "&:focus::-moz-placeholder": n,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": n
      // Edge
    },
    [`&.${uo.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: i
      }) => !i.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: i
      }) => i.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), td = J_({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), ws = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": n,
    autoComplete: i,
    autoFocus: a,
    className: s,
    color: c,
    components: p = {},
    componentsProps: l = {},
    defaultValue: d,
    disabled: u,
    disableInjectingGlobalStyles: h,
    endAdornment: y,
    error: f,
    fullWidth: b = !1,
    id: w,
    inputComponent: x = "input",
    inputProps: E = {},
    inputRef: T,
    margin: C,
    maxRows: R,
    minRows: A,
    multiline: j = !1,
    name: N,
    onBlur: O,
    onChange: D,
    onClick: H,
    onFocus: G,
    onKeyDown: X,
    onKeyUp: Q,
    placeholder: M,
    readOnly: k,
    renderSuffix: $,
    rows: ne,
    size: te,
    slotProps: de = {},
    slots: ae = {},
    startAdornment: z,
    type: Z = "text",
    value: oe,
    ...ye
  } = o, V = E.value != null ? E.value : oe, {
    current: q
  } = be.useRef(V != null), ee = be.useRef(), ue = be.useCallback((Fe) => {
    process.env.NODE_ENV !== "production" && Fe && Fe.nodeName !== "INPUT" && !Fe.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), ge = Mt(ee, T, E.ref, ue), [he, W] = be.useState(!1), Y = wo();
  process.env.NODE_ENV !== "production" && be.useEffect(() => {
    if (Y)
      return Y.registerEffect();
  }, [Y]);
  const se = _o({
    props: o,
    muiFormControl: Y,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  se.focused = Y ? Y.focused : he, be.useEffect(() => {
    !Y && u && he && (W(!1), O && O());
  }, [Y, u, he, O]);
  const Te = Y && Y.onFilled, Oe = Y && Y.onEmpty, B = be.useCallback((Fe) => {
    Ba(Fe) ? Te && Te() : Oe && Oe();
  }, [Te, Oe]);
  Wr(() => {
    q && B({
      value: V
    });
  }, [V, B, q]);
  const U = (Fe) => {
    G && G(Fe), E.onFocus && E.onFocus(Fe), Y && Y.onFocus ? Y.onFocus(Fe) : W(!0);
  }, _ = (Fe) => {
    O && O(Fe), E.onBlur && E.onBlur(Fe), Y && Y.onBlur ? Y.onBlur(Fe) : W(!1);
  }, v = (Fe, ...rt) => {
    if (!q) {
      const Ge = Fe.target || ee.current;
      if (Ge == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : Hr(1));
      B({
        value: Ge.value
      });
    }
    E.onChange && E.onChange(Fe, ...rt), D && D(Fe, ...rt);
  };
  be.useEffect(() => {
    B(ee.current);
  }, []);
  const S = (Fe) => {
    ee.current && Fe.currentTarget === Fe.target && ee.current.focus(), H && H(Fe);
  };
  let P = x, J = E;
  j && P === "input" && (ne ? (process.env.NODE_ENV !== "production" && (A || R) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), J = {
    type: void 0,
    minRows: ne,
    maxRows: ne,
    ...J
  }) : J = {
    type: void 0,
    maxRows: R,
    minRows: A,
    ...J
  }, P = Zh);
  const ve = (Fe) => {
    B(Fe.animationName === "mui-auto-fill-cancel" ? ee.current : {
      value: "x"
    });
  };
  be.useEffect(() => {
    Y && Y.setAdornedStart(!!z);
  }, [Y, z]);
  const Re = {
    ...o,
    color: se.color || "primary",
    disabled: se.disabled,
    endAdornment: y,
    error: se.error,
    focused: se.focused,
    formControl: Y,
    fullWidth: b,
    hiddenLabel: se.hiddenLabel,
    multiline: j,
    size: se.size,
    startAdornment: z,
    type: Z
  }, je = iE(Re), qe = ae.root || p.Root || vs, ze = de.root || l.root || {}, We = ae.input || p.Input || _s;
  return J = {
    ...J,
    ...de.input ?? l.input
  }, /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [!h && typeof td == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (ed || (ed = /* @__PURE__ */ _e.jsx(td, {}))), /* @__PURE__ */ _e.jsxs(qe, {
      ...ze,
      ref: r,
      onClick: S,
      ...ye,
      ...!ui(qe) && {
        ownerState: {
          ...Re,
          ...ze.ownerState
        }
      },
      className: ot(je.root, ze.className, s, k && "MuiInputBase-readOnly"),
      children: [z, /* @__PURE__ */ _e.jsx(ms.Provider, {
        value: null,
        children: /* @__PURE__ */ _e.jsx(We, {
          "aria-invalid": se.error,
          "aria-describedby": n,
          autoComplete: i,
          autoFocus: a,
          defaultValue: d,
          disabled: se.disabled,
          id: w,
          onAnimationStart: ve,
          name: N,
          placeholder: M,
          readOnly: k,
          required: se.required,
          rows: ne,
          value: V,
          onKeyDown: X,
          onKeyUp: Q,
          type: Z,
          ...J,
          ...!ui(We) && {
            as: P,
            ownerState: {
              ...Re,
              ...J.ownerState
            }
          },
          ref: ge,
          className: ot(je.input, J.className, k && "MuiInputBase-readOnly"),
          onBlur: _,
          onChange: v,
          onFocus: U
        })
      }), y, $ ? $({
        ...se,
        startAdornment: z
      }) : null]
    })]
  });
});
process.env.NODE_ENV !== "production" && (ws.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  "aria-describedby": m.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: m.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: m.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), m.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Input: m.elementType,
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: m.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: m.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: m.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: m.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * The id of the `input` element.
   */
  id: m.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: us,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: m.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Ar,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: m.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: m.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: m.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: m.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * @ignore
   */
  onClick: m.func,
  /**
   * @ignore
   */
  onFocus: m.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: m.func,
  /**
   * @ignore
   */
  onKeyDown: m.func,
  /**
   * @ignore
   */
  onKeyUp: m.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: m.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: m.bool,
  /**
   * @ignore
   */
  renderSuffix: m.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: m.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: m.oneOfType([m.number, m.string]),
  /**
   * The size of the component.
   */
  size: m.oneOfType([m.oneOf(["medium", "small"]), m.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: m.shape({
    input: m.elementType,
    root: m.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: m.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: m.any
});
function aE(e) {
  return gt("MuiInput", e);
}
const jo = {
  ...uo,
  ...ht("MuiInput", ["root", "underline", "input"])
};
function sE(e) {
  return gt("MuiOutlinedInput", e);
}
const Pr = {
  ...uo,
  ...ht("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function lE(e) {
  return gt("MuiFilledInput", e);
}
const wn = {
  ...uo,
  ...ht("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, cE = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), uE = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, qh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = ds(), n = {
    enter: o.transitions.duration.enteringScreen,
    exit: o.transitions.duration.leavingScreen
  }, {
    addEndListener: i,
    appear: a = !0,
    children: s,
    easing: c,
    in: p,
    onEnter: l,
    onEntered: d,
    onEntering: u,
    onExit: h,
    onExited: y,
    onExiting: f,
    style: b,
    timeout: w = n,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: x = qr,
    ...E
  } = t, T = be.useRef(null), C = Mt(T, vo(s), r), R = (X) => (Q) => {
    if (X) {
      const M = T.current;
      Q === void 0 ? X(M) : X(M, Q);
    }
  }, A = R(u), j = R((X, Q) => {
    Ih(X);
    const M = ja({
      style: b,
      timeout: w,
      easing: c
    }, {
      mode: "enter"
    });
    X.style.webkitTransition = o.transitions.create("opacity", M), X.style.transition = o.transitions.create("opacity", M), l && l(X, Q);
  }), N = R(d), O = R(f), D = R((X) => {
    const Q = ja({
      style: b,
      timeout: w,
      easing: c
    }, {
      mode: "exit"
    });
    X.style.webkitTransition = o.transitions.create("opacity", Q), X.style.transition = o.transitions.create("opacity", Q), h && h(X);
  }), H = R(y), G = (X) => {
    i && i(T.current, X);
  };
  return /* @__PURE__ */ _e.jsx(x, {
    appear: a,
    in: p,
    nodeRef: T,
    onEnter: j,
    onEntered: N,
    onEntering: A,
    onExit: D,
    onExited: H,
    onExiting: O,
    addEndListener: G,
    timeout: w,
    ...E,
    children: (X, Q) => /* @__PURE__ */ be.cloneElement(s, {
      style: {
        opacity: 0,
        visibility: X === "exited" && !p ? "hidden" : void 0,
        ...uE[X],
        ...b,
        ...s.props.style
      },
      ref: C,
      ...Q
    })
  });
});
process.env.NODE_ENV !== "production" && (qh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: m.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: m.bool,
  /**
   * A single child content element.
   */
  children: bo.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: m.oneOfType([m.shape({
    enter: m.string,
    exit: m.string
  }), m.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: m.bool,
  /**
   * @ignore
   */
  onEnter: m.func,
  /**
   * @ignore
   */
  onEntered: m.func,
  /**
   * @ignore
   */
  onEntering: m.func,
  /**
   * @ignore
   */
  onExit: m.func,
  /**
   * @ignore
   */
  onExited: m.func,
  /**
   * @ignore
   */
  onExiting: m.func,
  /**
   * @ignore
   */
  style: m.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: m.oneOfType([m.number, m.shape({
    appear: m.number,
    enter: m.number,
    exit: m.number
  })])
});
function fE(e) {
  return gt("MuiBackdrop", e);
}
ht("MuiBackdrop", ["root", "invisible"]);
const dE = (e) => {
  const {
    ownerState: t,
    ...r
  } = e;
  return r;
}, pE = (e) => {
  const {
    classes: t,
    invisible: r
  } = e;
  return _t({
    root: ["root", r && "invisible"]
  }, fE, t);
}, hE = tt("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), Yh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: n,
    className: i,
    component: a = "div",
    invisible: s = !1,
    open: c,
    components: p = {},
    componentsProps: l = {},
    slotProps: d = {},
    slots: u = {},
    TransitionComponent: h,
    transitionDuration: y,
    ...f
  } = o, b = {
    ...o,
    component: a,
    invisible: s
  }, w = pE(b), x = {
    transition: h,
    root: p.Root,
    ...u
  }, E = {
    ...l,
    ...d
  }, T = {
    slots: x,
    slotProps: E
  }, [C, R] = Zt("root", {
    elementType: hE,
    externalForwardedProps: T,
    className: ot(w.root, i),
    ownerState: b
  }), [A, j] = Zt("transition", {
    elementType: qh,
    externalForwardedProps: T,
    ownerState: b
  }), N = dE(j);
  return /* @__PURE__ */ _e.jsx(A, {
    in: c,
    timeout: y,
    ...f,
    ...N,
    children: /* @__PURE__ */ _e.jsx(C, {
      "aria-hidden": !0,
      ...R,
      classes: w,
      ref: r,
      children: n
    })
  });
});
process.env.NODE_ENV !== "production" && (Yh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    root: m.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: m.bool,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    root: m.oneOfType([m.func, m.object]),
    transition: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    root: m.elementType,
    transition: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   * @deprecated Use `slots.transition` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: m.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: m.oneOfType([m.number, m.shape({
    appear: m.number,
    enter: m.number,
    exit: m.number
  })])
});
const yE = ht("MuiBox", ["root"]), mE = Oh(), fr = Bv({
  themeId: Ga,
  defaultTheme: mE,
  defaultClassName: yE.root,
  generateClassName: nh.generate
});
process.env.NODE_ENV !== "production" && (fr.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: m.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function gE(e) {
  return gt("MuiButton", e);
}
const Hn = ht("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), Gh = /* @__PURE__ */ be.createContext({});
process.env.NODE_ENV !== "production" && (Gh.displayName = "ButtonGroupContext");
const Kh = /* @__PURE__ */ be.createContext(void 0);
process.env.NODE_ENV !== "production" && (Kh.displayName = "ButtonGroupButtonContext");
const bE = (e) => {
  const {
    color: t,
    disableElevation: r,
    fullWidth: o,
    size: n,
    variant: i,
    classes: a
  } = e, s = {
    root: ["root", i, `${i}${at(t)}`, `size${at(n)}`, `${i}Size${at(n)}`, `color${at(t)}`, r && "disableElevation", o && "fullWidth"],
    label: ["label"],
    startIcon: ["icon", "startIcon", `iconSize${at(n)}`],
    endIcon: ["icon", "endIcon", `iconSize${at(n)}`]
  }, c = _t(s, gE, a);
  return {
    ...a,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...c
  };
}, Xh = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], vE = tt(ps, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, t[r.variant], t[`${r.variant}${at(r.color)}`], t[`size${at(r.size)}`], t[`${r.variant}Size${at(r.size)}`], r.color === "inherit" && t.colorInherit, r.disableElevation && t.disableElevation, r.fullWidth && t.fullWidth];
  }
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], r = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return {
    ...e.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${Hn.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (e.vars || e).shadows[2],
        "&:hover": {
          boxShadow: (e.vars || e).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (e.vars || e).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (e.vars || e).shadows[8]
        },
        [`&.${Hn.focusVisible}`]: {
          boxShadow: (e.vars || e).shadows[6]
        },
        [`&.${Hn.disabled}`]: {
          color: (e.vars || e).palette.action.disabled,
          boxShadow: (e.vars || e).shadows[0],
          backgroundColor: (e.vars || e).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${Hn.disabled}`]: {
          border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(e.palette).filter(yn()).map(([o]) => ({
      props: {
        color: o
      },
      style: {
        "--variant-textColor": (e.vars || e).palette[o].main,
        "--variant-outlinedColor": (e.vars || e).palette[o].main,
        "--variant-outlinedBorder": e.vars ? `rgba(${e.vars.palette[o].mainChannel} / 0.5)` : Qt(e.palette[o].main, 0.5),
        "--variant-containedColor": (e.vars || e).palette[o].contrastText,
        "--variant-containedBg": (e.vars || e).palette[o].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (e.vars || e).palette[o].dark,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette[o].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt(e.palette[o].main, e.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (e.vars || e).palette[o].main,
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette[o].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt(e.palette[o].main, e.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : r,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt(e.palette.text.primary, e.palette.action.hoverOpacity),
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Qt(e.palette.text.primary, e.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${Hn.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${Hn.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }]
  };
})), _E = tt("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.startIcon, t[`iconSize${at(r.size)}`]];
  }
})({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, ...Xh]
}), wE = tt("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.endIcon, t[`iconSize${at(r.size)}`]];
  }
})({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, ...Xh]
}), fi = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = be.useContext(Gh), n = be.useContext(Kh), i = Ia(o, t), a = wt({
    props: i,
    name: "MuiButton"
  }), {
    children: s,
    color: c = "primary",
    component: p = "button",
    className: l,
    disabled: d = !1,
    disableElevation: u = !1,
    disableFocusRipple: h = !1,
    endIcon: y,
    focusVisibleClassName: f,
    fullWidth: b = !1,
    size: w = "medium",
    startIcon: x,
    type: E,
    variant: T = "text",
    ...C
  } = a, R = {
    ...a,
    color: c,
    component: p,
    disabled: d,
    disableElevation: u,
    disableFocusRipple: h,
    fullWidth: b,
    size: w,
    type: E,
    variant: T
  }, A = bE(R), j = x && /* @__PURE__ */ _e.jsx(_E, {
    className: A.startIcon,
    ownerState: R,
    children: x
  }), N = y && /* @__PURE__ */ _e.jsx(wE, {
    className: A.endIcon,
    ownerState: R,
    children: y
  }), O = n || "";
  return /* @__PURE__ */ _e.jsxs(vE, {
    ownerState: R,
    className: ot(o.className, A.root, l, O),
    component: p,
    disabled: d,
    focusRipple: !h,
    focusVisibleClassName: ot(A.focusVisible, f),
    ref: r,
    type: E,
    ...C,
    classes: A,
    children: [j, s, N]
  });
});
process.env.NODE_ENV !== "production" && (fi.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: m.oneOfType([m.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), m.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: m.bool,
  /**
   * If `true`, no elevation is used.
   * @default false
   */
  disableElevation: m.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: m.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: m.bool,
  /**
   * Element placed after the children.
   */
  endIcon: m.node,
  /**
   * @ignore
   */
  focusVisibleClassName: m.string,
  /**
   * If `true`, the button will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: m.string,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: m.oneOfType([m.oneOf(["small", "medium", "large"]), m.string]),
  /**
   * Element placed before the children.
   */
  startIcon: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * @ignore
   */
  type: m.oneOfType([m.oneOf(["button", "reset", "submit"]), m.string]),
  /**
   * The variant to use.
   * @default 'text'
   */
  variant: m.oneOfType([m.oneOf(["contained", "outlined", "text"]), m.string])
});
function EE(e) {
  const t = pr(e);
  return t.body === e ? ln(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function Qo(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function rd(e) {
  return parseInt(ln(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function SE(e) {
  const r = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), o = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return r || o;
}
function nd(e, t, r, o, n) {
  const i = [t, r, ...o];
  [].forEach.call(e.children, (a) => {
    const s = !i.includes(a), c = !SE(a);
    s && c && Qo(a, n);
  });
}
function rl(e, t) {
  let r = -1;
  return e.some((o, n) => t(o) ? (r = n, !0) : !1), r;
}
function TE(e, t) {
  const r = [], o = e.container;
  if (!t.disableScrollLock) {
    if (EE(o)) {
      const a = hh(ln(o));
      r.push({
        value: o.style.paddingRight,
        property: "padding-right",
        el: o
      }), o.style.paddingRight = `${rd(o) + a}px`;
      const s = pr(o).querySelectorAll(".mui-fixed");
      [].forEach.call(s, (c) => {
        r.push({
          value: c.style.paddingRight,
          property: "padding-right",
          el: c
        }), c.style.paddingRight = `${rd(c) + a}px`;
      });
    }
    let i;
    if (o.parentNode instanceof DocumentFragment)
      i = pr(o).body;
    else {
      const a = o.parentElement, s = ln(o);
      i = (a == null ? void 0 : a.nodeName) === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : o;
    }
    r.push({
      value: i.style.overflow,
      property: "overflow",
      el: i
    }, {
      value: i.style.overflowX,
      property: "overflow-x",
      el: i
    }, {
      value: i.style.overflowY,
      property: "overflow-y",
      el: i
    }), i.style.overflow = "hidden";
  }
  return () => {
    r.forEach(({
      value: i,
      el: a,
      property: s
    }) => {
      i ? a.style.setProperty(s, i) : a.style.removeProperty(s);
    });
  };
}
function xE(e) {
  const t = [];
  return [].forEach.call(e.children, (r) => {
    r.getAttribute("aria-hidden") === "true" && t.push(r);
  }), t;
}
class RE {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, r) {
    let o = this.modals.indexOf(t);
    if (o !== -1)
      return o;
    o = this.modals.length, this.modals.push(t), t.modalRef && Qo(t.modalRef, !1);
    const n = xE(r);
    nd(r, t.mount, t.modalRef, n, !0);
    const i = rl(this.containers, (a) => a.container === r);
    return i !== -1 ? (this.containers[i].modals.push(t), o) : (this.containers.push({
      modals: [t],
      container: r,
      restore: null,
      hiddenSiblings: n
    }), o);
  }
  mount(t, r) {
    const o = rl(this.containers, (i) => i.modals.includes(t)), n = this.containers[o];
    n.restore || (n.restore = TE(n, r));
  }
  remove(t, r = !0) {
    const o = this.modals.indexOf(t);
    if (o === -1)
      return o;
    const n = rl(this.containers, (a) => a.modals.includes(t)), i = this.containers[n];
    if (i.modals.splice(i.modals.indexOf(t), 1), this.modals.splice(o, 1), i.modals.length === 0)
      i.restore && i.restore(), t.modalRef && Qo(t.modalRef, r), nd(i.container, t.mount, t.modalRef, i.hiddenSiblings, !1), this.containers.splice(n, 1);
    else {
      const a = i.modals[i.modals.length - 1];
      a.modalRef && Qo(a.modalRef, !1);
    }
    return o;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const OE = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function AE(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function kE(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (o) => e.ownerDocument.querySelector(`input[type="radio"]${o}`);
  let r = t(`[name="${e.name}"]:checked`);
  return r || (r = t(`[name="${e.name}"]`)), r !== e;
}
function CE(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || kE(e));
}
function PE(e) {
  const t = [], r = [];
  return Array.from(e.querySelectorAll(OE)).forEach((o, n) => {
    const i = AE(o);
    i === -1 || !CE(o) || (i === 0 ? t.push(o) : r.push({
      documentOrder: n,
      tabIndex: i,
      node: o
    }));
  }), r.sort((o, n) => o.tabIndex === n.tabIndex ? o.documentOrder - n.documentOrder : o.tabIndex - n.tabIndex).map((o) => o.node).concat(t);
}
function IE() {
  return !0;
}
function $a(e) {
  const {
    children: t,
    disableAutoFocus: r = !1,
    disableEnforceFocus: o = !1,
    disableRestoreFocus: n = !1,
    getTabbable: i = PE,
    isEnabled: a = IE,
    open: s
  } = e, c = be.useRef(!1), p = be.useRef(null), l = be.useRef(null), d = be.useRef(null), u = be.useRef(null), h = be.useRef(!1), y = be.useRef(null), f = Mt(vo(t), y), b = be.useRef(null);
  be.useEffect(() => {
    !s || !y.current || (h.current = !r);
  }, [r, s]), be.useEffect(() => {
    if (!s || !y.current)
      return;
    const E = pr(y.current);
    return y.current.contains(E.activeElement) || (y.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), y.current.setAttribute("tabIndex", "-1")), h.current && y.current.focus()), () => {
      n || (d.current && d.current.focus && (c.current = !0, d.current.focus()), d.current = null);
    };
  }, [s]), be.useEffect(() => {
    if (!s || !y.current)
      return;
    const E = pr(y.current), T = (A) => {
      b.current = A, !(o || !a() || A.key !== "Tab") && E.activeElement === y.current && A.shiftKey && (c.current = !0, l.current && l.current.focus());
    }, C = () => {
      var N, O;
      const A = y.current;
      if (A === null)
        return;
      if (!E.hasFocus() || !a() || c.current) {
        c.current = !1;
        return;
      }
      if (A.contains(E.activeElement) || o && E.activeElement !== p.current && E.activeElement !== l.current)
        return;
      if (E.activeElement !== u.current)
        u.current = null;
      else if (u.current !== null)
        return;
      if (!h.current)
        return;
      let j = [];
      if ((E.activeElement === p.current || E.activeElement === l.current) && (j = i(y.current)), j.length > 0) {
        const D = !!((N = b.current) != null && N.shiftKey && ((O = b.current) == null ? void 0 : O.key) === "Tab"), H = j[0], G = j[j.length - 1];
        typeof H != "string" && typeof G != "string" && (D ? G.focus() : H.focus());
      } else
        A.focus();
    };
    E.addEventListener("focusin", C), E.addEventListener("keydown", T, !0);
    const R = setInterval(() => {
      E.activeElement && E.activeElement.tagName === "BODY" && C();
    }, 50);
    return () => {
      clearInterval(R), E.removeEventListener("focusin", C), E.removeEventListener("keydown", T, !0);
    };
  }, [r, o, n, a, s, i]);
  const w = (E) => {
    d.current === null && (d.current = E.relatedTarget), h.current = !0, u.current = E.target;
    const T = t.props.onFocus;
    T && T(E);
  }, x = (E) => {
    d.current === null && (d.current = E.relatedTarget), h.current = !0;
  };
  return /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [/* @__PURE__ */ _e.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: x,
      ref: p,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ be.cloneElement(t, {
      ref: f,
      onFocus: w
    }), /* @__PURE__ */ _e.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: x,
      ref: l,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && ($a.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A single child content element.
   */
  children: bo,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: m.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: m.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: m.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: m.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: m.func,
  /**
   * If `true`, focus is locked.
   */
  open: m.bool.isRequired
});
process.env.NODE_ENV !== "production" && ($a.propTypes = fh($a.propTypes));
function NE(e) {
  return typeof e == "function" ? e() : e;
}
function LE(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const od = () => {
}, Gi = new RE();
function jE(e) {
  const {
    container: t,
    disableEscapeKeyDown: r = !1,
    disableScrollLock: o = !1,
    closeAfterTransition: n = !1,
    onTransitionEnter: i,
    onTransitionExited: a,
    children: s,
    onClose: c,
    open: p,
    rootRef: l
  } = e, d = be.useRef({}), u = be.useRef(null), h = be.useRef(null), y = Mt(h, l), [f, b] = be.useState(!p), w = LE(s);
  let x = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (x = !1);
  const E = () => pr(u.current), T = () => (d.current.modalRef = h.current, d.current.mount = u.current, d.current), C = () => {
    Gi.mount(T(), {
      disableScrollLock: o
    }), h.current && (h.current.scrollTop = 0);
  }, R = dn(() => {
    const Q = NE(t) || E().body;
    Gi.add(T(), Q), h.current && C();
  }), A = () => Gi.isTopModal(T()), j = dn((Q) => {
    u.current = Q, Q && (p && A() ? C() : h.current && Qo(h.current, x));
  }), N = be.useCallback(() => {
    Gi.remove(T(), x);
  }, [x]);
  be.useEffect(() => () => {
    N();
  }, [N]), be.useEffect(() => {
    p ? R() : (!w || !n) && N();
  }, [p, N, w, n, R]);
  const O = (Q) => (M) => {
    var k;
    (k = Q.onKeyDown) == null || k.call(Q, M), !(M.key !== "Escape" || M.which === 229 || // Wait until IME is settled.
    !A()) && (r || (M.stopPropagation(), c && c(M, "escapeKeyDown")));
  }, D = (Q) => (M) => {
    var k;
    (k = Q.onClick) == null || k.call(Q, M), M.target === M.currentTarget && c && c(M, "backdropClick");
  };
  return {
    getRootProps: (Q = {}) => {
      const M = vh(e);
      delete M.onTransitionEnter, delete M.onTransitionExited;
      const k = {
        ...M,
        ...Q
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...k,
        onKeyDown: O(k),
        ref: y
      };
    },
    getBackdropProps: (Q = {}) => {
      const M = Q;
      return {
        "aria-hidden": !0,
        ...M,
        onClick: D(M),
        open: p
      };
    },
    getTransitionProps: () => {
      const Q = () => {
        b(!1), i && i();
      }, M = () => {
        b(!0), a && a(), n && N();
      };
      return {
        onEnter: xf(Q, (s == null ? void 0 : s.props.onEnter) ?? od),
        onExited: xf(M, (s == null ? void 0 : s.props.onExited) ?? od)
      };
    },
    rootRef: y,
    portalRef: j,
    isTopModal: A,
    exited: f,
    hasTransition: w
  };
}
function ME(e) {
  return gt("MuiModal", e);
}
ht("MuiModal", ["root", "hidden", "backdrop"]);
const FE = (e) => {
  const {
    open: t,
    exited: r,
    classes: o
  } = e;
  return _t({
    root: ["root", !t && r && "hidden"],
    backdrop: ["backdrop"]
  }, ME, o);
}, DE = tt("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.open && r.exited && t.hidden];
  }
})(Ct(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), BE = tt(Yh, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), Qc = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: n = BE,
    BackdropProps: i,
    classes: a,
    className: s,
    closeAfterTransition: c = !1,
    children: p,
    container: l,
    component: d,
    components: u = {},
    componentsProps: h = {},
    disableAutoFocus: y = !1,
    disableEnforceFocus: f = !1,
    disableEscapeKeyDown: b = !1,
    disablePortal: w = !1,
    disableRestoreFocus: x = !1,
    disableScrollLock: E = !1,
    hideBackdrop: T = !1,
    keepMounted: C = !1,
    onBackdropClick: R,
    onClose: A,
    onTransitionEnter: j,
    onTransitionExited: N,
    open: O,
    slotProps: D = {},
    slots: H = {},
    // eslint-disable-next-line react/prop-types
    theme: G,
    ...X
  } = o, Q = {
    ...o,
    closeAfterTransition: c,
    disableAutoFocus: y,
    disableEnforceFocus: f,
    disableEscapeKeyDown: b,
    disablePortal: w,
    disableRestoreFocus: x,
    disableScrollLock: E,
    hideBackdrop: T,
    keepMounted: C
  }, {
    getRootProps: M,
    getBackdropProps: k,
    getTransitionProps: $,
    portalRef: ne,
    isTopModal: te,
    exited: de,
    hasTransition: ae
  } = jE({
    ...Q,
    rootRef: r
  }), z = {
    ...Q,
    exited: de
  }, Z = FE(z), oe = {};
  if (p.props.tabIndex === void 0 && (oe.tabIndex = "-1"), ae) {
    const {
      onEnter: he,
      onExited: W
    } = $();
    oe.onEnter = he, oe.onExited = W;
  }
  const ye = {
    ...X,
    slots: {
      root: u.Root,
      backdrop: u.Backdrop,
      ...H
    },
    slotProps: {
      ...h,
      ...D
    }
  }, [V, q] = Zt("root", {
    elementType: DE,
    externalForwardedProps: ye,
    getSlotProps: M,
    additionalProps: {
      ref: r,
      as: d
    },
    ownerState: z,
    className: ot(s, Z == null ? void 0 : Z.root, !z.open && z.exited && (Z == null ? void 0 : Z.hidden))
  }), [ee, ue] = Zt("backdrop", {
    elementType: n,
    externalForwardedProps: ye,
    additionalProps: i,
    getSlotProps: (he) => k({
      ...he,
      onClick: (W) => {
        R && R(W), he != null && he.onClick && he.onClick(W);
      }
    }),
    className: ot(i == null ? void 0 : i.className, Z == null ? void 0 : Z.backdrop),
    ownerState: z
  }), ge = Mt(i == null ? void 0 : i.ref, ue.ref);
  return !C && !O && (!ae || de) ? null : /* @__PURE__ */ _e.jsx(ci, {
    ref: ne,
    container: l,
    disablePortal: w,
    children: /* @__PURE__ */ _e.jsxs(V, {
      ...q,
      children: [!T && n ? /* @__PURE__ */ _e.jsx(ee, {
        ...ue,
        ref: ge
      }) : null, /* @__PURE__ */ _e.jsx($a, {
        disableEnforceFocus: f,
        disableAutoFocus: y,
        disableRestoreFocus: x,
        isEnabled: te,
        open: O,
        children: /* @__PURE__ */ be.cloneElement(p, oe)
      })]
    })
  });
});
process.env.NODE_ENV !== "production" && (Qc.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: m.elementType,
  /**
   * Props applied to the [`Backdrop`](https://mui.com/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: m.object,
  /**
   * A single child content element.
   */
  children: bo.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: m.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Backdrop: m.elementType,
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    backdrop: m.oneOfType([m.func, m.object]),
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: m.oneOfType([sn, m.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: m.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: m.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: m.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: m.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: m.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: m.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: m.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: m.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: m.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: m.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: m.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: m.func,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: m.shape({
    backdrop: m.oneOfType([m.func, m.object]),
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: m.shape({
    backdrop: m.elementType,
    root: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
const id = ht("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), $E = (e) => {
  const {
    classes: t,
    disableUnderline: r,
    startAdornment: o,
    endAdornment: n,
    size: i,
    hiddenLabel: a,
    multiline: s
  } = e, c = {
    root: ["root", !r && "underline", o && "adornedStart", n && "adornedEnd", i === "small" && `size${at(i)}`, a && "hiddenLabel", s && "multiline"],
    input: ["input"]
  }, p = _t(c, lE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...p
  };
}, UE = tt(vs, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [...gs(e, t), !r.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", r = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", o = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", n = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", i = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : n,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o
      }
    },
    [`&.${wn.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o
    },
    [`&.${wn.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : i
    },
    variants: [{
      props: ({
        ownerState: a
      }) => !a.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${wn.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${wn.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : r}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${wn.disabled}, .${wn.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${wn.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(yn()).map(([a]) => {
      var s;
      return {
        props: {
          disableUnderline: !1,
          color: a
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(s = (e.vars || e).palette[a]) == null ? void 0 : s.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState: a
      }) => a.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: a,
        size: s
      }) => a.multiline && s === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: a
      }) => a.multiline && a.hiddenLabel && a.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), zE = tt(_s, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: bs
})(Ct(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), di = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: n = !1,
    components: i = {},
    componentsProps: a,
    fullWidth: s = !1,
    hiddenLabel: c,
    // declare here to prevent spreading to DOM
    inputComponent: p = "input",
    multiline: l = !1,
    slotProps: d,
    slots: u = {},
    type: h = "text",
    ...y
  } = o, f = {
    ...o,
    disableUnderline: n,
    fullWidth: s,
    inputComponent: p,
    multiline: l,
    type: h
  }, b = $E(o), w = {
    root: {
      ownerState: f
    },
    input: {
      ownerState: f
    }
  }, x = d ?? a ? tr(w, d ?? a) : w, E = u.root ?? i.Root ?? UE, T = u.input ?? i.Input ?? zE;
  return /* @__PURE__ */ _e.jsx(ws, {
    slots: {
      root: E,
      input: T
    },
    slotProps: x,
    fullWidth: s,
    inputComponent: p,
    multiline: l,
    ref: r,
    type: h,
    ...y,
    classes: b
  });
});
process.env.NODE_ENV !== "production" && (di.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: m.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: m.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary"]), m.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Input: m.elementType,
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: m.bool,
  /**
   * If `true`, the input will not have an underline.
   * @default false
   */
  disableUnderline: m.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: m.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: m.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: m.bool,
  /**
   * The id of the `input` element.
   */
  id: m.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: m.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: m.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Ar,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: m.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: m.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: m.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: m.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: m.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: m.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: m.oneOfType([m.number, m.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: m.shape({
    input: m.elementType,
    root: m.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: m.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: m.any
});
di && (di.muiName = "Input");
function HE(e) {
  return gt("MuiFormControl", e);
}
ht("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const WE = (e) => {
  const {
    classes: t,
    margin: r,
    fullWidth: o
  } = e, n = {
    root: ["root", r !== "none" && `margin${at(r)}`, o && "fullWidth"]
  };
  return _t(n, HE, t);
}, VE = tt("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => ({
    ...t.root,
    ...t[`margin${at(e.margin)}`],
    ...e.fullWidth && t.fullWidth
  })
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), Ai = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiFormControl"
  }), {
    children: n,
    className: i,
    color: a = "primary",
    component: s = "div",
    disabled: c = !1,
    error: p = !1,
    focused: l,
    fullWidth: d = !1,
    hiddenLabel: u = !1,
    margin: h = "none",
    required: y = !1,
    size: f = "medium",
    variant: b = "outlined",
    ...w
  } = o, x = {
    ...o,
    color: a,
    component: s,
    disabled: c,
    error: p,
    fullWidth: d,
    hiddenLabel: u,
    margin: h,
    required: y,
    size: f,
    variant: b
  }, E = WE(x), [T, C] = be.useState(() => {
    let X = !1;
    return n && be.Children.forEach(n, (Q) => {
      if (!Go(Q, ["Input", "Select"]))
        return;
      const M = Go(Q, ["Select"]) ? Q.props.input : Q;
      M && nE(M.props) && (X = !0);
    }), X;
  }), [R, A] = be.useState(() => {
    let X = !1;
    return n && be.Children.forEach(n, (Q) => {
      Go(Q, ["Input", "Select"]) && (Ba(Q.props, !0) || Ba(Q.props.inputProps, !0)) && (X = !0);
    }), X;
  }), [j, N] = be.useState(!1);
  c && j && N(!1);
  const O = l !== void 0 && !c ? l : j;
  let D;
  const H = be.useRef(!1);
  process.env.NODE_ENV !== "production" && (D = () => (H.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), H.current = !0, () => {
    H.current = !1;
  }));
  const G = be.useMemo(() => ({
    adornedStart: T,
    setAdornedStart: C,
    color: a,
    disabled: c,
    error: p,
    filled: R,
    focused: O,
    fullWidth: d,
    hiddenLabel: u,
    size: f,
    onBlur: () => {
      N(!1);
    },
    onEmpty: () => {
      A(!1);
    },
    onFilled: () => {
      A(!0);
    },
    onFocus: () => {
      N(!0);
    },
    registerEffect: D,
    required: y,
    variant: b
  }), [T, a, c, p, R, O, d, u, D, y, f, b]);
  return /* @__PURE__ */ _e.jsx(ms.Provider, {
    value: G,
    children: /* @__PURE__ */ _e.jsx(VE, {
      as: s,
      ownerState: x,
      className: ot(E.root, i),
      ref: r,
      ...w,
      children: n
    })
  });
});
process.env.NODE_ENV !== "production" && (Ai.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), m.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: m.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: m.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: m.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: m.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: m.oneOf(["dense", "none", "normal"]),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: m.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: m.oneOfType([m.oneOf(["medium", "small"]), m.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: m.oneOf(["filled", "outlined", "standard"])
});
function ZE(e) {
  return gt("MuiFormHelperText", e);
}
const ad = ht("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var sd;
const qE = (e) => {
  const {
    classes: t,
    contained: r,
    size: o,
    disabled: n,
    error: i,
    filled: a,
    focused: s,
    required: c
  } = e, p = {
    root: ["root", n && "disabled", i && "error", o && `size${at(o)}`, r && "contained", s && "focused", a && "filled", c && "required"]
  };
  return _t(p, ZE, t);
}, YE = tt("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.size && t[`size${at(r.size)}`], r.contained && t.contained, r.filled && t.filled];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${ad.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${ad.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), Jc = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: n,
    className: i,
    component: a = "p",
    disabled: s,
    error: c,
    filled: p,
    focused: l,
    margin: d,
    required: u,
    variant: h,
    ...y
  } = o, f = wo(), b = _o({
    props: o,
    muiFormControl: f,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), w = {
    ...o,
    component: a,
    contained: b.variant === "filled" || b.variant === "outlined",
    variant: b.variant,
    size: b.size,
    disabled: b.disabled,
    error: b.error,
    filled: b.filled,
    focused: b.focused,
    required: b.required
  };
  delete w.ownerState;
  const x = qE(w);
  return /* @__PURE__ */ _e.jsx(YE, {
    as: a,
    className: ot(x.root, i),
    ref: r,
    ...y,
    ownerState: w,
    children: n === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      sd || (sd = /* @__PURE__ */ _e.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: "​"
      }))
    ) : n
  });
});
process.env.NODE_ENV !== "production" && (Jc.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: m.bool,
  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: m.bool,
  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: m.bool,
  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: m.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: m.oneOf(["dense"]),
  /**
   * If `true`, the helper text should use required classes key.
   */
  required: m.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The variant to use.
   */
  variant: m.oneOfType([m.oneOf(["filled", "outlined", "standard"]), m.string])
});
function GE(e) {
  return gt("MuiFormLabel", e);
}
const Jo = ht("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), KE = (e) => {
  const {
    classes: t,
    color: r,
    focused: o,
    disabled: n,
    error: i,
    filled: a,
    required: s
  } = e, c = {
    root: ["root", `color${at(r)}`, n && "disabled", i && "error", a && "filled", o && "focused", s && "required"],
    asterisk: ["asterisk", i && "error"]
  };
  return _t(c, GE, t);
}, XE = tt("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => ({
    ...t.root,
    ...e.color === "secondary" && t.colorSecondary,
    ...e.filled && t.filled
  })
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(yn()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Jo.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${Jo.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${Jo.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), QE = tt("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (e, t) => t.asterisk
})(Ct(({
  theme: e
}) => ({
  [`&.${Jo.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), Es = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: n,
    className: i,
    color: a,
    component: s = "label",
    disabled: c,
    error: p,
    filled: l,
    focused: d,
    required: u,
    ...h
  } = o, y = wo(), f = _o({
    props: o,
    muiFormControl: y,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), b = {
    ...o,
    color: f.color || "primary",
    component: s,
    disabled: f.disabled,
    error: f.error,
    filled: f.filled,
    focused: f.focused,
    required: f.required
  }, w = KE(b);
  return /* @__PURE__ */ _e.jsxs(XE, {
    as: s,
    ownerState: b,
    className: ot(w.root, i),
    ref: r,
    ...h,
    children: [n, f.required && /* @__PURE__ */ _e.jsxs(QE, {
      ownerState: b,
      "aria-hidden": !0,
      className: w.asterisk,
      children: [" ", "*"]
    })]
  });
});
process.env.NODE_ENV !== "production" && (Es.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: m.oneOfType([m.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), m.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: m.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: m.bool,
  /**
   * If `true`, the label should use filled classes key.
   */
  filled: m.bool,
  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: m.bool,
  /**
   * If `true`, the label will indicate that the `input` is required.
   */
  required: m.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function Zl(e) {
  return `scale(${e}, ${e ** 2})`;
}
const JE = {
  entering: {
    opacity: 1,
    transform: Zl(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, nl = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), pi = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    addEndListener: o,
    appear: n = !0,
    children: i,
    easing: a,
    in: s,
    onEnter: c,
    onEntered: p,
    onEntering: l,
    onExit: d,
    onExited: u,
    onExiting: h,
    style: y,
    timeout: f = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: b = qr,
    ...w
  } = t, x = Kn(), E = be.useRef(), T = ds(), C = be.useRef(null), R = Mt(C, vo(i), r), A = (Q) => (M) => {
    if (Q) {
      const k = C.current;
      M === void 0 ? Q(k) : Q(k, M);
    }
  }, j = A(l), N = A((Q, M) => {
    Ih(Q);
    const {
      duration: k,
      delay: $,
      easing: ne
    } = ja({
      style: y,
      timeout: f,
      easing: a
    }, {
      mode: "enter"
    });
    let te;
    f === "auto" ? (te = T.transitions.getAutoHeightDuration(Q.clientHeight), E.current = te) : te = k, Q.style.transition = [T.transitions.create("opacity", {
      duration: te,
      delay: $
    }), T.transitions.create("transform", {
      duration: nl ? te : te * 0.666,
      delay: $,
      easing: ne
    })].join(","), c && c(Q, M);
  }), O = A(p), D = A(h), H = A((Q) => {
    const {
      duration: M,
      delay: k,
      easing: $
    } = ja({
      style: y,
      timeout: f,
      easing: a
    }, {
      mode: "exit"
    });
    let ne;
    f === "auto" ? (ne = T.transitions.getAutoHeightDuration(Q.clientHeight), E.current = ne) : ne = M, Q.style.transition = [T.transitions.create("opacity", {
      duration: ne,
      delay: k
    }), T.transitions.create("transform", {
      duration: nl ? ne : ne * 0.666,
      delay: nl ? k : k || ne * 0.333,
      easing: $
    })].join(","), Q.style.opacity = 0, Q.style.transform = Zl(0.75), d && d(Q);
  }), G = A(u), X = (Q) => {
    f === "auto" && x.start(E.current || 0, Q), o && o(C.current, Q);
  };
  return /* @__PURE__ */ _e.jsx(b, {
    appear: n,
    in: s,
    nodeRef: C,
    onEnter: N,
    onEntered: O,
    onEntering: j,
    onExit: H,
    onExited: G,
    onExiting: D,
    addEndListener: X,
    timeout: f === "auto" ? null : f,
    ...w,
    children: (Q, M) => /* @__PURE__ */ be.cloneElement(i, {
      style: {
        opacity: 0,
        transform: Zl(0.75),
        visibility: Q === "exited" && !s ? "hidden" : void 0,
        ...JE[Q],
        ...y,
        ...i.props.style
      },
      ref: R,
      ...M
    })
  });
});
process.env.NODE_ENV !== "production" && (pi.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: m.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: m.bool,
  /**
   * A single child content element.
   */
  children: bo.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: m.oneOfType([m.shape({
    enter: m.string,
    exit: m.string
  }), m.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: m.bool,
  /**
   * @ignore
   */
  onEnter: m.func,
  /**
   * @ignore
   */
  onEntered: m.func,
  /**
   * @ignore
   */
  onEntering: m.func,
  /**
   * @ignore
   */
  onExit: m.func,
  /**
   * @ignore
   */
  onExited: m.func,
  /**
   * @ignore
   */
  onExiting: m.func,
  /**
   * @ignore
   */
  style: m.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: m.oneOfType([m.oneOf(["auto"]), m.number, m.shape({
    appear: m.number,
    enter: m.number,
    exit: m.number
  })])
});
pi && (pi.muiSupportAuto = !0);
const eS = (e) => {
  const {
    classes: t,
    disableUnderline: r
  } = e, n = _t({
    root: ["root", !r && "underline"],
    input: ["input"]
  }, aE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...n
  };
}, tS = tt(vs, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [...gs(e, t), !r.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  let r = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (r = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: o
      }) => o.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: o
      }) => !o.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${jo.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${jo.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${r}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${jo.disabled}, .${jo.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${r}`
          }
        },
        [`&.${jo.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(yn()).map(([o]) => ({
      props: {
        color: o,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[o].main}`
        }
      }
    }))]
  };
})), rS = tt(_s, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: bs
})({}), hi = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: n = !1,
    components: i = {},
    componentsProps: a,
    fullWidth: s = !1,
    inputComponent: c = "input",
    multiline: p = !1,
    slotProps: l,
    slots: d = {},
    type: u = "text",
    ...h
  } = o, y = eS(o), b = {
    root: {
      ownerState: {
        disableUnderline: n
      }
    }
  }, w = l ?? a ? tr(l ?? a, b) : b, x = d.root ?? i.Root ?? tS, E = d.input ?? i.Input ?? rS;
  return /* @__PURE__ */ _e.jsx(ws, {
    slots: {
      root: x,
      input: E
    },
    slotProps: w,
    fullWidth: s,
    inputComponent: c,
    multiline: p,
    ref: r,
    type: u,
    ...h,
    classes: y
  });
});
process.env.NODE_ENV !== "production" && (hi.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: m.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: m.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary"]), m.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Input: m.elementType,
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: m.bool,
  /**
   * If `true`, the `input` will not have an underline.
   * @default false
   */
  disableUnderline: m.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: m.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: m.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * The id of the `input` element.
   */
  id: m.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: m.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: m.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Ar,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: m.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: m.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: m.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: m.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: m.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: m.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: m.oneOfType([m.number, m.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: m.shape({
    input: m.object,
    root: m.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: m.shape({
    input: m.elementType,
    root: m.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: m.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: m.any
});
hi && (hi.muiName = "Input");
function nS(e) {
  return gt("MuiInputLabel", e);
}
ht("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const oS = (e) => {
  const {
    classes: t,
    formControl: r,
    size: o,
    shrink: n,
    disableAnimation: i,
    variant: a,
    required: s
  } = e, c = {
    root: ["root", r && "formControl", !i && "animated", n && "shrink", o && o !== "normal" && `size${at(o)}`, a],
    asterisk: [s && "asterisk"]
  }, p = _t(c, nS, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...p
  };
}, iS = tt(Es, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [{
      [`& .${Jo.asterisk}`]: t.asterisk
    }, t.root, r.formControl && t.formControl, r.size === "small" && t.sizeSmall, r.shrink && t.shrink, !r.disableAnimation && t.animated, r.focused && t.focused, t[r.variant]];
  }
})(Ct(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: r
    }) => t === "filled" && r.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: r,
      size: o
    }) => t === "filled" && r.shrink && o === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: r
    }) => t === "outlined" && r.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), Qh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: n = !1,
    margin: i,
    shrink: a,
    variant: s,
    className: c,
    ...p
  } = o, l = wo();
  let d = a;
  typeof d > "u" && l && (d = l.filled || l.focused || l.adornedStart);
  const u = _o({
    props: o,
    muiFormControl: l,
    states: ["size", "variant", "required", "focused"]
  }), h = {
    ...o,
    disableAnimation: n,
    formControl: l,
    shrink: d,
    size: u.size,
    variant: u.variant,
    required: u.required,
    focused: u.focused
  }, y = oS(h);
  return /* @__PURE__ */ _e.jsx(iS, {
    "data-shrink": d,
    ref: r,
    className: ot(y.root, c),
    ...p,
    ownerState: h,
    classes: y
  });
});
process.env.NODE_ENV !== "production" && (Qh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: m.oneOfType([m.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), m.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: m.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: m.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: m.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: m.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: m.oneOf(["dense"]),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: m.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: m.bool,
  /**
   * The size of the component.
   * @default 'normal'
   */
  size: m.oneOfType([m.oneOf(["normal", "small"]), m.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The variant to use.
   */
  variant: m.oneOf(["filled", "outlined", "standard"])
});
const Ur = /* @__PURE__ */ be.createContext({});
process.env.NODE_ENV !== "production" && (Ur.displayName = "ListContext");
function aS(e) {
  return gt("MuiList", e);
}
ht("MuiList", ["root", "padding", "dense", "subheader"]);
const sS = (e) => {
  const {
    classes: t,
    disablePadding: r,
    dense: o,
    subheader: n
  } = e;
  return _t({
    root: ["root", !r && "padding", o && "dense", n && "subheader"]
  }, aS, t);
}, lS = tt("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.disablePadding && t.padding, r.dense && t.dense, r.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), eu = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiList"
  }), {
    children: n,
    className: i,
    component: a = "ul",
    dense: s = !1,
    disablePadding: c = !1,
    subheader: p,
    ...l
  } = o, d = be.useMemo(() => ({
    dense: s
  }), [s]), u = {
    ...o,
    component: a,
    dense: s,
    disablePadding: c
  }, h = sS(u);
  return /* @__PURE__ */ _e.jsx(Ur.Provider, {
    value: d,
    children: /* @__PURE__ */ _e.jsxs(lS, {
      as: a,
      className: ot(h.root, i),
      ref: r,
      ownerState: u,
      ...l,
      children: [p, n]
    })
  });
});
process.env.NODE_ENV !== "production" && (eu.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: m.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: m.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function cS(e) {
  return gt("MuiListItem", e);
}
ht("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const uS = ht("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function fS(e) {
  return gt("MuiListItemSecondaryAction", e);
}
ht("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const dS = (e) => {
  const {
    disableGutters: t,
    classes: r
  } = e;
  return _t({
    root: ["root", t && "disableGutters"]
  }, fS, r);
}, pS = tt("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.disableGutters && t.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState: e
    }) => e.disableGutters,
    style: {
      right: 0
    }
  }]
}), tu = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiListItemSecondaryAction"
  }), {
    className: n,
    ...i
  } = o, a = be.useContext(Ur), s = {
    ...o,
    disableGutters: a.disableGutters
  }, c = dS(s);
  return /* @__PURE__ */ _e.jsx(pS, {
    className: ot(c.root, n),
    ownerState: s,
    ref: r,
    ...i
  });
});
process.env.NODE_ENV !== "production" && (tu.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component, normally an `IconButton` or selection control.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
tu.muiName = "ListItemSecondaryAction";
const hS = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.dense && t.dense, r.alignItems === "flex-start" && t.alignItemsFlexStart, r.divider && t.divider, !r.disableGutters && t.gutters, !r.disablePadding && t.padding, r.hasSecondaryAction && t.secondaryAction];
}, yS = (e) => {
  const {
    alignItems: t,
    classes: r,
    dense: o,
    disableGutters: n,
    disablePadding: i,
    divider: a,
    hasSecondaryAction: s
  } = e;
  return _t({
    root: ["root", o && "dense", !n && "gutters", !i && "padding", a && "divider", t === "flex-start" && "alignItemsFlexStart", s && "secondaryAction"],
    container: ["container"]
  }, cS, r);
}, mS = tt("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: hS
})(Ct(({
  theme: e
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && t.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !!t.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.secondaryAction,
    style: {
      [`& > .${uS.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.button,
    style: {
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
}))), gS = tt("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (e, t) => t.container
})({
  position: "relative"
}), Ua = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiListItem"
  }), {
    alignItems: n = "center",
    children: i,
    className: a,
    component: s,
    components: c = {},
    componentsProps: p = {},
    ContainerComponent: l = "li",
    ContainerProps: {
      className: d,
      ...u
    } = {},
    dense: h = !1,
    disableGutters: y = !1,
    disablePadding: f = !1,
    divider: b = !1,
    secondaryAction: w,
    slotProps: x = {},
    slots: E = {},
    ...T
  } = o, C = be.useContext(Ur), R = be.useMemo(() => ({
    dense: h || C.dense || !1,
    alignItems: n,
    disableGutters: y
  }), [n, C.dense, h, y]), A = be.useRef(null), j = be.Children.toArray(i), N = j.length && Go(j[j.length - 1], ["ListItemSecondaryAction"]), O = {
    ...o,
    alignItems: n,
    dense: R.dense,
    disableGutters: y,
    disablePadding: f,
    divider: b,
    hasSecondaryAction: N
  }, D = yS(O), H = Mt(A, r), G = E.root || c.Root || mS, X = x.root || p.root || {}, Q = {
    className: ot(D.root, X.className, a),
    ...T
  };
  let M = s || "li";
  return N ? (M = !Q.component && !s ? "div" : M, l === "li" && (M === "li" ? M = "div" : Q.component === "li" && (Q.component = "div")), /* @__PURE__ */ _e.jsx(Ur.Provider, {
    value: R,
    children: /* @__PURE__ */ _e.jsxs(gS, {
      as: l,
      className: ot(D.container, d),
      ref: H,
      ownerState: O,
      ...u,
      children: [/* @__PURE__ */ _e.jsx(G, {
        ...X,
        ...!ui(G) && {
          as: M,
          ownerState: {
            ...O,
            ...X.ownerState
          }
        },
        ...Q,
        children: j
      }), j.pop()]
    })
  })) : /* @__PURE__ */ _e.jsx(Ur.Provider, {
    value: R,
    children: /* @__PURE__ */ _e.jsxs(G, {
      ...X,
      as: M,
      ref: H,
      ...!ui(G) && {
        ownerState: {
          ...O,
          ...X.ownerState
        }
      },
      ...Q,
      children: [j, w && /* @__PURE__ */ _e.jsx(tu, {
        children: w
      })]
    })
  });
});
process.env.NODE_ENV !== "production" && (Ua.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Defines the `align-items` style property.
   * @default 'center'
   */
  alignItems: m.oneOf(["center", "flex-start"]),
  /**
   * The content of the component if a `ListItemSecondaryAction` is used it must
   * be the last child.
   */
  children: gn(m.node, (e) => {
    const t = be.Children.toArray(e.children);
    let r = -1;
    for (let o = t.length - 1; o >= 0; o -= 1) {
      const n = t[o];
      if (Go(n, ["ListItemSecondaryAction"])) {
        r = o;
        break;
      }
    }
    return r !== -1 && r !== t.length - 1 ? new Error("MUI: You used an element after ListItemSecondaryAction. For ListItem to detect that it has a secondary action you must pass it as the last child to ListItem.") : null;
  }),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * The components used for each slot inside.
   *
   * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  components: m.shape({
    Root: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  componentsProps: m.shape({
    root: m.object
  }),
  /**
   * The container component used when a `ListItemSecondaryAction` is the last child.
   * @default 'li'
   * @deprecated Use the `component` or `slots.root` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  ContainerComponent: us,
  /**
   * Props applied to the container component if used.
   * @default {}
   * @deprecated Use the `slotProps.root` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  ContainerProps: m.object,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent List component.
   * @default false
   */
  dense: m.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: m.bool,
  /**
   * If `true`, all padding is removed.
   * @default false
   */
  disablePadding: m.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the list item.
   * @default false
   */
  divider: m.bool,
  /**
   * The element to display at the end of ListItem.
   */
  secondaryAction: m.node,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: m.shape({
    root: m.object
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: m.shape({
    root: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function bS(e) {
  return gt("MuiListItemIcon", e);
}
const ld = ht("MuiListItemIcon", ["root", "alignItemsFlexStart"]), vS = (e) => {
  const {
    alignItems: t,
    classes: r
  } = e;
  return _t({
    root: ["root", t === "flex-start" && "alignItemsFlexStart"]
  }, bS, r);
}, _S = tt("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.alignItems === "flex-start" && t.alignItemsFlexStart];
  }
})(Ct(({
  theme: e
}) => ({
  minWidth: 56,
  color: (e.vars || e).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
}))), Jh = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiListItemIcon"
  }), {
    className: n,
    ...i
  } = o, a = be.useContext(Ur), s = {
    ...o,
    alignItems: a.alignItems
  }, c = vS(s);
  return /* @__PURE__ */ _e.jsx(_S, {
    className: ot(c.root, n),
    ownerState: s,
    ref: r,
    ...i
  });
});
process.env.NODE_ENV !== "production" && (Jh.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component, normally `Icon`, `SvgIcon`,
   * or a `@mui/icons-material` SVG icon element.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function wS(e) {
  return gt("MuiListItemText", e);
}
const Xn = ht("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), ES = (e) => {
  const {
    classes: t,
    inset: r,
    primary: o,
    secondary: n,
    dense: i
  } = e;
  return _t({
    root: ["root", r && "inset", i && "dense", o && n && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, wS, t);
}, SS = tt("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [{
      [`& .${Xn.primary}`]: t.primary
    }, {
      [`& .${Xn.secondary}`]: t.secondary
    }, t.root, r.inset && t.inset, r.primary && r.secondary && t.multiline, r.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${zf.root}:where(& .${Xn.primary})`]: {
    display: "block"
  },
  [`.${zf.root}:where(& .${Xn.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), ey = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiListItemText"
  }), {
    children: n,
    className: i,
    disableTypography: a = !1,
    inset: s = !1,
    primary: c,
    primaryTypographyProps: p,
    secondary: l,
    secondaryTypographyProps: d,
    slots: u = {},
    slotProps: h = {},
    ...y
  } = o, {
    dense: f
  } = be.useContext(Ur);
  let b = c ?? n, w = l;
  const x = {
    ...o,
    disableTypography: a,
    inset: s,
    primary: !!b,
    secondary: !!w,
    dense: f
  }, E = ES(x), T = {
    slots: u,
    slotProps: {
      primary: p,
      secondary: d,
      ...h
    }
  }, [C, R] = Zt("primary", {
    className: E.primary,
    elementType: Fr,
    externalForwardedProps: T,
    ownerState: x
  }), [A, j] = Zt("secondary", {
    className: E.secondary,
    elementType: Fr,
    externalForwardedProps: T,
    ownerState: x
  });
  return b != null && b.type !== Fr && !a && (b = /* @__PURE__ */ _e.jsx(C, {
    variant: f ? "body2" : "body1",
    component: R != null && R.variant ? void 0 : "span",
    ...R,
    children: b
  })), w != null && w.type !== Fr && !a && (w = /* @__PURE__ */ _e.jsx(A, {
    variant: "body2",
    color: "textSecondary",
    ...j,
    children: w
  })), /* @__PURE__ */ _e.jsxs(SS, {
    className: ot(E.root, i),
    ownerState: x,
    ref: r,
    ...y,
    children: [b, w]
  });
});
process.env.NODE_ENV !== "production" && (ey.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Alias for the `primary` prop.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * If `true`, the children won't be wrapped by a Typography component.
   * This can be useful to render an alternative Typography variant by wrapping
   * the `children` (or `primary`) text, and optional `secondary` text
   * with the Typography component.
   * @default false
   */
  disableTypography: m.bool,
  /**
   * If `true`, the children are indented.
   * This should be used if there is no left avatar or left icon.
   * @default false
   */
  inset: m.bool,
  /**
   * The main content element.
   */
  primary: m.node,
  /**
   * These props will be forwarded to the primary typography component
   * (as long as disableTypography is not `true`).
   * @deprecated Use `slotProps.primary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  primaryTypographyProps: m.object,
  /**
   * The secondary content element.
   */
  secondary: m.node,
  /**
   * These props will be forwarded to the secondary typography component
   * (as long as disableTypography is not `true`).
   * @deprecated Use `slotProps.secondary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  secondaryTypographyProps: m.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    primary: m.oneOfType([m.func, m.object]),
    secondary: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    primary: m.elementType,
    secondary: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object])
});
function ol(e, t, r) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : r ? null : e.firstChild;
}
function cd(e, t, r) {
  return e === t ? r ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : r ? null : e.lastChild;
}
function ty(e, t) {
  if (t === void 0)
    return !0;
  let r = e.innerText;
  return r === void 0 && (r = e.textContent), r = r.trim().toLowerCase(), r.length === 0 ? !1 : t.repeating ? r[0] === t.keys[0] : r.startsWith(t.keys.join(""));
}
function Mo(e, t, r, o, n, i) {
  let a = !1, s = n(e, t, t ? r : !1);
  for (; s; ) {
    if (s === e.firstChild) {
      if (a)
        return !1;
      a = !0;
    }
    const c = o ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
    if (!s.hasAttribute("tabindex") || !ty(s, i) || c)
      s = n(e, s, r);
    else
      return s.focus(), !0;
  }
  return !1;
}
const ki = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: o,
    autoFocus: n = !1,
    autoFocusItem: i = !1,
    children: a,
    className: s,
    disabledItemsFocusable: c = !1,
    disableListWrap: p = !1,
    onKeyDown: l,
    variant: d = "selectedMenu",
    ...u
  } = t, h = be.useRef(null), y = be.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  Wr(() => {
    n && h.current.focus();
  }, [n]), be.useImperativeHandle(o, () => ({
    adjustStyleForScrollbar: (E, {
      direction: T
    }) => {
      const C = !h.current.style.width;
      if (E.clientHeight < h.current.clientHeight && C) {
        const R = `${hh(ln(E))}px`;
        h.current.style[T === "rtl" ? "paddingLeft" : "paddingRight"] = R, h.current.style.width = `calc(100% + ${R})`;
      }
      return h.current;
    }
  }), []);
  const f = (E) => {
    const T = h.current, C = E.key;
    if (E.ctrlKey || E.metaKey || E.altKey) {
      l && l(E);
      return;
    }
    const A = pr(T).activeElement;
    if (C === "ArrowDown")
      E.preventDefault(), Mo(T, A, p, c, ol);
    else if (C === "ArrowUp")
      E.preventDefault(), Mo(T, A, p, c, cd);
    else if (C === "Home")
      E.preventDefault(), Mo(T, null, p, c, ol);
    else if (C === "End")
      E.preventDefault(), Mo(T, null, p, c, cd);
    else if (C.length === 1) {
      const j = y.current, N = C.toLowerCase(), O = performance.now();
      j.keys.length > 0 && (O - j.lastTime > 500 ? (j.keys = [], j.repeating = !0, j.previousKeyMatched = !0) : j.repeating && N !== j.keys[0] && (j.repeating = !1)), j.lastTime = O, j.keys.push(N);
      const D = A && !j.repeating && ty(A, j);
      j.previousKeyMatched && (D || Mo(T, A, !1, c, ol, j)) ? E.preventDefault() : j.previousKeyMatched = !1;
    }
    l && l(E);
  }, b = Mt(h, r);
  let w = -1;
  be.Children.forEach(a, (E, T) => {
    if (!/* @__PURE__ */ be.isValidElement(E)) {
      w === T && (w += 1, w >= a.length && (w = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && Uc.isFragment(E) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), E.props.disabled || (d === "selectedMenu" && E.props.selected || w === -1) && (w = T), w === T && (E.props.disabled || E.props.muiSkipListHighlight || E.type.muiSkipListHighlight) && (w += 1, w >= a.length && (w = -1));
  });
  const x = be.Children.map(a, (E, T) => {
    if (T === w) {
      const C = {};
      return i && (C.autoFocus = !0), E.props.tabIndex === void 0 && d === "selectedMenu" && (C.tabIndex = 0), /* @__PURE__ */ be.cloneElement(E, C);
    }
    return E;
  });
  return /* @__PURE__ */ _e.jsx(eu, {
    role: "menu",
    ref: b,
    className: s,
    onKeyDown: f,
    tabIndex: n ? 0 : -1,
    ...u,
    children: x
  });
});
process.env.NODE_ENV !== "production" && (ki.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: m.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: m.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: m.node,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: m.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: m.bool,
  /**
   * @ignore
   */
  onKeyDown: m.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: m.oneOf(["menu", "selectedMenu"])
});
function TS(e) {
  return gt("MuiPopover", e);
}
ht("MuiPopover", ["root", "paper"]);
function ud(e, t) {
  let r = 0;
  return typeof t == "number" ? r = t : t === "center" ? r = e.height / 2 : t === "bottom" && (r = e.height), r;
}
function fd(e, t) {
  let r = 0;
  return typeof t == "number" ? r = t : t === "center" ? r = e.width / 2 : t === "right" && (r = e.width), r;
}
function dd(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function ga(e) {
  return typeof e == "function" ? e() : e;
}
const xS = (e) => {
  const {
    classes: t
  } = e;
  return _t({
    root: ["root"],
    paper: ["paper"]
  }, TS, t);
}, RS = tt(Qc, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), ry = tt(Nh, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), ny = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiPopover"
  }), {
    action: n,
    anchorEl: i,
    anchorOrigin: a = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: s,
    anchorReference: c = "anchorEl",
    children: p,
    className: l,
    container: d,
    elevation: u = 8,
    marginThreshold: h = 16,
    open: y,
    PaperProps: f = {},
    slots: b = {},
    slotProps: w = {},
    transformOrigin: x = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: E = pi,
    transitionDuration: T = "auto",
    TransitionProps: {
      onEntering: C,
      ...R
    } = {},
    disableScrollLock: A = !1,
    ...j
  } = o, N = (w == null ? void 0 : w.paper) ?? f, O = be.useRef(), D = {
    ...o,
    anchorOrigin: a,
    anchorReference: c,
    elevation: u,
    marginThreshold: h,
    externalPaperSlotProps: N,
    transformOrigin: x,
    TransitionComponent: E,
    transitionDuration: T,
    TransitionProps: R
  }, H = xS(D), G = be.useCallback(() => {
    if (c === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (s || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), s;
    const ue = ga(i), ge = ue && ue.nodeType === 1 ? ue : pr(O.current).body, he = ge.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const W = ge.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && W.top === 0 && W.left === 0 && W.right === 0 && W.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: he.top + ud(he, a.vertical),
      left: he.left + fd(he, a.horizontal)
    };
  }, [i, a.horizontal, a.vertical, s, c]), X = be.useCallback((ue) => ({
    vertical: ud(ue, x.vertical),
    horizontal: fd(ue, x.horizontal)
  }), [x.horizontal, x.vertical]), Q = be.useCallback((ue) => {
    const ge = {
      width: ue.offsetWidth,
      height: ue.offsetHeight
    }, he = X(ge);
    if (c === "none")
      return {
        top: null,
        left: null,
        transformOrigin: dd(he)
      };
    const W = G();
    let Y = W.top - he.vertical, se = W.left - he.horizontal;
    const Te = Y + ge.height, Oe = se + ge.width, B = ln(ga(i)), U = B.innerHeight - h, _ = B.innerWidth - h;
    if (h !== null && Y < h) {
      const v = Y - h;
      Y -= v, he.vertical += v;
    } else if (h !== null && Te > U) {
      const v = Te - U;
      Y -= v, he.vertical += v;
    }
    if (process.env.NODE_ENV !== "production" && ge.height > U && ge.height && U && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${ge.height - U}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), h !== null && se < h) {
      const v = se - h;
      se -= v, he.horizontal += v;
    } else if (Oe > _) {
      const v = Oe - _;
      se -= v, he.horizontal += v;
    }
    return {
      top: `${Math.round(Y)}px`,
      left: `${Math.round(se)}px`,
      transformOrigin: dd(he)
    };
  }, [i, c, G, X, h]), [M, k] = be.useState(y), $ = be.useCallback(() => {
    const ue = O.current;
    if (!ue)
      return;
    const ge = Q(ue);
    ge.top !== null && ue.style.setProperty("top", ge.top), ge.left !== null && (ue.style.left = ge.left), ue.style.transformOrigin = ge.transformOrigin, k(!0);
  }, [Q]);
  be.useEffect(() => (A && window.addEventListener("scroll", $), () => window.removeEventListener("scroll", $)), [i, A, $]);
  const ne = (ue, ge) => {
    C && C(ue, ge), $();
  }, te = () => {
    k(!1);
  };
  be.useEffect(() => {
    y && $();
  }), be.useImperativeHandle(n, () => y ? {
    updatePosition: () => {
      $();
    }
  } : null, [y, $]), be.useEffect(() => {
    if (!y)
      return;
    const ue = dh(() => {
      $();
    }), ge = ln(i);
    return ge.addEventListener("resize", ue), () => {
      ue.clear(), ge.removeEventListener("resize", ue);
    };
  }, [i, y, $]);
  let de = T;
  T === "auto" && !E.muiSupportAuto && (de = void 0);
  const ae = d || (i ? pr(ga(i)).body : void 0), z = {
    slots: b,
    slotProps: {
      ...w,
      paper: N
    }
  }, [Z, oe] = Zt("paper", {
    elementType: ry,
    externalForwardedProps: z,
    additionalProps: {
      elevation: u,
      className: ot(H.paper, N == null ? void 0 : N.className),
      style: M ? N.style : {
        ...N.style,
        opacity: 0
      }
    },
    ownerState: D
  }), [ye, {
    slotProps: V,
    ...q
  }] = Zt("root", {
    elementType: RS,
    externalForwardedProps: z,
    additionalProps: {
      slotProps: {
        backdrop: {
          invisible: !0
        }
      },
      container: ae,
      open: y
    },
    ownerState: D,
    className: ot(H.root, l)
  }), ee = Mt(O, oe.ref);
  return /* @__PURE__ */ _e.jsx(ye, {
    ...q,
    ...!ui(ye) && {
      slotProps: V,
      disableScrollLock: A
    },
    ...j,
    ref: r,
    children: /* @__PURE__ */ _e.jsx(E, {
      appear: !0,
      in: y,
      onEntering: ne,
      onExited: te,
      timeout: de,
      ...R,
      children: /* @__PURE__ */ _e.jsx(Z, {
        ...oe,
        ref: ee,
        children: p
      })
    })
  });
});
process.env.NODE_ENV !== "production" && (ny.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: Ar,
  /**
   * An HTML element, [PopoverVirtualElement](https://mui.com/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: gn(m.oneOfType([sn, m.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = ga(e.anchorEl);
      if (t && t.nodeType === 1) {
        const r = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: m.shape({
    horizontal: m.oneOfType([m.oneOf(["center", "left", "right"]), m.number]).isRequired,
    vertical: m.oneOfType([m.oneOf(["bottom", "center", "top"]), m.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: m.shape({
    left: m.number.isRequired,
    top: m.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: m.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slotProps.root.slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slotProps.root.slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: m.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.root.slotProps.backdrop` instead.
   */
  BackdropProps: m.object,
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: m.oneOfType([sn, m.func]),
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: m.bool,
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: gh,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * If null, the popover will not be constrained by the window.
   * @default 16
   */
  marginThreshold: m.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: m.func,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * Props applied to the [`Paper`](https://mui.com/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overriden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: m.shape({
    component: us
  }),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    paper: m.oneOfType([m.func, m.object]),
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    paper: m.elementType,
    root: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: m.shape({
    horizontal: m.oneOfType([m.oneOf(["center", "left", "right"]), m.number]).isRequired,
    vertical: m.oneOfType([m.oneOf(["bottom", "center", "top"]), m.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: m.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: m.oneOfType([m.oneOf(["auto"]), m.number, m.shape({
    appear: m.number,
    enter: m.number,
    exit: m.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: m.object
});
function OS(e) {
  return gt("MuiMenu", e);
}
ht("MuiMenu", ["root", "paper", "list"]);
const AS = {
  vertical: "top",
  horizontal: "right"
}, kS = {
  vertical: "top",
  horizontal: "left"
}, CS = (e) => {
  const {
    classes: t
  } = e;
  return _t({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, OS, t);
}, PS = tt(ny, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), IS = tt(ry, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), NS = tt(ki, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), ru = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: n = !0,
    children: i,
    className: a,
    disableAutoFocusItem: s = !1,
    MenuListProps: c = {},
    onClose: p,
    open: l,
    PaperProps: d = {},
    PopoverClasses: u,
    transitionDuration: h = "auto",
    TransitionProps: {
      onEntering: y,
      ...f
    } = {},
    variant: b = "selectedMenu",
    slots: w = {},
    slotProps: x = {},
    ...E
  } = o, T = Dc(), C = {
    ...o,
    autoFocus: n,
    disableAutoFocusItem: s,
    MenuListProps: c,
    onEntering: y,
    PaperProps: d,
    transitionDuration: h,
    TransitionProps: f,
    variant: b
  }, R = CS(C), A = n && !s && l, j = be.useRef(null), N = (M, k) => {
    j.current && j.current.adjustStyleForScrollbar(M, {
      direction: T ? "rtl" : "ltr"
    }), y && y(M, k);
  }, O = (M) => {
    M.key === "Tab" && (M.preventDefault(), p && p(M, "tabKeyDown"));
  };
  let D = -1;
  be.Children.map(i, (M, k) => {
    /* @__PURE__ */ be.isValidElement(M) && (process.env.NODE_ENV !== "production" && Uc.isFragment(M) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), M.props.disabled || (b === "selectedMenu" && M.props.selected || D === -1) && (D = k));
  });
  const H = w.paper ?? IS, G = x.paper ?? d, X = Dl({
    elementType: w.root,
    externalSlotProps: x.root,
    ownerState: C,
    className: [R.root, a]
  }), Q = Dl({
    elementType: H,
    externalSlotProps: G,
    ownerState: C,
    className: R.paper
  });
  return /* @__PURE__ */ _e.jsx(PS, {
    onClose: p,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: T ? "right" : "left"
    },
    transformOrigin: T ? AS : kS,
    slots: {
      paper: H,
      root: w.root
    },
    slotProps: {
      root: X,
      paper: Q
    },
    open: l,
    ref: r,
    transitionDuration: h,
    TransitionProps: {
      onEntering: N,
      ...f
    },
    ownerState: C,
    ...E,
    classes: u,
    children: /* @__PURE__ */ _e.jsx(NS, {
      onKeyDown: O,
      actions: j,
      autoFocus: n && (D === -1 || s),
      autoFocusItem: A,
      variant: b,
      ...c,
      className: ot(R.list, c.className),
      children: i
    })
  });
});
process.env.NODE_ENV !== "production" && (ru.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: m.oneOfType([sn, m.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: m.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: m.bool,
  /**
   * Props applied to the [`MenuList`](https://mui.com/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: m.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: m.func,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: m.object,
  /**
   * `classes` prop applied to the [`Popover`](https://mui.com/material-ui/api/popover/) element.
   */
  PopoverClasses: m.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    paper: m.oneOfType([m.func, m.object]),
    root: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    paper: m.elementType,
    root: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: m.oneOfType([m.oneOf(["auto"]), m.number, m.shape({
    appear: m.number,
    enter: m.number,
    exit: m.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: m.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: m.oneOf(["menu", "selectedMenu"])
});
function LS(e) {
  return gt("MuiMenuItem", e);
}
const Fo = ht("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), jS = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.dense && t.dense, r.divider && t.divider, !r.disableGutters && t.gutters];
}, MS = (e) => {
  const {
    disabled: t,
    dense: r,
    divider: o,
    disableGutters: n,
    selected: i,
    classes: a
  } = e, c = _t({
    root: ["root", r && "dense", t && "disabled", !n && "gutters", o && "divider", i && "selected"]
  }, LS, a);
  return {
    ...a,
    ...c
  };
}, FS = tt(ps, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: jS
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${Fo.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Qt(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${Fo.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Qt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${Fo.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Qt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Qt(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${Fo.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${Fo.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${id.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${id.inset}`]: {
    marginLeft: 52
  },
  [`& .${Xn.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${Xn.inset}`]: {
    paddingLeft: 36
  },
  [`& .${ld.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${ld.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), nu = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: n = !1,
    component: i = "li",
    dense: a = !1,
    divider: s = !1,
    disableGutters: c = !1,
    focusVisibleClassName: p,
    role: l = "menuitem",
    tabIndex: d,
    className: u,
    ...h
  } = o, y = be.useContext(Ur), f = be.useMemo(() => ({
    dense: a || y.dense || !1,
    disableGutters: c
  }), [y.dense, a, c]), b = be.useRef(null);
  Wr(() => {
    n && (b.current ? b.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [n]);
  const w = {
    ...o,
    dense: f.dense,
    divider: s,
    disableGutters: c
  }, x = MS(o), E = Mt(b, r);
  let T;
  return o.disabled || (T = d !== void 0 ? d : -1), /* @__PURE__ */ _e.jsx(Ur.Provider, {
    value: f,
    children: /* @__PURE__ */ _e.jsx(FS, {
      ref: E,
      role: l,
      tabIndex: T,
      component: i,
      focusVisibleClassName: ot(x.focusVisible, p),
      className: ot(x.root, u),
      ...h,
      ownerState: w,
      classes: x
    })
  });
});
process.env.NODE_ENV !== "production" && (nu.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: m.bool,
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: m.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: m.bool,
  /**
   * @ignore
   */
  disabled: m.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: m.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: m.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: m.string,
  /**
   * @ignore
   */
  role: m.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: m.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * @default 0
   */
  tabIndex: m.number
});
function DS(e) {
  return gt("MuiNativeSelect", e);
}
const ou = ht("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), BS = (e) => {
  const {
    classes: t,
    variant: r,
    disabled: o,
    multiple: n,
    open: i,
    error: a
  } = e, s = {
    select: ["select", r, o && "disabled", n && "multiple", a && "error"],
    icon: ["icon", `icon${at(r)}`, i && "iconOpen", o && "disabled"]
  };
  return _t(s, DS, t);
}, oy = tt("select")(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${ou.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), $S = tt(oy, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Tr,
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.select, t[r.variant], r.error && t.error, {
      [`&.${ou.multiple}`]: t.multiple
    }];
  }
})({}), iy = tt("svg")(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${ou.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), US = tt(iy, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.icon, r.variant && t[`icon${at(r.variant)}`], r.open && t.iconOpen];
  }
})({}), ay = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const {
    className: o,
    disabled: n,
    error: i,
    IconComponent: a,
    inputRef: s,
    variant: c = "standard",
    ...p
  } = t, l = {
    ...t,
    disabled: n,
    variant: c,
    error: i
  }, d = BS(l);
  return /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [/* @__PURE__ */ _e.jsx($S, {
      ownerState: l,
      className: ot(d.select, o),
      disabled: n,
      ref: s || r,
      ...p
    }), t.multiple ? null : /* @__PURE__ */ _e.jsx(US, {
      as: a,
      ownerState: l,
      className: d.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (ay.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * The CSS class name of the select element.
   */
  className: m.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: m.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: m.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: m.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: Ar,
  /**
   * @ignore
   */
  multiple: m.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: m.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * The input value.
   */
  value: m.any,
  /**
   * The variant to use.
   */
  variant: m.oneOf(["standard", "outlined", "filled"])
});
var pd;
const zS = tt("fieldset", {
  shouldForwardProp: Tr
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), HS = tt("legend", {
  shouldForwardProp: Tr
})(Ct(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function sy(e) {
  const {
    children: t,
    classes: r,
    className: o,
    label: n,
    notched: i,
    ...a
  } = e, s = n != null && n !== "", c = {
    ...e,
    notched: i,
    withLabel: s
  };
  return /* @__PURE__ */ _e.jsx(zS, {
    "aria-hidden": !0,
    className: o,
    ownerState: c,
    ...a,
    children: /* @__PURE__ */ _e.jsx(HS, {
      ownerState: c,
      children: s ? /* @__PURE__ */ _e.jsx("span", {
        children: n
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        pd || (pd = /* @__PURE__ */ _e.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: "​"
        }))
      )
    })
  });
}
process.env.NODE_ENV !== "production" && (sy.propTypes = {
  /**
   * The content of the component.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The label.
   */
  label: m.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: m.bool.isRequired,
  /**
   * @ignore
   */
  style: m.object
});
const WS = (e) => {
  const {
    classes: t
  } = e, o = _t({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, sE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...o
  };
}, VS = tt(vs, {
  shouldForwardProp: (e) => Tr(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: gs
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${Pr.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Pr.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
      }
    },
    [`&.${Pr.focused} .${Pr.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(yn()).map(([r]) => ({
      props: {
        color: r
      },
      style: {
        [`&.${Pr.focused} .${Pr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[r].main
        }
      }
    })), {
      props: {},
      // to overide the above style
      style: {
        [`&.${Pr.error} .${Pr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${Pr.disabled} .${Pr.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: r
      }) => r.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: r
      }) => r.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: r
      }) => r.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: r,
        size: o
      }) => r.multiline && o === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), ZS = tt(sy, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
})), qS = tt(_s, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: bs
})(Ct(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), yi = /* @__PURE__ */ be.forwardRef(function(t, r) {
  var o;
  const n = wt({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: i = {},
    fullWidth: a = !1,
    inputComponent: s = "input",
    label: c,
    multiline: p = !1,
    notched: l,
    slots: d = {},
    type: u = "text",
    ...h
  } = n, y = WS(n), f = wo(), b = _o({
    props: n,
    muiFormControl: f,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), w = {
    ...n,
    color: b.color || "primary",
    disabled: b.disabled,
    error: b.error,
    focused: b.focused,
    formControl: f,
    fullWidth: a,
    hiddenLabel: b.hiddenLabel,
    multiline: p,
    size: b.size,
    type: u
  }, x = d.root ?? i.Root ?? VS, E = d.input ?? i.Input ?? qS;
  return /* @__PURE__ */ _e.jsx(ws, {
    slots: {
      root: x,
      input: E
    },
    renderSuffix: (T) => /* @__PURE__ */ _e.jsx(ZS, {
      ownerState: w,
      className: y.notchedOutline,
      label: c != null && c !== "" && b.required ? o || (o = /* @__PURE__ */ _e.jsxs(be.Fragment, {
        children: [c, " ", "*"]
      })) : c,
      notched: typeof l < "u" ? l : !!(T.startAdornment || T.filled || T.focused)
    }),
    fullWidth: a,
    inputComponent: s,
    multiline: p,
    ref: r,
    type: u,
    ...h,
    classes: {
      ...y,
      notchedOutline: null
    }
  });
});
process.env.NODE_ENV !== "production" && (yi.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: m.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: m.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary"]), m.string]),
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Input: m.elementType,
    Root: m.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: m.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: m.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: m.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * The id of the `input` element.
   */
  id: m.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: m.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: m.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Ar,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: m.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: m.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * If `true`, a [TextareaAutosize](https://mui.com/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: m.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: m.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: m.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: m.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: m.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: m.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: m.oneOfType([m.number, m.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: m.shape({
    input: m.elementType,
    root: m.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: m.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: m.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: m.any
});
yi && (yi.muiName = "Input");
function YS(e) {
  return gt("MuiSelect", e);
}
const Do = ht("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var hd;
const GS = tt(oy, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${Do.select}`]: t.select
      },
      {
        [`&.${Do.select}`]: t[r.variant]
      },
      {
        [`&.${Do.error}`]: t.error
      },
      {
        [`&.${Do.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${Do.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), KS = tt(iy, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.icon, r.variant && t[`icon${at(r.variant)}`], r.open && t.iconOpen];
  }
})({}), XS = tt("input", {
  shouldForwardProp: (e) => Ah(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function yd(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function QS(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const JS = (e) => {
  const {
    classes: t,
    variant: r,
    disabled: o,
    multiple: n,
    open: i,
    error: a
  } = e, s = {
    select: ["select", r, o && "disabled", n && "multiple", a && "error"],
    icon: ["icon", `icon${at(r)}`, i && "iconOpen", o && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return _t(s, YS, t);
}, ly = /* @__PURE__ */ be.forwardRef(function(t, r) {
  var Je;
  const {
    "aria-describedby": o,
    "aria-label": n,
    autoFocus: i,
    autoWidth: a,
    children: s,
    className: c,
    defaultOpen: p,
    defaultValue: l,
    disabled: d,
    displayEmpty: u,
    error: h = !1,
    IconComponent: y,
    inputRef: f,
    labelId: b,
    MenuProps: w = {},
    multiple: x,
    name: E,
    onBlur: T,
    onChange: C,
    onClose: R,
    onFocus: A,
    onOpen: j,
    open: N,
    readOnly: O,
    renderValue: D,
    SelectDisplayProps: H = {},
    tabIndex: G,
    // catching `type` from Input which makes no sense for SelectInput
    type: X,
    value: Q,
    variant: M = "standard",
    ...k
  } = t, [$, ne] = Ml({
    controlled: Q,
    default: l,
    name: "Select"
  }), [te, de] = Ml({
    controlled: N,
    default: p,
    name: "Select"
  }), ae = be.useRef(null), z = be.useRef(null), [Z, oe] = be.useState(null), {
    current: ye
  } = be.useRef(N != null), [V, q] = be.useState(), ee = Mt(r, f), ue = be.useCallback((Ze) => {
    z.current = Ze, Ze && oe(Ze);
  }, []), ge = Z == null ? void 0 : Z.parentNode;
  be.useImperativeHandle(ee, () => ({
    focus: () => {
      z.current.focus();
    },
    node: ae.current,
    value: $
  }), [$]), be.useEffect(() => {
    p && te && Z && !ye && (q(a ? null : ge.clientWidth), z.current.focus());
  }, [Z, a]), be.useEffect(() => {
    i && z.current.focus();
  }, [i]), be.useEffect(() => {
    if (!b)
      return;
    const Ze = pr(z.current).getElementById(b);
    if (Ze) {
      const F = () => {
        getSelection().isCollapsed && z.current.focus();
      };
      return Ze.addEventListener("click", F), () => {
        Ze.removeEventListener("click", F);
      };
    }
  }, [b]);
  const he = (Ze, F) => {
    Ze ? j && j(F) : R && R(F), ye || (q(a ? null : ge.clientWidth), de(Ze));
  }, W = (Ze) => {
    Ze.button === 0 && (Ze.preventDefault(), z.current.focus(), he(!0, Ze));
  }, Y = (Ze) => {
    he(!1, Ze);
  }, se = be.Children.toArray(s), Te = (Ze) => {
    const F = se.find((we) => we.props.value === Ze.target.value);
    F !== void 0 && (ne(F.props.value), C && C(Ze, F));
  }, Oe = (Ze) => (F) => {
    let we;
    if (F.currentTarget.hasAttribute("tabindex")) {
      if (x) {
        we = Array.isArray($) ? $.slice() : [];
        const xe = $.indexOf(Ze.props.value);
        xe === -1 ? we.push(Ze.props.value) : we.splice(xe, 1);
      } else
        we = Ze.props.value;
      if (Ze.props.onClick && Ze.props.onClick(F), $ !== we && (ne(we), C)) {
        const xe = F.nativeEvent || F, Ce = new xe.constructor(xe.type, xe);
        Object.defineProperty(Ce, "target", {
          writable: !0,
          value: {
            value: we,
            name: E
          }
        }), C(Ce, Ze);
      }
      x || he(!1, F);
    }
  }, B = (Ze) => {
    O || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(Ze.key) && (Ze.preventDefault(), he(!0, Ze));
  }, U = Z !== null && te, _ = (Ze) => {
    !U && T && (Object.defineProperty(Ze, "target", {
      writable: !0,
      value: {
        value: $,
        name: E
      }
    }), T(Ze));
  };
  delete k["aria-invalid"];
  let v, S;
  const P = [];
  let J = !1, ve = !1;
  (Ba({
    value: $
  }) || u) && (D ? v = D($) : J = !0);
  const Re = se.map((Ze) => {
    if (!/* @__PURE__ */ be.isValidElement(Ze))
      return null;
    process.env.NODE_ENV !== "production" && Uc.isFragment(Ze) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let F;
    if (x) {
      if (!Array.isArray($))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : Hr(2));
      F = $.some((we) => yd(we, Ze.props.value)), F && J && P.push(Ze.props.children);
    } else
      F = yd($, Ze.props.value), F && J && (S = Ze.props.children);
    return F && (ve = !0), /* @__PURE__ */ be.cloneElement(Ze, {
      "aria-selected": F ? "true" : "false",
      onClick: Oe(Ze),
      onKeyUp: (we) => {
        we.key === " " && we.preventDefault(), Ze.props.onKeyUp && Ze.props.onKeyUp(we);
      },
      role: "option",
      selected: F,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": Ze.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && be.useEffect(() => {
    if (!ve && !x && $ !== "") {
      const Ze = se.map((F) => F.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${$}\` for the select ${E ? `(name="${E}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${Ze.filter((F) => F != null).map((F) => `\`${F}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [ve, se, x, E, $]), J && (x ? P.length === 0 ? v = null : v = P.reduce((Ze, F, we) => (Ze.push(F), we < P.length - 1 && Ze.push(", "), Ze), []) : v = S);
  let je = V;
  !a && ye && Z && (je = ge.clientWidth);
  let qe;
  typeof G < "u" ? qe = G : qe = d ? null : 0;
  const ze = H.id || (E ? `mui-component-select-${E}` : void 0), We = {
    ...t,
    variant: M,
    value: $,
    open: U,
    error: h
  }, Fe = JS(We), rt = {
    ...w.PaperProps,
    ...(Je = w.slotProps) == null ? void 0 : Je.paper
  }, Ge = Fc();
  return /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [/* @__PURE__ */ _e.jsx(GS, {
      as: "div",
      ref: ue,
      tabIndex: qe,
      role: "combobox",
      "aria-controls": Ge,
      "aria-disabled": d ? "true" : void 0,
      "aria-expanded": U ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": n,
      "aria-labelledby": [b, ze].filter(Boolean).join(" ") || void 0,
      "aria-describedby": o,
      onKeyDown: B,
      onMouseDown: d || O ? null : W,
      onBlur: _,
      onFocus: A,
      ...H,
      ownerState: We,
      className: ot(H.className, Fe.select, c),
      id: ze,
      children: QS(v) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        hd || (hd = /* @__PURE__ */ _e.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: "​"
        }))
      ) : v
    }), /* @__PURE__ */ _e.jsx(XS, {
      "aria-invalid": h,
      value: Array.isArray($) ? $.join(",") : $,
      name: E,
      ref: ae,
      "aria-hidden": !0,
      onChange: Te,
      tabIndex: -1,
      disabled: d,
      className: Fe.nativeInput,
      autoFocus: i,
      ...k,
      ownerState: We
    }), /* @__PURE__ */ _e.jsx(KS, {
      as: y,
      className: Fe.icon,
      ownerState: We
    }), /* @__PURE__ */ _e.jsx(ru, {
      id: `menu-${E || ""}`,
      anchorEl: ge,
      open: U,
      onClose: Y,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...w,
      MenuListProps: {
        "aria-labelledby": b,
        role: "listbox",
        "aria-multiselectable": x ? "true" : void 0,
        disableListWrap: !0,
        id: Ge,
        ...w.MenuListProps
      },
      slotProps: {
        ...w.slotProps,
        paper: {
          ...rt,
          style: {
            minWidth: je,
            ...rt != null ? rt.style : null
          }
        }
      },
      children: Re
    })]
  });
});
process.env.NODE_ENV !== "production" && (ly.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": m.string,
  /**
   * @ignore
   */
  "aria-label": m.string,
  /**
   * @ignore
   */
  autoFocus: m.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: m.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * The CSS class name of the select element.
   */
  className: m.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: m.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: m.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: m.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: m.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: m.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: Ar,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: m.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: m.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: m.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: m.string,
  /**
   * @ignore
   */
  onBlur: m.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: m.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: m.func,
  /**
   * @ignore
   */
  onFocus: m.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: m.func,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool,
  /**
   * @ignore
   */
  readOnly: m.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: m.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: m.object,
  /**
   * @ignore
   */
  tabIndex: m.oneOfType([m.number, m.string]),
  /**
   * @ignore
   */
  type: m.any,
  /**
   * The input value.
   */
  value: m.any,
  /**
   * The variant to use.
   */
  variant: m.oneOf(["standard", "outlined", "filled"])
});
const e2 = (e) => {
  const {
    classes: t
  } = e;
  return t;
}, iu = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => Tr(e) && e !== "variant",
  slot: "Root"
}, t2 = tt(hi, iu)(""), r2 = tt(yi, iu)(""), n2 = tt(di, iu)(""), au = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: n = !1,
    children: i,
    classes: a = {},
    className: s,
    defaultOpen: c = !1,
    displayEmpty: p = !1,
    IconComponent: l = cE,
    id: d,
    input: u,
    inputProps: h,
    label: y,
    labelId: f,
    MenuProps: b,
    multiple: w = !1,
    native: x = !1,
    onClose: E,
    onOpen: T,
    open: C,
    renderValue: R,
    SelectDisplayProps: A,
    variant: j = "outlined",
    ...N
  } = o, O = x ? ay : ly, D = wo(), H = _o({
    props: o,
    muiFormControl: D,
    states: ["variant", "error"]
  }), G = H.variant || j, X = {
    ...o,
    variant: G,
    classes: a
  }, Q = e2(X), {
    root: M,
    ...k
  } = Q, $ = u || {
    standard: /* @__PURE__ */ _e.jsx(t2, {
      ownerState: X
    }),
    outlined: /* @__PURE__ */ _e.jsx(r2, {
      label: y,
      ownerState: X
    }),
    filled: /* @__PURE__ */ _e.jsx(n2, {
      ownerState: X
    })
  }[G], ne = Mt(r, vo($));
  return /* @__PURE__ */ _e.jsx(be.Fragment, {
    children: /* @__PURE__ */ be.cloneElement($, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: O,
      inputProps: {
        children: i,
        error: H.error,
        IconComponent: l,
        variant: G,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: w,
        ...x ? {
          id: d
        } : {
          autoWidth: n,
          defaultOpen: c,
          displayEmpty: p,
          labelId: f,
          MenuProps: b,
          onClose: E,
          onOpen: T,
          open: C,
          renderValue: R,
          SelectDisplayProps: {
            id: d,
            ...A
          }
        },
        ...h,
        classes: h ? tr(k, h.classes) : k,
        ...u ? u.props.inputProps : {}
      },
      ...(w && x || p) && G === "outlined" ? {
        notched: !0
      } : {},
      ref: ne,
      className: ot($.props.className, s, Q.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!u && {
        variant: G
      },
      ...N
    })
  });
});
process.env.NODE_ENV !== "production" && (au.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: m.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * ⚠️The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: m.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   * ⚠️ When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: m.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: m.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: m.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: m.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: m.object,
  /**
   * See [OutlinedInput#label](https://mui.com/material-ui/api/outlined-input/#props)
   */
  label: m.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: m.string,
  /**
   * Props applied to the [`Menu`](https://mui.com/material-ui/api/menu/) element.
   */
  MenuProps: m.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: m.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: m.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<Value>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: m.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: m.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: m.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: m.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: m.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: m.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: m.oneOfType([m.oneOf([""]), m.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: m.oneOf(["filled", "outlined", "standard"])
});
au.muiName = "Select";
function o2(e) {
  return gt("MuiTooltip", e);
}
const jt = ht("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function i2(e) {
  return Math.round(e * 1e5) / 1e5;
}
const a2 = (e) => {
  const {
    classes: t,
    disableInteractive: r,
    arrow: o,
    touch: n,
    placement: i
  } = e, a = {
    popper: ["popper", !r && "popperInteractive", o && "popperArrow"],
    tooltip: ["tooltip", o && "tooltipArrow", n && "touch", `tooltipPlacement${at(i.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return _t(a, o2, t);
}, s2 = tt(Xc, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.popper, !r.disableInteractive && t.popperInteractive, r.arrow && t.popperArrow, !r.open && t.popperClose];
  }
})(Ct(({
  theme: e
}) => ({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open: t
    }) => !t,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${jt.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${jt.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${jt.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${jt.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${jt.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${jt.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${jt.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${jt.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
}))), l2 = tt("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.tooltip, r.touch && t.touch, r.arrow && t.tooltipArrow, t[`tooltipPlacement${at(r.placement.split("-")[0])}`]];
  }
})(Ct(({
  theme: e
}) => ({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : Qt(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium,
  [`.${jt.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${jt.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${jt.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${jt.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      padding: "8px 16px",
      fontSize: e.typography.pxToRem(14),
      lineHeight: `${i2(16 / 14)}em`,
      fontWeight: e.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl,
    style: {
      [`.${jt.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${jt.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl && t.touch,
    style: {
      [`.${jt.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${jt.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl,
    style: {
      [`.${jt.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${jt.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl && t.touch,
    style: {
      [`.${jt.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${jt.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${jt.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${jt.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
}))), c2 = tt("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (e, t) => t.arrow
})(Ct(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : Qt(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let Ki = !1;
const md = new fs();
let Bo = {
  x: 0,
  y: 0
};
function Xi(e, t) {
  return (r, ...o) => {
    t && t(r, ...o), e(r, ...o);
  };
}
const ba = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: n = !1,
    children: i,
    classes: a,
    components: s = {},
    componentsProps: c = {},
    describeChild: p = !1,
    disableFocusListener: l = !1,
    disableHoverListener: d = !1,
    disableInteractive: u = !1,
    disableTouchListener: h = !1,
    enterDelay: y = 100,
    enterNextDelay: f = 0,
    enterTouchDelay: b = 700,
    followCursor: w = !1,
    id: x,
    leaveDelay: E = 0,
    leaveTouchDelay: T = 1500,
    onClose: C,
    onOpen: R,
    open: A,
    placement: j = "bottom",
    PopperComponent: N,
    PopperProps: O = {},
    slotProps: D = {},
    slots: H = {},
    title: G,
    TransitionComponent: X,
    TransitionProps: Q,
    ...M
  } = o, k = /* @__PURE__ */ be.isValidElement(i) ? i : /* @__PURE__ */ _e.jsx("span", {
    children: i
  }), $ = ds(), ne = Dc(), [te, de] = be.useState(), [ae, z] = be.useState(null), Z = be.useRef(!1), oe = u || w, ye = Kn(), V = Kn(), q = Kn(), ee = Kn(), [ue, ge] = Ml({
    controlled: A,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let he = ue;
  if (process.env.NODE_ENV !== "production") {
    const {
      current: le
    } = be.useRef(A !== void 0);
    be.useEffect(() => {
      te && te.disabled && !le && G !== "" && te.tagName.toLowerCase() === "button" && console.error(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
    }, [G, te, le]);
  }
  const W = Fc(x), Y = be.useRef(), se = dn(() => {
    Y.current !== void 0 && (document.body.style.WebkitUserSelect = Y.current, Y.current = void 0), ee.clear();
  });
  be.useEffect(() => se, [se]);
  const Te = (le) => {
    md.clear(), Ki = !0, ge(!0), R && !he && R(le);
  }, Oe = dn(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (le) => {
      md.start(800 + E, () => {
        Ki = !1;
      }), ge(!1), C && he && C(le), ye.start($.transitions.duration.shortest, () => {
        Z.current = !1;
      });
    }
  ), B = (le) => {
    Z.current && le.type !== "touchstart" || (te && te.removeAttribute("title"), V.clear(), q.clear(), y || Ki && f ? V.start(Ki ? f : y, () => {
      Te(le);
    }) : Te(le));
  }, U = (le) => {
    V.clear(), q.start(E, () => {
      Oe(le);
    });
  }, [, _] = be.useState(!1), v = (le) => {
    Na(le.target) || (_(!1), U(le));
  }, S = (le) => {
    te || de(le.currentTarget), Na(le.target) && (_(!0), B(le));
  }, P = (le) => {
    Z.current = !0;
    const L = k.props;
    L.onTouchStart && L.onTouchStart(le);
  }, J = (le) => {
    P(le), q.clear(), ye.clear(), se(), Y.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", ee.start(b, () => {
      document.body.style.WebkitUserSelect = Y.current, B(le);
    });
  }, ve = (le) => {
    k.props.onTouchEnd && k.props.onTouchEnd(le), se(), q.start(T, () => {
      Oe(le);
    });
  };
  be.useEffect(() => {
    if (!he)
      return;
    function le(L) {
      L.key === "Escape" && Oe(L);
    }
    return document.addEventListener("keydown", le), () => {
      document.removeEventListener("keydown", le);
    };
  }, [Oe, he]);
  const Re = Mt(vo(k), de, r);
  !G && G !== 0 && (he = !1);
  const je = be.useRef(), qe = (le) => {
    const L = k.props;
    L.onMouseMove && L.onMouseMove(le), Bo = {
      x: le.clientX,
      y: le.clientY
    }, je.current && je.current.update();
  }, ze = {}, We = typeof G == "string";
  p ? (ze.title = !he && We && !d ? G : null, ze["aria-describedby"] = he ? W : null) : (ze["aria-label"] = We ? G : null, ze["aria-labelledby"] = he && !We ? W : null);
  const Fe = {
    ...ze,
    ...M,
    ...k.props,
    className: ot(M.className, k.props.className),
    onTouchStart: P,
    ref: Re,
    ...w ? {
      onMouseMove: qe
    } : {}
  };
  process.env.NODE_ENV !== "production" && (Fe["data-mui-internal-clone-element"] = !0, be.useEffect(() => {
    te && !te.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
  }, [te]));
  const rt = {};
  h || (Fe.onTouchStart = J, Fe.onTouchEnd = ve), d || (Fe.onMouseOver = Xi(B, Fe.onMouseOver), Fe.onMouseLeave = Xi(U, Fe.onMouseLeave), oe || (rt.onMouseOver = B, rt.onMouseLeave = U)), l || (Fe.onFocus = Xi(S, Fe.onFocus), Fe.onBlur = Xi(v, Fe.onBlur), oe || (rt.onFocus = S, rt.onBlur = v)), process.env.NODE_ENV !== "production" && k.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${k.props.title}\` or the Tooltip component.`].join(`
`));
  const Ge = {
    ...o,
    isRtl: ne,
    arrow: n,
    disableInteractive: oe,
    placement: j,
    PopperComponentProp: N,
    touch: Z.current
  }, Je = typeof D.popper == "function" ? D.popper(Ge) : D.popper, Ze = be.useMemo(() => {
    var L, K;
    let le = [{
      name: "arrow",
      enabled: !!ae,
      options: {
        element: ae,
        padding: 4
      }
    }];
    return (L = O.popperOptions) != null && L.modifiers && (le = le.concat(O.popperOptions.modifiers)), (K = Je == null ? void 0 : Je.popperOptions) != null && K.modifiers && (le = le.concat(Je.popperOptions.modifiers)), {
      ...O.popperOptions,
      ...Je == null ? void 0 : Je.popperOptions,
      modifiers: le
    };
  }, [ae, O.popperOptions, Je == null ? void 0 : Je.popperOptions]), F = a2(Ge), we = typeof D.transition == "function" ? D.transition(Ge) : D.transition, xe = {
    slots: {
      popper: s.Popper,
      transition: s.Transition ?? X,
      tooltip: s.Tooltip,
      arrow: s.Arrow,
      ...H
    },
    slotProps: {
      arrow: D.arrow ?? c.arrow,
      popper: {
        ...O,
        ...Je ?? c.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: D.tooltip ?? c.tooltip,
      transition: {
        ...Q,
        ...we ?? c.transition
      }
    }
  }, [Ce, re] = Zt("popper", {
    elementType: s2,
    externalForwardedProps: xe,
    ownerState: Ge,
    className: ot(F.popper, O == null ? void 0 : O.className)
  }), [me, I] = Zt("transition", {
    elementType: pi,
    externalForwardedProps: xe,
    ownerState: Ge
  }), [Ee, De] = Zt("tooltip", {
    elementType: l2,
    className: F.tooltip,
    externalForwardedProps: xe,
    ownerState: Ge
  }), [g, fe] = Zt("arrow", {
    elementType: c2,
    className: F.arrow,
    externalForwardedProps: xe,
    ownerState: Ge,
    ref: z
  });
  return /* @__PURE__ */ _e.jsxs(be.Fragment, {
    children: [/* @__PURE__ */ be.cloneElement(k, Fe), /* @__PURE__ */ _e.jsx(Ce, {
      as: N ?? Xc,
      placement: j,
      anchorEl: w ? {
        getBoundingClientRect: () => ({
          top: Bo.y,
          left: Bo.x,
          right: Bo.x,
          bottom: Bo.y,
          width: 0,
          height: 0
        })
      } : te,
      popperRef: je,
      open: te ? he : !1,
      id: W,
      transition: !0,
      ...rt,
      ...re,
      popperOptions: Ze,
      children: ({
        TransitionProps: le
      }) => /* @__PURE__ */ _e.jsx(me, {
        timeout: $.transitions.duration.shorter,
        ...le,
        ...I,
        children: /* @__PURE__ */ _e.jsxs(Ee, {
          ...De,
          children: [G, n ? /* @__PURE__ */ _e.jsx(g, {
            ...fe
          }) : null]
        })
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (ba.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * If `true`, adds an arrow to the tooltip.
   * @default false
   */
  arrow: m.bool,
  /**
   * Tooltip reference element.
   */
  children: bo.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The components used for each slot inside.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  components: m.shape({
    Arrow: m.elementType,
    Popper: m.elementType,
    Tooltip: m.elementType,
    Transition: m.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   *
   * @default {}
   */
  componentsProps: m.shape({
    arrow: m.object,
    popper: m.object,
    tooltip: m.object,
    transition: m.object
  }),
  /**
   * Set to `true` if the `title` acts as an accessible description.
   * By default the `title` acts as an accessible label for the child.
   * @default false
   */
  describeChild: m.bool,
  /**
   * Do not respond to focus-visible events.
   * @default false
   */
  disableFocusListener: m.bool,
  /**
   * Do not respond to hover events.
   * @default false
   */
  disableHoverListener: m.bool,
  /**
   * Makes a tooltip not interactive, i.e. it will close when the user
   * hovers over the tooltip before the `leaveDelay` is expired.
   * @default false
   */
  disableInteractive: m.bool,
  /**
   * Do not respond to long press touch events.
   * @default false
   */
  disableTouchListener: m.bool,
  /**
   * The number of milliseconds to wait before showing the tooltip.
   * This prop won't impact the enter touch delay (`enterTouchDelay`).
   * @default 100
   */
  enterDelay: m.number,
  /**
   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
   * @default 0
   */
  enterNextDelay: m.number,
  /**
   * The number of milliseconds a user must touch the element before showing the tooltip.
   * @default 700
   */
  enterTouchDelay: m.number,
  /**
   * If `true`, the tooltip follow the cursor over the wrapped element.
   * @default false
   */
  followCursor: m.bool,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: m.string,
  /**
   * The number of milliseconds to wait before hiding the tooltip.
   * This prop won't impact the leave touch delay (`leaveTouchDelay`).
   * @default 0
   */
  leaveDelay: m.number,
  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   * @default 1500
   */
  leaveTouchDelay: m.number,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onClose: m.func,
  /**
   * Callback fired when the component requests to be open.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onOpen: m.func,
  /**
   * If `true`, the component is shown.
   */
  open: m.bool,
  /**
   * Tooltip placement.
   * @default 'bottom'
   */
  placement: m.oneOf(["bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * The component used for the popper.
   * @deprecated use the `slots.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  PopperComponent: m.elementType,
  /**
   * Props applied to the [`Popper`](https://mui.com/material-ui/api/popper/) element.
   * @deprecated use the `slotProps.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  PopperProps: m.object,
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    arrow: m.oneOfType([m.func, m.object]),
    popper: m.oneOfType([m.func, m.object]),
    tooltip: m.oneOfType([m.func, m.object]),
    transition: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    arrow: m.elementType,
    popper: m.elementType,
    tooltip: m.elementType,
    transition: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
   */
  title: m.node,
  /**
   * The component used for the transition.
   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @deprecated use the `slots.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  TransitionComponent: m.elementType,
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   * @default {}
   */
  TransitionProps: m.object
});
function u2(e) {
  return gt("MuiTextField", e);
}
ht("MuiTextField", ["root"]);
const f2 = {
  standard: hi,
  filled: di,
  outlined: yi
}, d2 = (e) => {
  const {
    classes: t
  } = e;
  return _t({
    root: ["root"]
  }, u2, t);
}, p2 = tt(Ai, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), ei = /* @__PURE__ */ be.forwardRef(function(t, r) {
  const o = wt({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: n,
    autoFocus: i = !1,
    children: a,
    className: s,
    color: c = "primary",
    defaultValue: p,
    disabled: l = !1,
    error: d = !1,
    FormHelperTextProps: u,
    fullWidth: h = !1,
    helperText: y,
    id: f,
    InputLabelProps: b,
    inputProps: w,
    InputProps: x,
    inputRef: E,
    label: T,
    maxRows: C,
    minRows: R,
    multiline: A = !1,
    name: j,
    onBlur: N,
    onChange: O,
    onFocus: D,
    placeholder: H,
    required: G = !1,
    rows: X,
    select: Q = !1,
    SelectProps: M,
    slots: k = {},
    slotProps: $ = {},
    type: ne,
    value: te,
    variant: de = "outlined",
    ...ae
  } = o, z = {
    ...o,
    autoFocus: i,
    color: c,
    disabled: l,
    error: d,
    fullWidth: h,
    multiline: A,
    required: G,
    select: Q,
    variant: de
  }, Z = d2(z);
  process.env.NODE_ENV !== "production" && Q && !a && console.error("MUI: `children` must be passed when using the `TextField` component with `select`.");
  const oe = Fc(f), ye = y && oe ? `${oe}-helper-text` : void 0, V = T && oe ? `${oe}-label` : void 0, q = f2[de], ee = {
    slots: k,
    slotProps: {
      input: x,
      inputLabel: b,
      htmlInput: w,
      formHelperText: u,
      select: M,
      ...$
    }
  }, ue = {}, ge = ee.slotProps.inputLabel;
  de === "outlined" && (ge && typeof ge.shrink < "u" && (ue.notched = ge.shrink), ue.label = T), Q && ((!M || !M.native) && (ue.id = void 0), ue["aria-describedby"] = void 0);
  const [he, W] = Zt("input", {
    elementType: q,
    externalForwardedProps: ee,
    additionalProps: ue,
    ownerState: z
  }), [Y, se] = Zt("inputLabel", {
    elementType: Qh,
    externalForwardedProps: ee,
    ownerState: z
  }), [Te, Oe] = Zt("htmlInput", {
    elementType: "input",
    externalForwardedProps: ee,
    ownerState: z
  }), [B, U] = Zt("formHelperText", {
    elementType: Jc,
    externalForwardedProps: ee,
    ownerState: z
  }), [_, v] = Zt("select", {
    elementType: au,
    externalForwardedProps: ee,
    ownerState: z
  }), S = /* @__PURE__ */ _e.jsx(he, {
    "aria-describedby": ye,
    autoComplete: n,
    autoFocus: i,
    defaultValue: p,
    fullWidth: h,
    multiline: A,
    name: j,
    rows: X,
    maxRows: C,
    minRows: R,
    type: ne,
    value: te,
    id: oe,
    inputRef: E,
    onBlur: N,
    onChange: O,
    onFocus: D,
    placeholder: H,
    inputProps: Oe,
    slots: {
      input: k.htmlInput ? Te : void 0
    },
    ...W
  });
  return /* @__PURE__ */ _e.jsxs(p2, {
    className: ot(Z.root, s),
    disabled: l,
    error: d,
    fullWidth: h,
    ref: r,
    required: G,
    color: c,
    variant: de,
    ownerState: z,
    ...ae,
    children: [T != null && T !== "" && /* @__PURE__ */ _e.jsx(Y, {
      htmlFor: oe,
      id: V,
      ...se,
      children: T
    }), Q ? /* @__PURE__ */ _e.jsx(_, {
      "aria-describedby": ye,
      id: oe,
      labelId: V,
      value: te,
      input: S,
      ...v,
      children: a
    }) : S, y && /* @__PURE__ */ _e.jsx(B, {
      id: ye,
      ...U,
      children: y
    })]
  });
});
process.env.NODE_ENV !== "production" && (ei.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: m.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: m.bool,
  /**
   * @ignore
   */
  children: m.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: m.object,
  /**
   * @ignore
   */
  className: m.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: m.oneOfType([m.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), m.string]),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: m.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: m.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: m.bool,
  /**
   * Props applied to the [`FormHelperText`](https://mui.com/material-ui/api/form-helper-text/) element.
   * @deprecated Use `slotProps.formHelperText` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  FormHelperTextProps: m.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: m.bool,
  /**
   * The helper text content.
   */
  helperText: m.node,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: m.string,
  /**
   * Props applied to the [`InputLabel`](https://mui.com/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   * @deprecated Use `slotProps.inputLabel` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  InputLabelProps: m.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @deprecated Use `slotProps.htmlInput` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  inputProps: m.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](https://mui.com/material-ui/api/filled-input/),
   * [`OutlinedInput`](https://mui.com/material-ui/api/outlined-input/) or [`Input`](https://mui.com/material-ui/api/input/)
   * component depending on the `variant` prop value.
   * @deprecated Use `slotProps.input` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  InputProps: m.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: Ar,
  /**
   * The label content.
   */
  label: m.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: m.oneOf(["dense", "none", "normal"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: m.oneOfType([m.number, m.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: m.oneOfType([m.number, m.string]),
  /**
   * If `true`, a `textarea` element is rendered instead of an input.
   * @default false
   */
  multiline: m.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: m.string,
  /**
   * @ignore
   */
  onBlur: m.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: m.func,
  /**
   * @ignore
   */
  onFocus: m.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: m.string,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: m.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: m.oneOfType([m.number, m.string]),
  /**
   * Render a [`Select`](https://mui.com/material-ui/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   * @default false
   */
  select: m.bool,
  /**
   * Props applied to the [`Select`](https://mui.com/material-ui/api/select/) element.
   * @deprecated Use `slotProps.select` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  SelectProps: m.object,
  /**
   * The size of the component.
   */
  size: m.oneOfType([m.oneOf(["medium", "small"]), m.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: m.shape({
    formHelperText: m.oneOfType([m.func, m.object]),
    htmlInput: m.oneOfType([m.func, m.object]),
    input: m.oneOfType([m.func, m.object]),
    inputLabel: m.oneOfType([m.func, m.object]),
    select: m.oneOfType([m.func, m.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: m.shape({
    formHelperText: m.elementType,
    htmlInput: m.elementType,
    input: m.elementType,
    inputLabel: m.elementType,
    select: m.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: m.oneOfType([m.arrayOf(m.oneOfType([m.func, m.object, m.bool])), m.func, m.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: m.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: m.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: m.oneOf(["filled", "outlined", "standard"])
});
const { min: h2, max: y2 } = Math, Cn = (e, t = 0, r = 1) => h2(y2(t, e), r), su = (e) => {
  e._clipped = !1, e._unclipped = e.slice(0);
  for (let t = 0; t <= 3; t++)
    t < 3 ? ((e[t] < 0 || e[t] > 255) && (e._clipped = !0), e[t] = Cn(e[t], 0, 255)) : t === 3 && (e[t] = Cn(e[t], 0, 1));
  return e;
}, cy = {};
for (let e of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
])
  cy[`[object ${e}]`] = e.toLowerCase();
function ut(e) {
  return cy[Object.prototype.toString.call(e)] || "object";
}
const lt = (e, t = null) => e.length >= 3 ? Array.prototype.slice.call(e) : ut(e[0]) == "object" && t ? t.split("").filter((r) => e[0][r] !== void 0).map((r) => e[0][r]) : e[0].slice(0), Eo = (e) => {
  if (e.length < 2) return null;
  const t = e.length - 1;
  return ut(e[t]) == "string" ? e[t].toLowerCase() : null;
}, { PI: Ss, min: uy, max: fy } = Math, br = (e) => Math.round(e * 100) / 100, ql = (e) => Math.round(e * 100) / 100, tn = Ss * 2, il = Ss / 3, m2 = Ss / 180, g2 = 180 / Ss;
function dy(e) {
  return [...e.slice(0, 3).reverse(), ...e.slice(3)];
}
const it = {
  format: {},
  autodetect: []
};
class Ue {
  constructor(...t) {
    const r = this;
    if (ut(t[0]) === "object" && t[0].constructor && t[0].constructor === this.constructor)
      return t[0];
    let o = Eo(t), n = !1;
    if (!o) {
      n = !0, it.sorted || (it.autodetect = it.autodetect.sort((i, a) => a.p - i.p), it.sorted = !0);
      for (let i of it.autodetect)
        if (o = i.test(...t), o) break;
    }
    if (it.format[o]) {
      const i = it.format[o].apply(
        null,
        n ? t : t.slice(0, -1)
      );
      r._rgb = su(i);
    } else
      throw new Error("unknown format: " + t);
    r._rgb.length === 3 && r._rgb.push(1);
  }
  toString() {
    return ut(this.hex) == "function" ? this.hex() : `[${this._rgb.join(",")}]`;
  }
}
const b2 = "3.1.2", dt = (...e) => new Ue(...e);
dt.version = b2;
const fo = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
}, v2 = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, _2 = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, py = (e) => {
  if (e.match(v2)) {
    (e.length === 4 || e.length === 7) && (e = e.substr(1)), e.length === 3 && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]);
    const t = parseInt(e, 16), r = t >> 16, o = t >> 8 & 255, n = t & 255;
    return [r, o, n, 1];
  }
  if (e.match(_2)) {
    (e.length === 5 || e.length === 9) && (e = e.substr(1)), e.length === 4 && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]);
    const t = parseInt(e, 16), r = t >> 24 & 255, o = t >> 16 & 255, n = t >> 8 & 255, i = Math.round((t & 255) / 255 * 100) / 100;
    return [r, o, n, i];
  }
  throw new Error(`unknown hex color: ${e}`);
}, { round: Qi } = Math, hy = (...e) => {
  let [t, r, o, n] = lt(e, "rgba"), i = Eo(e) || "auto";
  n === void 0 && (n = 1), i === "auto" && (i = n < 1 ? "rgba" : "rgb"), t = Qi(t), r = Qi(r), o = Qi(o);
  let s = "000000" + (t << 16 | r << 8 | o).toString(16);
  s = s.substr(s.length - 6);
  let c = "0" + Qi(n * 255).toString(16);
  switch (c = c.substr(c.length - 2), i.toLowerCase()) {
    case "rgba":
      return `#${s}${c}`;
    case "argb":
      return `#${c}${s}`;
    default:
      return `#${s}`;
  }
};
Ue.prototype.name = function() {
  const e = hy(this._rgb, "rgb");
  for (let t of Object.keys(fo))
    if (fo[t] === e) return t.toLowerCase();
  return e;
};
it.format.named = (e) => {
  if (e = e.toLowerCase(), fo[e]) return py(fo[e]);
  throw new Error("unknown color name: " + e);
};
it.autodetect.push({
  p: 5,
  test: (e, ...t) => {
    if (!t.length && ut(e) === "string" && fo[e.toLowerCase()])
      return "named";
  }
});
Ue.prototype.alpha = function(e, t = !1) {
  return e !== void 0 && ut(e) === "number" ? t ? (this._rgb[3] = e, this) : new Ue([this._rgb[0], this._rgb[1], this._rgb[2], e], "rgb") : this._rgb[3];
};
Ue.prototype.clipped = function() {
  return this._rgb._clipped || !1;
};
const zr = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  labWhitePoint: "d65",
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  // 4 / 29
  t1: 0.206896552,
  // 6 / 29
  t2: 0.12841855,
  // 3 * t1 * t1
  t3: 8856452e-9,
  // t1 * t1 * t1,
  kE: 216 / 24389,
  kKE: 8,
  kK: 24389 / 27,
  RefWhiteRGB: {
    // sRGB
    X: 0.95047,
    Y: 1,
    Z: 1.08883
  },
  MtxRGB2XYZ: {
    m00: 0.4124564390896922,
    m01: 0.21267285140562253,
    m02: 0.0193338955823293,
    m10: 0.357576077643909,
    m11: 0.715152155287818,
    m12: 0.11919202588130297,
    m20: 0.18043748326639894,
    m21: 0.07217499330655958,
    m22: 0.9503040785363679
  },
  MtxXYZ2RGB: {
    m00: 3.2404541621141045,
    m01: -0.9692660305051868,
    m02: 0.055643430959114726,
    m10: -1.5371385127977166,
    m11: 1.8760108454466942,
    m12: -0.2040259135167538,
    m20: -0.498531409556016,
    m21: 0.041556017530349834,
    m22: 1.0572251882231791
  },
  // used in rgb2xyz
  As: 0.9414285350000001,
  Bs: 1.040417467,
  Cs: 1.089532651,
  MtxAdaptMa: {
    m00: 0.8951,
    m01: -0.7502,
    m02: 0.0389,
    m10: 0.2664,
    m11: 1.7135,
    m12: -0.0685,
    m20: -0.1614,
    m21: 0.0367,
    m22: 1.0296
  },
  MtxAdaptMaI: {
    m00: 0.9869929054667123,
    m01: 0.43230526972339456,
    m02: -0.008528664575177328,
    m10: -0.14705425642099013,
    m11: 0.5183602715367776,
    m12: 0.04004282165408487,
    m20: 0.15996265166373125,
    m21: 0.0492912282128556,
    m22: 0.9684866957875502
  }
}, w2 = /* @__PURE__ */ new Map([
  // ASTM E308-01
  ["a", [1.0985, 0.35585]],
  // Wyszecki & Stiles, p. 769
  ["b", [1.0985, 0.35585]],
  // C ASTM E308-01
  ["c", [0.98074, 1.18232]],
  // D50 (ASTM E308-01)
  ["d50", [0.96422, 0.82521]],
  // D55 (ASTM E308-01)
  ["d55", [0.95682, 0.92149]],
  // D65 (ASTM E308-01)
  ["d65", [0.95047, 1.08883]],
  // E (ASTM E308-01)
  ["e", [1, 1, 1]],
  // F2 (ASTM E308-01)
  ["f2", [0.99186, 0.67393]],
  // F7 (ASTM E308-01)
  ["f7", [0.95041, 1.08747]],
  // F11 (ASTM E308-01)
  ["f11", [1.00962, 0.6435]],
  ["icc", [0.96422, 0.82521]]
]);
function rn(e) {
  const t = w2.get(String(e).toLowerCase());
  if (!t)
    throw new Error("unknown Lab illuminant " + e);
  zr.labWhitePoint = e, zr.Xn = t[0], zr.Zn = t[1];
}
function mi() {
  return zr.labWhitePoint;
}
const lu = (...e) => {
  e = lt(e, "lab");
  const [t, r, o] = e, [n, i, a] = E2(t, r, o), [s, c, p] = yy(n, i, a);
  return [s, c, p, e.length > 3 ? e[3] : 1];
}, E2 = (e, t, r) => {
  const { kE: o, kK: n, kKE: i, Xn: a, Yn: s, Zn: c } = zr, p = (e + 16) / 116, l = 2e-3 * t + p, d = p - 5e-3 * r, u = l * l * l, h = d * d * d, y = u > o ? u : (116 * l - 16) / n, f = e > i ? Math.pow((e + 16) / 116, 3) : e / n, b = h > o ? h : (116 * d - 16) / n, w = y * a, x = f * s, E = b * c;
  return [w, x, E];
}, al = (e) => {
  const t = Math.sign(e);
  return e = Math.abs(e), (e <= 31308e-7 ? e * 12.92 : 1.055 * Math.pow(e, 1 / 2.4) - 0.055) * t;
}, yy = (e, t, r) => {
  const { MtxAdaptMa: o, MtxAdaptMaI: n, MtxXYZ2RGB: i, RefWhiteRGB: a, Xn: s, Yn: c, Zn: p } = zr, l = s * o.m00 + c * o.m10 + p * o.m20, d = s * o.m01 + c * o.m11 + p * o.m21, u = s * o.m02 + c * o.m12 + p * o.m22, h = a.X * o.m00 + a.Y * o.m10 + a.Z * o.m20, y = a.X * o.m01 + a.Y * o.m11 + a.Z * o.m21, f = a.X * o.m02 + a.Y * o.m12 + a.Z * o.m22, b = (e * o.m00 + t * o.m10 + r * o.m20) * (h / l), w = (e * o.m01 + t * o.m11 + r * o.m21) * (y / d), x = (e * o.m02 + t * o.m12 + r * o.m22) * (f / u), E = b * n.m00 + w * n.m10 + x * n.m20, T = b * n.m01 + w * n.m11 + x * n.m21, C = b * n.m02 + w * n.m12 + x * n.m22, R = al(
    E * i.m00 + T * i.m10 + C * i.m20
  ), A = al(
    E * i.m01 + T * i.m11 + C * i.m21
  ), j = al(
    E * i.m02 + T * i.m12 + C * i.m22
  );
  return [R * 255, A * 255, j * 255];
}, cu = (...e) => {
  const [t, r, o, ...n] = lt(e, "rgb"), [i, a, s] = my(t, r, o), [c, p, l] = S2(i, a, s);
  return [c, p, l, ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
};
function S2(e, t, r) {
  const { Xn: o, Yn: n, Zn: i, kE: a, kK: s } = zr, c = e / o, p = t / n, l = r / i, d = c > a ? Math.pow(c, 1 / 3) : (s * c + 16) / 116, u = p > a ? Math.pow(p, 1 / 3) : (s * p + 16) / 116, h = l > a ? Math.pow(l, 1 / 3) : (s * l + 16) / 116;
  return [116 * u - 16, 500 * (d - u), 200 * (u - h)];
}
function sl(e) {
  const t = Math.sign(e);
  return e = Math.abs(e), (e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4)) * t;
}
const my = (e, t, r) => {
  e = sl(e / 255), t = sl(t / 255), r = sl(r / 255);
  const { MtxRGB2XYZ: o, MtxAdaptMa: n, MtxAdaptMaI: i, Xn: a, Yn: s, Zn: c, As: p, Bs: l, Cs: d } = zr;
  let u = e * o.m00 + t * o.m10 + r * o.m20, h = e * o.m01 + t * o.m11 + r * o.m21, y = e * o.m02 + t * o.m12 + r * o.m22;
  const f = a * n.m00 + s * n.m10 + c * n.m20, b = a * n.m01 + s * n.m11 + c * n.m21, w = a * n.m02 + s * n.m12 + c * n.m22;
  let x = u * n.m00 + h * n.m10 + y * n.m20, E = u * n.m01 + h * n.m11 + y * n.m21, T = u * n.m02 + h * n.m12 + y * n.m22;
  return x *= f / p, E *= b / l, T *= w / d, u = x * i.m00 + E * i.m10 + T * i.m20, h = x * i.m01 + E * i.m11 + T * i.m21, y = x * i.m02 + E * i.m12 + T * i.m22, [u, h, y];
};
Ue.prototype.lab = function() {
  return cu(this._rgb);
};
const T2 = (...e) => new Ue(...e, "lab");
Object.assign(dt, { lab: T2, getLabWhitePoint: mi, setLabWhitePoint: rn });
it.format.lab = lu;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "lab"), ut(e) === "array" && e.length === 3)
      return "lab";
  }
});
Ue.prototype.darken = function(e = 1) {
  const t = this, r = t.lab();
  return r[0] -= zr.Kn * e, new Ue(r, "lab").alpha(t.alpha(), !0);
};
Ue.prototype.brighten = function(e = 1) {
  return this.darken(-e);
};
Ue.prototype.darker = Ue.prototype.darken;
Ue.prototype.brighter = Ue.prototype.brighten;
Ue.prototype.get = function(e) {
  const [t, r] = e.split("."), o = this[t]();
  if (r) {
    const n = t.indexOf(r) - (t.substr(0, 2) === "ok" ? 2 : 0);
    if (n > -1) return o[n];
    throw new Error(`unknown channel ${r} in mode ${t}`);
  } else
    return o;
};
const { pow: x2 } = Math, R2 = 1e-7, O2 = 20;
Ue.prototype.luminance = function(e, t = "rgb") {
  if (e !== void 0 && ut(e) === "number") {
    if (e === 0)
      return new Ue([0, 0, 0, this._rgb[3]], "rgb");
    if (e === 1)
      return new Ue([255, 255, 255, this._rgb[3]], "rgb");
    let r = this.luminance(), o = O2;
    const n = (a, s) => {
      const c = a.interpolate(s, 0.5, t), p = c.luminance();
      return Math.abs(e - p) < R2 || !o-- ? c : p > e ? n(a, c) : n(c, s);
    }, i = (r > e ? n(new Ue([0, 0, 0]), this) : n(this, new Ue([255, 255, 255]))).rgb();
    return new Ue([...i, this._rgb[3]]);
  }
  return A2(...this._rgb.slice(0, 3));
};
const A2 = (e, t, r) => (e = ll(e), t = ll(t), r = ll(r), 0.2126 * e + 0.7152 * t + 0.0722 * r), ll = (e) => (e /= 255, e <= 0.03928 ? e / 12.92 : x2((e + 0.055) / 1.055, 2.4)), er = {}, po = (e, t, r = 0.5, ...o) => {
  let n = o[0] || "lrgb";
  if (!er[n] && !o.length && (n = Object.keys(er)[0]), !er[n])
    throw new Error(`interpolation mode ${n} is not defined`);
  return ut(e) !== "object" && (e = new Ue(e)), ut(t) !== "object" && (t = new Ue(t)), er[n](e, t, r).alpha(
    e.alpha() + r * (t.alpha() - e.alpha())
  );
};
Ue.prototype.mix = Ue.prototype.interpolate = function(e, t = 0.5, ...r) {
  return po(this, e, t, ...r);
};
Ue.prototype.premultiply = function(e = !1) {
  const t = this._rgb, r = t[3];
  return e ? (this._rgb = [t[0] * r, t[1] * r, t[2] * r, r], this) : new Ue([t[0] * r, t[1] * r, t[2] * r, r], "rgb");
};
const { sin: k2, cos: C2 } = Math, gy = (...e) => {
  let [t, r, o] = lt(e, "lch");
  return isNaN(o) && (o = 0), o = o * m2, [t, C2(o) * r, k2(o) * r];
}, uu = (...e) => {
  e = lt(e, "lch");
  const [t, r, o] = e, [n, i, a] = gy(t, r, o), [s, c, p] = lu(n, i, a);
  return [s, c, p, e.length > 3 ? e[3] : 1];
}, P2 = (...e) => {
  const t = dy(lt(e, "hcl"));
  return uu(...t);
}, { sqrt: I2, atan2: N2, round: L2 } = Math, by = (...e) => {
  const [t, r, o] = lt(e, "lab"), n = I2(r * r + o * o);
  let i = (N2(o, r) * g2 + 360) % 360;
  return L2(n * 1e4) === 0 && (i = Number.NaN), [t, n, i];
}, fu = (...e) => {
  const [t, r, o, ...n] = lt(e, "rgb"), [i, a, s] = cu(t, r, o), [c, p, l] = by(i, a, s);
  return [c, p, l, ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
};
Ue.prototype.lch = function() {
  return fu(this._rgb);
};
Ue.prototype.hcl = function() {
  return dy(fu(this._rgb));
};
const j2 = (...e) => new Ue(...e, "lch"), M2 = (...e) => new Ue(...e, "hcl");
Object.assign(dt, { lch: j2, hcl: M2 });
it.format.lch = uu;
it.format.hcl = P2;
["lch", "hcl"].forEach(
  (e) => it.autodetect.push({
    p: 2,
    test: (...t) => {
      if (t = lt(t, e), ut(t) === "array" && t.length === 3)
        return e;
    }
  })
);
Ue.prototype.saturate = function(e = 1) {
  const t = this, r = t.lch();
  return r[1] += zr.Kn * e, r[1] < 0 && (r[1] = 0), new Ue(r, "lch").alpha(t.alpha(), !0);
};
Ue.prototype.desaturate = function(e = 1) {
  return this.saturate(-e);
};
Ue.prototype.set = function(e, t, r = !1) {
  const [o, n] = e.split("."), i = this[o]();
  if (n) {
    const a = o.indexOf(n) - (o.substr(0, 2) === "ok" ? 2 : 0);
    if (a > -1) {
      if (ut(t) == "string")
        switch (t.charAt(0)) {
          case "+":
            i[a] += +t;
            break;
          case "-":
            i[a] += +t;
            break;
          case "*":
            i[a] *= +t.substr(1);
            break;
          case "/":
            i[a] /= +t.substr(1);
            break;
          default:
            i[a] = +t;
        }
      else if (ut(t) === "number")
        i[a] = t;
      else
        throw new Error("unsupported value for Color.set");
      const s = new Ue(i, o);
      return r ? (this._rgb = s._rgb, this) : s;
    }
    throw new Error(`unknown channel ${n} in mode ${o}`);
  } else
    return i;
};
Ue.prototype.tint = function(e = 0.5, ...t) {
  return po(this, "white", e, ...t);
};
Ue.prototype.shade = function(e = 0.5, ...t) {
  return po(this, "black", e, ...t);
};
const F2 = (e, t, r) => {
  const o = e._rgb, n = t._rgb;
  return new Ue(
    o[0] + r * (n[0] - o[0]),
    o[1] + r * (n[1] - o[1]),
    o[2] + r * (n[2] - o[2]),
    "rgb"
  );
};
er.rgb = F2;
const { sqrt: cl, pow: Wn } = Math, D2 = (e, t, r) => {
  const [o, n, i] = e._rgb, [a, s, c] = t._rgb;
  return new Ue(
    cl(Wn(o, 2) * (1 - r) + Wn(a, 2) * r),
    cl(Wn(n, 2) * (1 - r) + Wn(s, 2) * r),
    cl(Wn(i, 2) * (1 - r) + Wn(c, 2) * r),
    "rgb"
  );
};
er.lrgb = D2;
const B2 = (e, t, r) => {
  const o = e.lab(), n = t.lab();
  return new Ue(
    o[0] + r * (n[0] - o[0]),
    o[1] + r * (n[1] - o[1]),
    o[2] + r * (n[2] - o[2]),
    "lab"
  );
};
er.lab = B2;
const So = (e, t, r, o) => {
  let n, i;
  o === "hsl" ? (n = e.hsl(), i = t.hsl()) : o === "hsv" ? (n = e.hsv(), i = t.hsv()) : o === "hcg" ? (n = e.hcg(), i = t.hcg()) : o === "hsi" ? (n = e.hsi(), i = t.hsi()) : o === "lch" || o === "hcl" ? (o = "hcl", n = e.hcl(), i = t.hcl()) : o === "oklch" && (n = e.oklch().reverse(), i = t.oklch().reverse());
  let a, s, c, p, l, d;
  (o.substr(0, 1) === "h" || o === "oklch") && ([a, c, l] = n, [s, p, d] = i);
  let u, h, y, f;
  return !isNaN(a) && !isNaN(s) ? (s > a && s - a > 180 ? f = s - (a + 360) : s < a && a - s > 180 ? f = s + 360 - a : f = s - a, h = a + r * f) : isNaN(a) ? isNaN(s) ? h = Number.NaN : (h = s, (l == 1 || l == 0) && o != "hsv" && (u = p)) : (h = a, (d == 1 || d == 0) && o != "hsv" && (u = c)), u === void 0 && (u = c + r * (p - c)), y = l + r * (d - l), o === "oklch" ? new Ue([y, u, h], o) : new Ue([h, u, y], o);
}, vy = (e, t, r) => So(e, t, r, "lch");
er.lch = vy;
er.hcl = vy;
const $2 = (e) => {
  if (ut(e) == "number" && e >= 0 && e <= 16777215) {
    const t = e >> 16, r = e >> 8 & 255, o = e & 255;
    return [t, r, o, 1];
  }
  throw new Error("unknown num color: " + e);
}, U2 = (...e) => {
  const [t, r, o] = lt(e, "rgb");
  return (t << 16) + (r << 8) + o;
};
Ue.prototype.num = function() {
  return U2(this._rgb);
};
const z2 = (...e) => new Ue(...e, "num");
Object.assign(dt, { num: z2 });
it.format.num = $2;
it.autodetect.push({
  p: 5,
  test: (...e) => {
    if (e.length === 1 && ut(e[0]) === "number" && e[0] >= 0 && e[0] <= 16777215)
      return "num";
  }
});
const H2 = (e, t, r) => {
  const o = e.num(), n = t.num();
  return new Ue(o + r * (n - o), "num");
};
er.num = H2;
const { floor: W2 } = Math, V2 = (...e) => {
  e = lt(e, "hcg");
  let [t, r, o] = e, n, i, a;
  o = o * 255;
  const s = r * 255;
  if (r === 0)
    n = i = a = o;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const c = W2(t), p = t - c, l = o * (1 - r), d = l + s * (1 - p), u = l + s * p, h = l + s;
    switch (c) {
      case 0:
        [n, i, a] = [h, u, l];
        break;
      case 1:
        [n, i, a] = [d, h, l];
        break;
      case 2:
        [n, i, a] = [l, h, u];
        break;
      case 3:
        [n, i, a] = [l, d, h];
        break;
      case 4:
        [n, i, a] = [u, l, h];
        break;
      case 5:
        [n, i, a] = [h, l, d];
        break;
    }
  }
  return [n, i, a, e.length > 3 ? e[3] : 1];
}, Z2 = (...e) => {
  const [t, r, o] = lt(e, "rgb"), n = uy(t, r, o), i = fy(t, r, o), a = i - n, s = a * 100 / 255, c = n / (255 - a) * 100;
  let p;
  return a === 0 ? p = Number.NaN : (t === i && (p = (r - o) / a), r === i && (p = 2 + (o - t) / a), o === i && (p = 4 + (t - r) / a), p *= 60, p < 0 && (p += 360)), [p, s, c];
};
Ue.prototype.hcg = function() {
  return Z2(this._rgb);
};
const q2 = (...e) => new Ue(...e, "hcg");
dt.hcg = q2;
it.format.hcg = V2;
it.autodetect.push({
  p: 1,
  test: (...e) => {
    if (e = lt(e, "hcg"), ut(e) === "array" && e.length === 3)
      return "hcg";
  }
});
const Y2 = (e, t, r) => So(e, t, r, "hcg");
er.hcg = Y2;
const { cos: Vn } = Math, G2 = (...e) => {
  e = lt(e, "hsi");
  let [t, r, o] = e, n, i, a;
  return isNaN(t) && (t = 0), isNaN(r) && (r = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 360, t < 1 / 3 ? (a = (1 - r) / 3, n = (1 + r * Vn(tn * t) / Vn(il - tn * t)) / 3, i = 1 - (a + n)) : t < 2 / 3 ? (t -= 1 / 3, n = (1 - r) / 3, i = (1 + r * Vn(tn * t) / Vn(il - tn * t)) / 3, a = 1 - (n + i)) : (t -= 2 / 3, i = (1 - r) / 3, a = (1 + r * Vn(tn * t) / Vn(il - tn * t)) / 3, n = 1 - (i + a)), n = Cn(o * n * 3), i = Cn(o * i * 3), a = Cn(o * a * 3), [n * 255, i * 255, a * 255, e.length > 3 ? e[3] : 1];
}, { min: K2, sqrt: X2, acos: Q2 } = Math, J2 = (...e) => {
  let [t, r, o] = lt(e, "rgb");
  t /= 255, r /= 255, o /= 255;
  let n;
  const i = K2(t, r, o), a = (t + r + o) / 3, s = a > 0 ? 1 - i / a : 0;
  return s === 0 ? n = NaN : (n = (t - r + (t - o)) / 2, n /= X2((t - r) * (t - r) + (t - o) * (r - o)), n = Q2(n), o > r && (n = tn - n), n /= tn), [n * 360, s, a];
};
Ue.prototype.hsi = function() {
  return J2(this._rgb);
};
const eT = (...e) => new Ue(...e, "hsi");
dt.hsi = eT;
it.format.hsi = G2;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "hsi"), ut(e) === "array" && e.length === 3)
      return "hsi";
  }
});
const tT = (e, t, r) => So(e, t, r, "hsi");
er.hsi = tT;
const Yl = (...e) => {
  e = lt(e, "hsl");
  const [t, r, o] = e;
  let n, i, a;
  if (r === 0)
    n = i = a = o * 255;
  else {
    const s = [0, 0, 0], c = [0, 0, 0], p = o < 0.5 ? o * (1 + r) : o + r - o * r, l = 2 * o - p, d = t / 360;
    s[0] = d + 1 / 3, s[1] = d, s[2] = d - 1 / 3;
    for (let u = 0; u < 3; u++)
      s[u] < 0 && (s[u] += 1), s[u] > 1 && (s[u] -= 1), 6 * s[u] < 1 ? c[u] = l + (p - l) * 6 * s[u] : 2 * s[u] < 1 ? c[u] = p : 3 * s[u] < 2 ? c[u] = l + (p - l) * (2 / 3 - s[u]) * 6 : c[u] = l;
    [n, i, a] = [c[0] * 255, c[1] * 255, c[2] * 255];
  }
  return e.length > 3 ? [n, i, a, e[3]] : [n, i, a, 1];
}, _y = (...e) => {
  e = lt(e, "rgba");
  let [t, r, o] = e;
  t /= 255, r /= 255, o /= 255;
  const n = uy(t, r, o), i = fy(t, r, o), a = (i + n) / 2;
  let s, c;
  return i === n ? (s = 0, c = Number.NaN) : s = a < 0.5 ? (i - n) / (i + n) : (i - n) / (2 - i - n), t == i ? c = (r - o) / (i - n) : r == i ? c = 2 + (o - t) / (i - n) : o == i && (c = 4 + (t - r) / (i - n)), c *= 60, c < 0 && (c += 360), e.length > 3 && e[3] !== void 0 ? [c, s, a, e[3]] : [c, s, a];
};
Ue.prototype.hsl = function() {
  return _y(this._rgb);
};
const rT = (...e) => new Ue(...e, "hsl");
dt.hsl = rT;
it.format.hsl = Yl;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "hsl"), ut(e) === "array" && e.length === 3)
      return "hsl";
  }
});
const nT = (e, t, r) => So(e, t, r, "hsl");
er.hsl = nT;
const { floor: oT } = Math, iT = (...e) => {
  e = lt(e, "hsv");
  let [t, r, o] = e, n, i, a;
  if (o *= 255, r === 0)
    n = i = a = o;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const s = oT(t), c = t - s, p = o * (1 - r), l = o * (1 - r * c), d = o * (1 - r * (1 - c));
    switch (s) {
      case 0:
        [n, i, a] = [o, d, p];
        break;
      case 1:
        [n, i, a] = [l, o, p];
        break;
      case 2:
        [n, i, a] = [p, o, d];
        break;
      case 3:
        [n, i, a] = [p, l, o];
        break;
      case 4:
        [n, i, a] = [d, p, o];
        break;
      case 5:
        [n, i, a] = [o, p, l];
        break;
    }
  }
  return [n, i, a, e.length > 3 ? e[3] : 1];
}, { min: aT, max: sT } = Math, lT = (...e) => {
  e = lt(e, "rgb");
  let [t, r, o] = e;
  const n = aT(t, r, o), i = sT(t, r, o), a = i - n;
  let s, c, p;
  return p = i / 255, i === 0 ? (s = Number.NaN, c = 0) : (c = a / i, t === i && (s = (r - o) / a), r === i && (s = 2 + (o - t) / a), o === i && (s = 4 + (t - r) / a), s *= 60, s < 0 && (s += 360)), [s, c, p];
};
Ue.prototype.hsv = function() {
  return lT(this._rgb);
};
const cT = (...e) => new Ue(...e, "hsv");
dt.hsv = cT;
it.format.hsv = iT;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "hsv"), ut(e) === "array" && e.length === 3)
      return "hsv";
  }
});
const uT = (e, t, r) => So(e, t, r, "hsv");
er.hsv = uT;
function za(e, t) {
  let r = e.length;
  Array.isArray(e[0]) || (e = [e]), Array.isArray(t[0]) || (t = t.map((a) => [a]));
  let o = t[0].length, n = t[0].map((a, s) => t.map((c) => c[s])), i = e.map(
    (a) => n.map((s) => Array.isArray(a) ? a.reduce((c, p, l) => c + p * (s[l] || 0), 0) : s.reduce((c, p) => c + p * a, 0))
  );
  return r === 1 && (i = i[0]), o === 1 ? i.map((a) => a[0]) : i;
}
const du = (...e) => {
  e = lt(e, "lab");
  const [t, r, o, ...n] = e, [i, a, s] = fT([t, r, o]), [c, p, l] = yy(i, a, s);
  return [c, p, l, ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
};
function fT(e) {
  var t = [
    [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
    [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
    [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
  ], r = [
    [1, 0.3963377773761749, 0.2158037573099136],
    [1, -0.1055613458156586, -0.0638541728258133],
    [1, -0.0894841775298119, -1.2914855480194092]
  ], o = za(r, e);
  return za(
    t,
    o.map((n) => n ** 3)
  );
}
const pu = (...e) => {
  const [t, r, o, ...n] = lt(e, "rgb"), i = my(t, r, o);
  return [...dT(i), ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
};
function dT(e) {
  const t = [
    [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
    [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
    [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
  ], r = [
    [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
    [1.9779985324311684, -2.42859224204858, 0.450593709617411],
    [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
  ], o = za(t, e);
  return za(
    r,
    o.map((n) => Math.cbrt(n))
  );
}
Ue.prototype.oklab = function() {
  return pu(this._rgb);
};
const pT = (...e) => new Ue(...e, "oklab");
Object.assign(dt, { oklab: pT });
it.format.oklab = du;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "oklab"), ut(e) === "array" && e.length === 3)
      return "oklab";
  }
});
const hT = (e, t, r) => {
  const o = e.oklab(), n = t.oklab();
  return new Ue(
    o[0] + r * (n[0] - o[0]),
    o[1] + r * (n[1] - o[1]),
    o[2] + r * (n[2] - o[2]),
    "oklab"
  );
};
er.oklab = hT;
const yT = (e, t, r) => So(e, t, r, "oklch");
er.oklch = yT;
const { pow: ul, sqrt: fl, PI: dl, cos: gd, sin: bd, atan2: mT } = Math, gT = (e, t = "lrgb", r = null) => {
  const o = e.length;
  r || (r = Array.from(new Array(o)).map(() => 1));
  const n = o / r.reduce(function(d, u) {
    return d + u;
  });
  if (r.forEach((d, u) => {
    r[u] *= n;
  }), e = e.map((d) => new Ue(d)), t === "lrgb")
    return bT(e, r);
  const i = e.shift(), a = i.get(t), s = [];
  let c = 0, p = 0;
  for (let d = 0; d < a.length; d++)
    if (a[d] = (a[d] || 0) * r[0], s.push(isNaN(a[d]) ? 0 : r[0]), t.charAt(d) === "h" && !isNaN(a[d])) {
      const u = a[d] / 180 * dl;
      c += gd(u) * r[0], p += bd(u) * r[0];
    }
  let l = i.alpha() * r[0];
  e.forEach((d, u) => {
    const h = d.get(t);
    l += d.alpha() * r[u + 1];
    for (let y = 0; y < a.length; y++)
      if (!isNaN(h[y]))
        if (s[y] += r[u + 1], t.charAt(y) === "h") {
          const f = h[y] / 180 * dl;
          c += gd(f) * r[u + 1], p += bd(f) * r[u + 1];
        } else
          a[y] += h[y] * r[u + 1];
  });
  for (let d = 0; d < a.length; d++)
    if (t.charAt(d) === "h") {
      let u = mT(p / s[d], c / s[d]) / dl * 180;
      for (; u < 0; ) u += 360;
      for (; u >= 360; ) u -= 360;
      a[d] = u;
    } else
      a[d] = a[d] / s[d];
  return l /= o, new Ue(a, t).alpha(l > 0.99999 ? 1 : l, !0);
}, bT = (e, t) => {
  const r = e.length, o = [0, 0, 0, 0];
  for (let n = 0; n < e.length; n++) {
    const i = e[n], a = t[n] / r, s = i._rgb;
    o[0] += ul(s[0], 2) * a, o[1] += ul(s[1], 2) * a, o[2] += ul(s[2], 2) * a, o[3] += s[3] * a;
  }
  return o[0] = fl(o[0]), o[1] = fl(o[1]), o[2] = fl(o[2]), o[3] > 0.9999999 && (o[3] = 1), new Ue(su(o));
}, { pow: vT } = Math;
function Ha(e) {
  let t = "rgb", r = dt("#ccc"), o = 0, n = [0, 1], i = [], a = [0, 0], s = !1, c = [], p = !1, l = 0, d = 1, u = !1, h = {}, y = !0, f = 1;
  const b = function(A) {
    if (A = A || ["#fff", "#000"], A && ut(A) === "string" && dt.brewer && dt.brewer[A.toLowerCase()] && (A = dt.brewer[A.toLowerCase()]), ut(A) === "array") {
      A.length === 1 && (A = [A[0], A[0]]), A = A.slice(0);
      for (let j = 0; j < A.length; j++)
        A[j] = dt(A[j]);
      i.length = 0;
      for (let j = 0; j < A.length; j++)
        i.push(j / (A.length - 1));
    }
    return C(), c = A;
  }, w = function(A) {
    if (s != null) {
      const j = s.length - 1;
      let N = 0;
      for (; N < j && A >= s[N]; )
        N++;
      return N - 1;
    }
    return 0;
  };
  let x = (A) => A, E = (A) => A;
  const T = function(A, j) {
    let N, O;
    if (j == null && (j = !1), isNaN(A) || A === null)
      return r;
    j ? O = A : s && s.length > 2 ? O = w(A) / (s.length - 2) : d !== l ? O = (A - l) / (d - l) : O = 1, O = E(O), j || (O = x(O)), f !== 1 && (O = vT(O, f)), O = a[0] + O * (1 - a[0] - a[1]), O = Cn(O, 0, 1);
    const D = Math.floor(O * 1e4);
    if (y && h[D])
      N = h[D];
    else {
      if (ut(c) === "array")
        for (let H = 0; H < i.length; H++) {
          const G = i[H];
          if (O <= G) {
            N = c[H];
            break;
          }
          if (O >= G && H === i.length - 1) {
            N = c[H];
            break;
          }
          if (O > G && O < i[H + 1]) {
            O = (O - G) / (i[H + 1] - G), N = dt.interpolate(
              c[H],
              c[H + 1],
              O,
              t
            );
            break;
          }
        }
      else ut(c) === "function" && (N = c(O));
      y && (h[D] = N);
    }
    return N;
  };
  var C = () => h = {};
  b(e);
  const R = function(A) {
    const j = dt(T(A));
    return p && j[p] ? j[p]() : j;
  };
  return R.classes = function(A) {
    if (A != null) {
      if (ut(A) === "array")
        s = A, n = [A[0], A[A.length - 1]];
      else {
        const j = dt.analyze(n);
        A === 0 ? s = [j.min, j.max] : s = dt.limits(j, "e", A);
      }
      return R;
    }
    return s;
  }, R.domain = function(A) {
    if (!arguments.length)
      return n;
    l = A[0], d = A[A.length - 1], i = [];
    const j = c.length;
    if (A.length === j && l !== d)
      for (let N of Array.from(A))
        i.push((N - l) / (d - l));
    else {
      for (let N = 0; N < j; N++)
        i.push(N / (j - 1));
      if (A.length > 2) {
        const N = A.map((D, H) => H / (A.length - 1)), O = A.map((D) => (D - l) / (d - l));
        O.every((D, H) => N[H] === D) || (E = (D) => {
          if (D <= 0 || D >= 1) return D;
          let H = 0;
          for (; D >= O[H + 1]; ) H++;
          const G = (D - O[H]) / (O[H + 1] - O[H]);
          return N[H] + G * (N[H + 1] - N[H]);
        });
      }
    }
    return n = [l, d], R;
  }, R.mode = function(A) {
    return arguments.length ? (t = A, C(), R) : t;
  }, R.range = function(A, j) {
    return b(A), R;
  }, R.out = function(A) {
    return p = A, R;
  }, R.spread = function(A) {
    return arguments.length ? (o = A, R) : o;
  }, R.correctLightness = function(A) {
    return A == null && (A = !0), u = A, C(), u ? x = function(j) {
      const N = T(0, !0).lab()[0], O = T(1, !0).lab()[0], D = N > O;
      let H = T(j, !0).lab()[0];
      const G = N + (O - N) * j;
      let X = H - G, Q = 0, M = 1, k = 20;
      for (; Math.abs(X) > 0.01 && k-- > 0; )
        (function() {
          return D && (X *= -1), X < 0 ? (Q = j, j += (M - j) * 0.5) : (M = j, j += (Q - j) * 0.5), H = T(j, !0).lab()[0], X = H - G;
        })();
      return j;
    } : x = (j) => j, R;
  }, R.padding = function(A) {
    return A != null ? (ut(A) === "number" && (A = [A, A]), a = A, R) : a;
  }, R.colors = function(A, j) {
    arguments.length < 2 && (j = "hex");
    let N = [];
    if (arguments.length === 0)
      N = c.slice(0);
    else if (A === 1)
      N = [R(0.5)];
    else if (A > 1) {
      const O = n[0], D = n[1] - O;
      N = _T(0, A).map(
        (H) => R(O + H / (A - 1) * D)
      );
    } else {
      e = [];
      let O = [];
      if (s && s.length > 2)
        for (let D = 1, H = s.length, G = 1 <= H; G ? D < H : D > H; G ? D++ : D--)
          O.push((s[D - 1] + s[D]) * 0.5);
      else
        O = n;
      N = O.map((D) => R(D));
    }
    return dt[j] && (N = N.map((O) => O[j]())), N;
  }, R.cache = function(A) {
    return A != null ? (y = A, R) : y;
  }, R.gamma = function(A) {
    return A != null ? (f = A, R) : f;
  }, R.nodata = function(A) {
    return A != null ? (r = dt(A), R) : r;
  }, R;
}
function _T(e, t, r) {
  let o = [], n = e < t, i = t;
  for (let a = e; n ? a < i : a > i; n ? a++ : a--)
    o.push(a);
  return o;
}
const wT = function(e) {
  let t = [1, 1];
  for (let r = 1; r < e; r++) {
    let o = [1];
    for (let n = 1; n <= t.length; n++)
      o[n] = (t[n] || 0) + t[n - 1];
    t = o;
  }
  return t;
}, ET = function(e) {
  let t, r, o, n;
  if (e = e.map((i) => new Ue(i)), e.length === 2)
    [r, o] = e.map((i) => i.lab()), t = function(i) {
      const a = [0, 1, 2].map((s) => r[s] + i * (o[s] - r[s]));
      return new Ue(a, "lab");
    };
  else if (e.length === 3)
    [r, o, n] = e.map((i) => i.lab()), t = function(i) {
      const a = [0, 1, 2].map(
        (s) => (1 - i) * (1 - i) * r[s] + 2 * (1 - i) * i * o[s] + i * i * n[s]
      );
      return new Ue(a, "lab");
    };
  else if (e.length === 4) {
    let i;
    [r, o, n, i] = e.map((a) => a.lab()), t = function(a) {
      const s = [0, 1, 2].map(
        (c) => (1 - a) * (1 - a) * (1 - a) * r[c] + 3 * (1 - a) * (1 - a) * a * o[c] + 3 * (1 - a) * a * a * n[c] + a * a * a * i[c]
      );
      return new Ue(s, "lab");
    };
  } else if (e.length >= 5) {
    let i, a, s;
    i = e.map((c) => c.lab()), s = e.length - 1, a = wT(s), t = function(c) {
      const p = 1 - c, l = [0, 1, 2].map(
        (d) => i.reduce(
          (u, h, y) => u + a[y] * p ** (s - y) * c ** y * h[d],
          0
        )
      );
      return new Ue(l, "lab");
    };
  } else
    throw new RangeError("No point in running bezier with only one color.");
  return t;
}, ST = (e) => {
  const t = ET(e);
  return t.scale = () => Ha(t), t;
}, { round: wy } = Math;
Ue.prototype.rgb = function(e = !0) {
  return e === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(wy);
};
Ue.prototype.rgba = function(e = !0) {
  return this._rgb.slice(0, 4).map((t, r) => r < 3 ? e === !1 ? t : wy(t) : t);
};
const TT = (...e) => new Ue(...e, "rgb");
Object.assign(dt, { rgb: TT });
it.format.rgb = (...e) => {
  const t = lt(e, "rgba");
  return t[3] === void 0 && (t[3] = 1), t;
};
it.autodetect.push({
  p: 3,
  test: (...e) => {
    if (e = lt(e, "rgba"), ut(e) === "array" && (e.length === 3 || e.length === 4 && ut(e[3]) == "number" && e[3] >= 0 && e[3] <= 1))
      return "rgb";
  }
});
const Or = (e, t, r) => {
  if (!Or[r])
    throw new Error("unknown blend mode " + r);
  return Or[r](e, t);
}, vn = (e) => (t, r) => {
  const o = dt(r).rgb(), n = dt(t).rgb();
  return dt.rgb(e(o, n));
}, _n = (e) => (t, r) => {
  const o = [];
  return o[0] = e(t[0], r[0]), o[1] = e(t[1], r[1]), o[2] = e(t[2], r[2]), o;
}, xT = (e) => e, RT = (e, t) => e * t / 255, OT = (e, t) => e > t ? t : e, AT = (e, t) => e > t ? e : t, kT = (e, t) => 255 * (1 - (1 - e / 255) * (1 - t / 255)), CT = (e, t) => t < 128 ? 2 * e * t / 255 : 255 * (1 - 2 * (1 - e / 255) * (1 - t / 255)), PT = (e, t) => 255 * (1 - (1 - t / 255) / (e / 255)), IT = (e, t) => e === 255 ? 255 : (e = 255 * (t / 255) / (1 - e / 255), e > 255 ? 255 : e);
Or.normal = vn(_n(xT));
Or.multiply = vn(_n(RT));
Or.screen = vn(_n(kT));
Or.overlay = vn(_n(CT));
Or.darken = vn(_n(OT));
Or.lighten = vn(_n(AT));
Or.dodge = vn(_n(IT));
Or.burn = vn(_n(PT));
const { pow: NT, sin: LT, cos: jT } = Math;
function MT(e = 300, t = -1.5, r = 1, o = 1, n = [0, 1]) {
  let i = 0, a;
  ut(n) === "array" ? a = n[1] - n[0] : (a = 0, n = [n, n]);
  const s = function(c) {
    const p = tn * ((e + 120) / 360 + t * c), l = NT(n[0] + a * c, o), u = (i !== 0 ? r[0] + c * i : r) * l * (1 - l) / 2, h = jT(p), y = LT(p), f = l + u * (-0.14861 * h + 1.78277 * y), b = l + u * (-0.29227 * h - 0.90649 * y), w = l + u * (1.97294 * h);
    return dt(su([f * 255, b * 255, w * 255, 1]));
  };
  return s.start = function(c) {
    return c == null ? e : (e = c, s);
  }, s.rotations = function(c) {
    return c == null ? t : (t = c, s);
  }, s.gamma = function(c) {
    return c == null ? o : (o = c, s);
  }, s.hue = function(c) {
    return c == null ? r : (r = c, ut(r) === "array" ? (i = r[1] - r[0], i === 0 && (r = r[1])) : i = 0, s);
  }, s.lightness = function(c) {
    return c == null ? n : (ut(c) === "array" ? (n = c, a = c[1] - c[0]) : (n = [c, c], a = 0), s);
  }, s.scale = () => dt.scale(s), s.hue(r), s;
}
const FT = "0123456789abcdef", { floor: DT, random: BT } = Math, $T = () => {
  let e = "#";
  for (let t = 0; t < 6; t++)
    e += FT.charAt(DT(BT() * 16));
  return new Ue(e, "hex");
}, { log: vd, pow: UT, floor: zT, abs: HT } = Math;
function Ey(e, t = null) {
  const r = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  return ut(e) === "object" && (e = Object.values(e)), e.forEach((o) => {
    t && ut(o) === "object" && (o = o[t]), o != null && !isNaN(o) && (r.values.push(o), r.sum += o, o < r.min && (r.min = o), o > r.max && (r.max = o), r.count += 1);
  }), r.domain = [r.min, r.max], r.limits = (o, n) => Sy(r, o, n), r;
}
function Sy(e, t = "equal", r = 7) {
  ut(e) == "array" && (e = Ey(e));
  const { min: o, max: n } = e, i = e.values.sort((s, c) => s - c);
  if (r === 1)
    return [o, n];
  const a = [];
  if (t.substr(0, 1) === "c" && (a.push(o), a.push(n)), t.substr(0, 1) === "e") {
    a.push(o);
    for (let s = 1; s < r; s++)
      a.push(o + s / r * (n - o));
    a.push(n);
  } else if (t.substr(0, 1) === "l") {
    if (o <= 0)
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    const s = Math.LOG10E * vd(o), c = Math.LOG10E * vd(n);
    a.push(o);
    for (let p = 1; p < r; p++)
      a.push(UT(10, s + p / r * (c - s)));
    a.push(n);
  } else if (t.substr(0, 1) === "q") {
    a.push(o);
    for (let s = 1; s < r; s++) {
      const c = (i.length - 1) * s / r, p = zT(c);
      if (p === c)
        a.push(i[p]);
      else {
        const l = c - p;
        a.push(i[p] * (1 - l) + i[p + 1] * l);
      }
    }
    a.push(n);
  } else if (t.substr(0, 1) === "k") {
    let s;
    const c = i.length, p = new Array(c), l = new Array(r);
    let d = !0, u = 0, h = null;
    h = [], h.push(o);
    for (let b = 1; b < r; b++)
      h.push(o + b / r * (n - o));
    for (h.push(n); d; ) {
      for (let w = 0; w < r; w++)
        l[w] = 0;
      for (let w = 0; w < c; w++) {
        const x = i[w];
        let E = Number.MAX_VALUE, T;
        for (let C = 0; C < r; C++) {
          const R = HT(h[C] - x);
          R < E && (E = R, T = C), l[T]++, p[w] = T;
        }
      }
      const b = new Array(r);
      for (let w = 0; w < r; w++)
        b[w] = null;
      for (let w = 0; w < c; w++)
        s = p[w], b[s] === null ? b[s] = i[w] : b[s] += i[w];
      for (let w = 0; w < r; w++)
        b[w] *= 1 / l[w];
      d = !1;
      for (let w = 0; w < r; w++)
        if (b[w] !== h[w]) {
          d = !0;
          break;
        }
      h = b, u++, u > 200 && (d = !1);
    }
    const y = {};
    for (let b = 0; b < r; b++)
      y[b] = [];
    for (let b = 0; b < c; b++)
      s = p[b], y[s].push(i[b]);
    let f = [];
    for (let b = 0; b < r; b++)
      f.push(y[b][0]), f.push(y[b][y[b].length - 1]);
    f = f.sort((b, w) => b - w), a.push(f[0]);
    for (let b = 1; b < f.length; b += 2) {
      const w = f[b];
      !isNaN(w) && a.indexOf(w) === -1 && a.push(w);
    }
  }
  return a;
}
const WT = (e, t) => {
  e = new Ue(e), t = new Ue(t);
  const r = e.luminance(), o = t.luminance();
  return r > o ? (r + 0.05) / (o + 0.05) : (o + 0.05) / (r + 0.05);
};
/**
 * @license
 *
 * The APCA contrast prediction algorithm is based of the formulas published
 * in the APCA-1.0.98G specification by Myndex. The specification is available at:
 * https://raw.githubusercontent.com/Myndex/apca-w3/master/images/APCAw3_0.1.17_APCA0.0.98G.svg
 *
 * Note that the APCA implementation is still beta, so please update to
 * future versions of chroma.js when they become available.
 *
 * You can read more about the APCA Readability Criterion at
 * https://readtech.org/ARC/
 */
const _d = 0.027, VT = 5e-4, ZT = 0.1, wd = 1.14, Ji = 0.022, Ed = 1.414, qT = (e, t) => {
  e = new Ue(e), t = new Ue(t), e.alpha() < 1 && (e = po(t, e, e.alpha(), "rgb"));
  const r = Sd(...e.rgb()), o = Sd(...t.rgb()), n = r >= Ji ? r : r + Math.pow(Ji - r, Ed), i = o >= Ji ? o : o + Math.pow(Ji - o, Ed), a = Math.pow(i, 0.56) - Math.pow(n, 0.57), s = Math.pow(i, 0.65) - Math.pow(n, 0.62), c = Math.abs(i - n) < VT ? 0 : n < i ? a * wd : s * wd;
  return (Math.abs(c) < ZT ? 0 : c > 0 ? c - _d : c + _d) * 100;
};
function Sd(e, t, r) {
  return 0.2126729 * Math.pow(e / 255, 2.4) + 0.7151522 * Math.pow(t / 255, 2.4) + 0.072175 * Math.pow(r / 255, 2.4);
}
const { sqrt: en, pow: Bt, min: YT, max: GT, atan2: Td, abs: xd, cos: ea, sin: Rd, exp: KT, PI: Od } = Math;
function XT(e, t, r = 1, o = 1, n = 1) {
  var i = function(z) {
    return 360 * z / (2 * Od);
  }, a = function(z) {
    return 2 * Od * z / 360;
  };
  e = new Ue(e), t = new Ue(t);
  const [s, c, p] = Array.from(e.lab()), [l, d, u] = Array.from(t.lab()), h = (s + l) / 2, y = en(Bt(c, 2) + Bt(p, 2)), f = en(Bt(d, 2) + Bt(u, 2)), b = (y + f) / 2, w = 0.5 * (1 - en(Bt(b, 7) / (Bt(b, 7) + Bt(25, 7)))), x = c * (1 + w), E = d * (1 + w), T = en(Bt(x, 2) + Bt(p, 2)), C = en(Bt(E, 2) + Bt(u, 2)), R = (T + C) / 2, A = i(Td(p, x)), j = i(Td(u, E)), N = A >= 0 ? A : A + 360, O = j >= 0 ? j : j + 360, D = xd(N - O) > 180 ? (N + O + 360) / 2 : (N + O) / 2, H = 1 - 0.17 * ea(a(D - 30)) + 0.24 * ea(a(2 * D)) + 0.32 * ea(a(3 * D + 6)) - 0.2 * ea(a(4 * D - 63));
  let G = O - N;
  G = xd(G) <= 180 ? G : O <= N ? G + 360 : G - 360, G = 2 * en(T * C) * Rd(a(G) / 2);
  const X = l - s, Q = C - T, M = 1 + 0.015 * Bt(h - 50, 2) / en(20 + Bt(h - 50, 2)), k = 1 + 0.045 * R, $ = 1 + 0.015 * R * H, ne = 30 * KT(-Bt((D - 275) / 25, 2)), de = -(2 * en(Bt(R, 7) / (Bt(R, 7) + Bt(25, 7)))) * Rd(2 * a(ne)), ae = en(
    Bt(X / (r * M), 2) + Bt(Q / (o * k), 2) + Bt(G / (n * $), 2) + de * (Q / (o * k)) * (G / (n * $))
  );
  return GT(0, YT(100, ae));
}
function QT(e, t, r = "lab") {
  e = new Ue(e), t = new Ue(t);
  const o = e.get(r), n = t.get(r);
  let i = 0;
  for (let a in o) {
    const s = (o[a] || 0) - (n[a] || 0);
    i += s * s;
  }
  return Math.sqrt(i);
}
const JT = (...e) => {
  try {
    return new Ue(...e), !0;
  } catch {
    return !1;
  }
}, ex = {
  cool() {
    return Ha([dt.hsl(180, 1, 0.9), dt.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return Ha(["#000", "#f00", "#ff0", "#fff"]).mode(
      "rgb"
    );
  }
}, Gl = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
}, Ty = Object.keys(Gl), Ad = new Map(Ty.map((e) => [e.toLowerCase(), e])), tx = typeof Proxy == "function" ? new Proxy(Gl, {
  get(e, t) {
    const r = t.toLowerCase();
    if (Ad.has(r))
      return e[Ad.get(r)];
  },
  getOwnPropertyNames() {
    return Object.getOwnPropertyNames(Ty);
  }
}) : Gl, rx = (...e) => {
  e = lt(e, "cmyk");
  const [t, r, o, n] = e, i = e.length > 4 ? e[4] : 1;
  return n === 1 ? [0, 0, 0, i] : [
    t >= 1 ? 0 : 255 * (1 - t) * (1 - n),
    // r
    r >= 1 ? 0 : 255 * (1 - r) * (1 - n),
    // g
    o >= 1 ? 0 : 255 * (1 - o) * (1 - n),
    // b
    i
  ];
}, { max: kd } = Math, nx = (...e) => {
  let [t, r, o] = lt(e, "rgb");
  t = t / 255, r = r / 255, o = o / 255;
  const n = 1 - kd(t, kd(r, o)), i = n < 1 ? 1 / (1 - n) : 0, a = (1 - t - n) * i, s = (1 - r - n) * i, c = (1 - o - n) * i;
  return [a, s, c, n];
};
Ue.prototype.cmyk = function() {
  return nx(this._rgb);
};
const ox = (...e) => new Ue(...e, "cmyk");
Object.assign(dt, { cmyk: ox });
it.format.cmyk = rx;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "cmyk"), ut(e) === "array" && e.length === 4)
      return "cmyk";
  }
});
const ix = (...e) => {
  const t = lt(e, "hsla");
  let r = Eo(e) || "lsa";
  return t[0] = br(t[0] || 0) + "deg", t[1] = br(t[1] * 100) + "%", t[2] = br(t[2] * 100) + "%", r === "hsla" || t.length > 3 && t[3] < 1 ? (t[3] = "/ " + (t.length > 3 ? t[3] : 1), r = "hsla") : t.length = 3, `${r.substr(0, 3)}(${t.join(" ")})`;
}, ax = (...e) => {
  const t = lt(e, "lab");
  let r = Eo(e) || "lab";
  return t[0] = br(t[0]) + "%", t[1] = br(t[1]), t[2] = br(t[2]), r === "laba" || t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `lab(${t.join(" ")})`;
}, sx = (...e) => {
  const t = lt(e, "lch");
  let r = Eo(e) || "lab";
  return t[0] = br(t[0]) + "%", t[1] = br(t[1]), t[2] = isNaN(t[2]) ? "none" : br(t[2]) + "deg", r === "lcha" || t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `lch(${t.join(" ")})`;
}, lx = (...e) => {
  const t = lt(e, "lab");
  return t[0] = br(t[0] * 100) + "%", t[1] = ql(t[1]), t[2] = ql(t[2]), t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `oklab(${t.join(" ")})`;
}, xy = (...e) => {
  const [t, r, o, ...n] = lt(e, "rgb"), [i, a, s] = pu(t, r, o), [c, p, l] = by(i, a, s);
  return [c, p, l, ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
}, cx = (...e) => {
  const t = lt(e, "lch");
  return t[0] = br(t[0] * 100) + "%", t[1] = ql(t[1]), t[2] = isNaN(t[2]) ? "none" : br(t[2]) + "deg", t.length > 3 && t[3] < 1 ? t[3] = "/ " + (t.length > 3 ? t[3] : 1) : t.length = 3, `oklch(${t.join(" ")})`;
}, { round: pl } = Math, ux = (...e) => {
  const t = lt(e, "rgba");
  let r = Eo(e) || "rgb";
  if (r.substr(0, 3) === "hsl")
    return ix(_y(t), r);
  if (r.substr(0, 3) === "lab") {
    const o = mi();
    rn("d50");
    const n = ax(cu(t), r);
    return rn(o), n;
  }
  if (r.substr(0, 3) === "lch") {
    const o = mi();
    rn("d50");
    const n = sx(fu(t), r);
    return rn(o), n;
  }
  return r.substr(0, 5) === "oklab" ? lx(pu(t)) : r.substr(0, 5) === "oklch" ? cx(xy(t)) : (t[0] = pl(t[0]), t[1] = pl(t[1]), t[2] = pl(t[2]), (r === "rgba" || t.length > 3 && t[3] < 1) && (t[3] = "/ " + (t.length > 3 ? t[3] : 1), r = "rgba"), `${r.substr(0, 3)}(${t.slice(0, r === "rgb" ? 3 : 4).join(" ")})`);
}, Ry = (...e) => {
  e = lt(e, "lch");
  const [t, r, o, ...n] = e, [i, a, s] = gy(t, r, o), [c, p, l] = du(i, a, s);
  return [c, p, l, ...n.length > 0 && n[0] < 1 ? [n[0]] : []];
}, nn = /((?:-?\d+)|(?:-?\d+(?:\.\d+)?)%|none)/.source, Rr = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%?)|none)/.source, Wa = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%)|none)/.source, Er = /\s*/.source, To = /\s+/.source, hu = /\s*,\s*/.source, Ts = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)(?:deg)?)|none)/.source, xo = /\s*(?:\/\s*((?:[01]|[01]?\.\d+)|\d+(?:\.\d+)?%))?/.source, Oy = new RegExp(
  "^rgba?\\(" + Er + [nn, nn, nn].join(To) + xo + "\\)$"
), Ay = new RegExp(
  "^rgb\\(" + Er + [nn, nn, nn].join(hu) + Er + "\\)$"
), ky = new RegExp(
  "^rgba\\(" + Er + [nn, nn, nn, Rr].join(hu) + Er + "\\)$"
), Cy = new RegExp(
  "^hsla?\\(" + Er + [Ts, Wa, Wa].join(To) + xo + "\\)$"
), Py = new RegExp(
  "^hsl?\\(" + Er + [Ts, Wa, Wa].join(hu) + Er + "\\)$"
), Iy = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, Ny = new RegExp(
  "^lab\\(" + Er + [Rr, Rr, Rr].join(To) + xo + "\\)$"
), Ly = new RegExp(
  "^lch\\(" + Er + [Rr, Rr, Ts].join(To) + xo + "\\)$"
), jy = new RegExp(
  "^oklab\\(" + Er + [Rr, Rr, Rr].join(To) + xo + "\\)$"
), My = new RegExp(
  "^oklch\\(" + Er + [Rr, Rr, Ts].join(To) + xo + "\\)$"
), { round: Fy } = Math, Zn = (e) => e.map((t, r) => r <= 2 ? Cn(Fy(t), 0, 255) : t), $t = (e, t = 0, r = 100, o = !1) => (typeof e == "string" && e.endsWith("%") && (e = parseFloat(e.substring(0, e.length - 1)) / 100, o ? e = t + (e + 1) * 0.5 * (r - t) : e = t + e * (r - t)), +e), rr = (e, t) => e === "none" ? t : e, yu = (e) => {
  if (e = e.toLowerCase().trim(), e === "transparent")
    return [0, 0, 0, 0];
  let t;
  if (it.format.named)
    try {
      return it.format.named(e);
    } catch {
    }
  if ((t = e.match(Oy)) || (t = e.match(Ay))) {
    let r = t.slice(1, 4);
    for (let n = 0; n < 3; n++)
      r[n] = +$t(rr(r[n], 0), 0, 255);
    r = Zn(r);
    const o = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return r[3] = o, r;
  }
  if (t = e.match(ky)) {
    const r = t.slice(1, 5);
    for (let o = 0; o < 4; o++)
      r[o] = +$t(r[o], 0, 255);
    return r;
  }
  if ((t = e.match(Cy)) || (t = e.match(Py))) {
    const r = t.slice(1, 4);
    r[0] = +rr(r[0].replace("deg", ""), 0), r[1] = +$t(rr(r[1], 0), 0, 100) * 0.01, r[2] = +$t(rr(r[2], 0), 0, 100) * 0.01;
    const o = Zn(Yl(r)), n = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return o[3] = n, o;
  }
  if (t = e.match(Iy)) {
    const r = t.slice(1, 4);
    r[1] *= 0.01, r[2] *= 0.01;
    const o = Yl(r);
    for (let n = 0; n < 3; n++)
      o[n] = Fy(o[n]);
    return o[3] = +t[4], o;
  }
  if (t = e.match(Ny)) {
    const r = t.slice(1, 4);
    r[0] = $t(rr(r[0], 0), 0, 100), r[1] = $t(rr(r[1], 0), -125, 125, !0), r[2] = $t(rr(r[2], 0), -125, 125, !0);
    const o = mi();
    rn("d50");
    const n = Zn(lu(r));
    rn(o);
    const i = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return n[3] = i, n;
  }
  if (t = e.match(Ly)) {
    const r = t.slice(1, 4);
    r[0] = $t(r[0], 0, 100), r[1] = $t(rr(r[1], 0), 0, 150, !1), r[2] = +rr(r[2].replace("deg", ""), 0);
    const o = mi();
    rn("d50");
    const n = Zn(uu(r));
    rn(o);
    const i = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return n[3] = i, n;
  }
  if (t = e.match(jy)) {
    const r = t.slice(1, 4);
    r[0] = $t(rr(r[0], 0), 0, 1), r[1] = $t(rr(r[1], 0), -0.4, 0.4, !0), r[2] = $t(rr(r[2], 0), -0.4, 0.4, !0);
    const o = Zn(du(r)), n = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return o[3] = n, o;
  }
  if (t = e.match(My)) {
    const r = t.slice(1, 4);
    r[0] = $t(rr(r[0], 0), 0, 1), r[1] = $t(rr(r[1], 0), 0, 0.4, !1), r[2] = +rr(r[2].replace("deg", ""), 0);
    const o = Zn(Ry(r)), n = t[4] !== void 0 ? +$t(t[4], 0, 1) : 1;
    return o[3] = n, o;
  }
};
yu.test = (e) => (
  // modern
  Oy.test(e) || Cy.test(e) || Ny.test(e) || Ly.test(e) || jy.test(e) || My.test(e) || // legacy
  Ay.test(e) || ky.test(e) || Py.test(e) || Iy.test(e) || e === "transparent"
);
Ue.prototype.css = function(e) {
  return ux(this._rgb, e);
};
const fx = (...e) => new Ue(...e, "css");
dt.css = fx;
it.format.css = yu;
it.autodetect.push({
  p: 5,
  test: (e, ...t) => {
    if (!t.length && ut(e) === "string" && yu.test(e))
      return "css";
  }
});
it.format.gl = (...e) => {
  const t = lt(e, "rgba");
  return t[0] *= 255, t[1] *= 255, t[2] *= 255, t;
};
const dx = (...e) => new Ue(...e, "gl");
dt.gl = dx;
Ue.prototype.gl = function() {
  const e = this._rgb;
  return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]];
};
Ue.prototype.hex = function(e) {
  return hy(this._rgb, e);
};
const px = (...e) => new Ue(...e, "hex");
dt.hex = px;
it.format.hex = py;
it.autodetect.push({
  p: 4,
  test: (e, ...t) => {
    if (!t.length && ut(e) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(e.length) >= 0)
      return "hex";
  }
});
const { log: ta } = Math, Dy = (e) => {
  const t = e / 100;
  let r, o, n;
  return t < 66 ? (r = 255, o = t < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (o = t - 2) + 104.49216199393888 * ta(o), n = t < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (n = t - 10) + 115.67994401066147 * ta(n)) : (r = 351.97690566805693 + 0.114206453784165 * (r = t - 55) - 40.25366309332127 * ta(r), o = 325.4494125711974 + 0.07943456536662342 * (o = t - 50) - 28.0852963507957 * ta(o), n = 255), [r, o, n, 1];
}, { round: hx } = Math, yx = (...e) => {
  const t = lt(e, "rgb"), r = t[0], o = t[2];
  let n = 1e3, i = 4e4;
  const a = 0.4;
  let s;
  for (; i - n > a; ) {
    s = (i + n) * 0.5;
    const c = Dy(s);
    c[2] / c[0] >= o / r ? i = s : n = s;
  }
  return hx(s);
};
Ue.prototype.temp = Ue.prototype.kelvin = Ue.prototype.temperature = function() {
  return yx(this._rgb);
};
const hl = (...e) => new Ue(...e, "temp");
Object.assign(dt, { temp: hl, kelvin: hl, temperature: hl });
it.format.temp = it.format.kelvin = it.format.temperature = Dy;
Ue.prototype.oklch = function() {
  return xy(this._rgb);
};
const mx = (...e) => new Ue(...e, "oklch");
Object.assign(dt, { oklch: mx });
it.format.oklch = Ry;
it.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = lt(e, "oklch"), ut(e) === "array" && e.length === 3)
      return "oklch";
  }
});
Object.assign(dt, {
  analyze: Ey,
  average: gT,
  bezier: ST,
  blend: Or,
  brewer: tx,
  Color: Ue,
  colors: fo,
  contrast: WT,
  contrastAPCA: qT,
  cubehelix: MT,
  deltaE: XT,
  distance: QT,
  input: it,
  interpolate: po,
  limits: Sy,
  mix: po,
  random: $T,
  scale: Ha,
  scales: ex,
  valid: JT
});
function By(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: gx } = Object.prototype, { getPrototypeOf: mu } = Object, xs = /* @__PURE__ */ ((e) => (t) => {
  const r = gx.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Yr = (e) => (e = e.toLowerCase(), (t) => xs(t) === e), Rs = (e) => (t) => typeof t === e, { isArray: Ro } = Array, gi = Rs("undefined");
function bx(e) {
  return e !== null && !gi(e) && e.constructor !== null && !gi(e.constructor) && vr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const $y = Yr("ArrayBuffer");
function vx(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && $y(e.buffer), t;
}
const _x = Rs("string"), vr = Rs("function"), Uy = Rs("number"), Os = (e) => e !== null && typeof e == "object", wx = (e) => e === !0 || e === !1, va = (e) => {
  if (xs(e) !== "object")
    return !1;
  const t = mu(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, Ex = Yr("Date"), Sx = Yr("File"), Tx = Yr("Blob"), xx = Yr("FileList"), Rx = (e) => Os(e) && vr(e.pipe), Ox = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || vr(e.append) && ((t = xs(e)) === "formdata" || // detect form-data instance
  t === "object" && vr(e.toString) && e.toString() === "[object FormData]"));
}, Ax = Yr("URLSearchParams"), kx = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ci(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let o, n;
  if (typeof e != "object" && (e = [e]), Ro(e))
    for (o = 0, n = e.length; o < n; o++)
      t.call(null, e[o], o, e);
  else {
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), a = i.length;
    let s;
    for (o = 0; o < a; o++)
      s = i[o], t.call(null, e[s], s, e);
  }
}
function zy(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let o = r.length, n;
  for (; o-- > 0; )
    if (n = r[o], t === n.toLowerCase())
      return n;
  return null;
}
const Hy = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Wy = (e) => !gi(e) && e !== Hy;
function Kl() {
  const { caseless: e } = Wy(this) && this || {}, t = {}, r = (o, n) => {
    const i = e && zy(t, n) || n;
    va(t[i]) && va(o) ? t[i] = Kl(t[i], o) : va(o) ? t[i] = Kl({}, o) : Ro(o) ? t[i] = o.slice() : t[i] = o;
  };
  for (let o = 0, n = arguments.length; o < n; o++)
    arguments[o] && Ci(arguments[o], r);
  return t;
}
const Cx = (e, t, r, { allOwnKeys: o } = {}) => (Ci(t, (n, i) => {
  r && vr(n) ? e[i] = By(n, r) : e[i] = n;
}, { allOwnKeys: o }), e), Px = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Ix = (e, t, r, o) => {
  e.prototype = Object.create(t.prototype, o), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, Nx = (e, t, r, o) => {
  let n, i, a;
  const s = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (n = Object.getOwnPropertyNames(e), i = n.length; i-- > 0; )
      a = n[i], (!o || o(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
    e = r !== !1 && mu(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, Lx = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const o = e.indexOf(t, r);
  return o !== -1 && o === r;
}, jx = (e) => {
  if (!e)
    return null;
  if (Ro(e))
    return e;
  let t = e.length;
  if (!Uy(t))
    return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, Mx = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && mu(Uint8Array)), Fx = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let o;
  for (; (o = r.next()) && !o.done; ) {
    const n = o.value;
    t.call(e, n[0], n[1]);
  }
}, Dx = (e, t) => {
  let r;
  const o = [];
  for (; (r = e.exec(t)) !== null; )
    o.push(r);
  return o;
}, Bx = Yr("HTMLFormElement"), $x = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, o) {
    return r.toUpperCase() + o;
  }
), Cd = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), Ux = Yr("RegExp"), Vy = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), o = {};
  Ci(r, (n, i) => {
    let a;
    (a = t(n, i, e)) !== !1 && (o[i] = a || n);
  }), Object.defineProperties(e, o);
}, zx = (e) => {
  Vy(e, (t, r) => {
    if (vr(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const o = e[r];
    if (vr(o)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, Hx = (e, t) => {
  const r = {}, o = (n) => {
    n.forEach((i) => {
      r[i] = !0;
    });
  };
  return Ro(e) ? o(e) : o(String(e).split(t)), r;
}, Wx = () => {
}, Vx = (e, t) => (e = +e, Number.isFinite(e) ? e : t), yl = "abcdefghijklmnopqrstuvwxyz", Pd = "0123456789", Zy = {
  DIGIT: Pd,
  ALPHA: yl,
  ALPHA_DIGIT: yl + yl.toUpperCase() + Pd
}, Zx = (e = 16, t = Zy.ALPHA_DIGIT) => {
  let r = "";
  const { length: o } = t;
  for (; e--; )
    r += t[Math.random() * o | 0];
  return r;
};
function qx(e) {
  return !!(e && vr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Yx = (e) => {
  const t = new Array(10), r = (o, n) => {
    if (Os(o)) {
      if (t.indexOf(o) >= 0)
        return;
      if (!("toJSON" in o)) {
        t[n] = o;
        const i = Ro(o) ? [] : {};
        return Ci(o, (a, s) => {
          const c = r(a, n + 1);
          !gi(c) && (i[s] = c);
        }), t[n] = void 0, i;
      }
    }
    return o;
  };
  return r(e, 0);
}, Gx = Yr("AsyncFunction"), Kx = (e) => e && (Os(e) || vr(e)) && vr(e.then) && vr(e.catch), Me = {
  isArray: Ro,
  isArrayBuffer: $y,
  isBuffer: bx,
  isFormData: Ox,
  isArrayBufferView: vx,
  isString: _x,
  isNumber: Uy,
  isBoolean: wx,
  isObject: Os,
  isPlainObject: va,
  isUndefined: gi,
  isDate: Ex,
  isFile: Sx,
  isBlob: Tx,
  isRegExp: Ux,
  isFunction: vr,
  isStream: Rx,
  isURLSearchParams: Ax,
  isTypedArray: Mx,
  isFileList: xx,
  forEach: Ci,
  merge: Kl,
  extend: Cx,
  trim: kx,
  stripBOM: Px,
  inherits: Ix,
  toFlatObject: Nx,
  kindOf: xs,
  kindOfTest: Yr,
  endsWith: Lx,
  toArray: jx,
  forEachEntry: Fx,
  matchAll: Dx,
  isHTMLForm: Bx,
  hasOwnProperty: Cd,
  hasOwnProp: Cd,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Vy,
  freezeMethods: zx,
  toObjectSet: Hx,
  toCamelCase: $x,
  noop: Wx,
  toFiniteNumber: Vx,
  findKey: zy,
  global: Hy,
  isContextDefined: Wy,
  ALPHABET: Zy,
  generateString: Zx,
  isSpecCompliantForm: qx,
  toJSONObject: Yx,
  isAsyncFn: Gx,
  isThenable: Kx
};
function pt(e, t, r, o, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), o && (this.request = o), n && (this.response = n);
}
Me.inherits(pt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Me.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const qy = pt.prototype, Yy = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  Yy[e] = { value: e };
});
Object.defineProperties(pt, Yy);
Object.defineProperty(qy, "isAxiosError", { value: !0 });
pt.from = (e, t, r, o, n, i) => {
  const a = Object.create(qy);
  return Me.toFlatObject(e, a, function(s) {
    return s !== Error.prototype;
  }, (s) => s !== "isAxiosError"), pt.call(a, e.message, t, r, o, n), a.cause = e, a.name = e.name, i && Object.assign(a, i), a;
};
const Xx = null;
function Xl(e) {
  return Me.isPlainObject(e) || Me.isArray(e);
}
function Gy(e) {
  return Me.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Id(e, t, r) {
  return e ? e.concat(t).map(function(o, n) {
    return o = Gy(o), !r && n ? "[" + o + "]" : o;
  }).join(r ? "." : "") : t;
}
function Qx(e) {
  return Me.isArray(e) && !e.some(Xl);
}
const Jx = Me.toFlatObject(Me, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function As(e, t, r) {
  if (!Me.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = Me.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, y) {
    return !Me.isUndefined(y[h]);
  });
  const o = r.metaTokens, n = r.visitor || p, i = r.dots, a = r.indexes, s = (r.Blob || typeof Blob < "u" && Blob) && Me.isSpecCompliantForm(t);
  if (!Me.isFunction(n))
    throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null)
      return "";
    if (Me.isDate(h))
      return h.toISOString();
    if (!s && Me.isBlob(h))
      throw new pt("Blob is not supported. Use a Buffer instead.");
    return Me.isArrayBuffer(h) || Me.isTypedArray(h) ? s && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function p(h, y, f) {
    let b = h;
    if (h && !f && typeof h == "object") {
      if (Me.endsWith(y, "{}"))
        y = o ? y : y.slice(0, -2), h = JSON.stringify(h);
      else if (Me.isArray(h) && Qx(h) || (Me.isFileList(h) || Me.endsWith(y, "[]")) && (b = Me.toArray(h)))
        return y = Gy(y), b.forEach(function(w, x) {
          !(Me.isUndefined(w) || w === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? Id([y], x, i) : a === null ? y : y + "[]",
            c(w)
          );
        }), !1;
    }
    return Xl(h) ? !0 : (t.append(Id(f, y, i), c(h)), !1);
  }
  const l = [], d = Object.assign(Jx, {
    defaultVisitor: p,
    convertValue: c,
    isVisitable: Xl
  });
  function u(h, y) {
    if (!Me.isUndefined(h)) {
      if (l.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      l.push(h), Me.forEach(h, function(f, b) {
        (!(Me.isUndefined(f) || f === null) && n.call(
          t,
          f,
          Me.isString(b) ? b.trim() : b,
          y,
          d
        )) === !0 && u(f, y ? y.concat(b) : [b]);
      }), l.pop();
    }
  }
  if (!Me.isObject(e))
    throw new TypeError("data must be an object");
  return u(e), t;
}
function Nd(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function gu(e, t) {
  this._pairs = [], e && As(e, this, t);
}
const Ky = gu.prototype;
Ky.append = function(e, t) {
  this._pairs.push([e, t]);
};
Ky.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, Nd);
  } : Nd;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function eR(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Xy(e, t, r) {
  if (!t)
    return e;
  const o = r && r.encode || eR, n = r && r.serialize;
  let i;
  if (n ? i = n(t, r) : i = Me.isURLSearchParams(t) ? t.toString() : new gu(t, r).toString(o), i) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
class Ld {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, o) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: o ? o.synchronous : !1,
      runWhen: o ? o.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Me.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const Qy = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, tR = typeof URLSearchParams < "u" ? URLSearchParams : gu, rR = typeof FormData < "u" ? FormData : null, nR = typeof Blob < "u" ? Blob : null, oR = {
  isBrowser: !0,
  classes: {
    URLSearchParams: tR,
    FormData: rR,
    Blob: nR
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Jy = typeof window < "u" && typeof document < "u", iR = ((e) => Jy && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), aR = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", sR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Jy,
  hasStandardBrowserEnv: iR,
  hasStandardBrowserWebWorkerEnv: aR
}, Symbol.toStringTag, { value: "Module" })), Dr = {
  ...sR,
  ...oR
};
function lR(e, t) {
  return As(e, new Dr.classes.URLSearchParams(), Object.assign({
    visitor: function(r, o, n, i) {
      return Dr.isNode && Me.isBuffer(r) ? (this.append(o, r.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function cR(e) {
  return Me.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function uR(e) {
  const t = {}, r = Object.keys(e);
  let o;
  const n = r.length;
  let i;
  for (o = 0; o < n; o++)
    i = r[o], t[i] = e[i];
  return t;
}
function em(e) {
  function t(r, o, n, i) {
    let a = r[i++];
    if (a === "__proto__")
      return !0;
    const s = Number.isFinite(+a), c = i >= r.length;
    return a = !a && Me.isArray(n) ? n.length : a, c ? (Me.hasOwnProp(n, a) ? n[a] = [n[a], o] : n[a] = o, !s) : ((!n[a] || !Me.isObject(n[a])) && (n[a] = []), t(r, o, n[a], i) && Me.isArray(n[a]) && (n[a] = uR(n[a])), !s);
  }
  if (Me.isFormData(e) && Me.isFunction(e.entries)) {
    const r = {};
    return Me.forEachEntry(e, (o, n) => {
      t(cR(o), n, r, 0);
    }), r;
  }
  return null;
}
function fR(e, t, r) {
  if (Me.isString(e))
    try {
      return (t || JSON.parse)(e), Me.trim(e);
    } catch (o) {
      if (o.name !== "SyntaxError")
        throw o;
    }
  return (0, JSON.stringify)(e);
}
const bu = {
  transitional: Qy,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", o = r.indexOf("application/json") > -1, n = Me.isObject(e);
    if (n && Me.isHTMLForm(e) && (e = new FormData(e)), Me.isFormData(e))
      return o ? JSON.stringify(em(e)) : e;
    if (Me.isArrayBuffer(e) || Me.isBuffer(e) || Me.isStream(e) || Me.isFile(e) || Me.isBlob(e))
      return e;
    if (Me.isArrayBufferView(e))
      return e.buffer;
    if (Me.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let i;
    if (n) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return lR(e, this.formSerializer).toString();
      if ((i = Me.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const a = this.env && this.env.FormData;
        return As(
          i ? { "files[]": e } : e,
          a && new a(),
          this.formSerializer
        );
      }
    }
    return n || o ? (t.setContentType("application/json", !1), fR(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || bu.transitional, r = t && t.forcedJSONParsing, o = this.responseType === "json";
    if (e && Me.isString(e) && (r && !this.responseType || o)) {
      const n = !(t && t.silentJSONParsing) && o;
      try {
        return JSON.parse(e);
      } catch (i) {
        if (n)
          throw i.name === "SyntaxError" ? pt.from(i, pt.ERR_BAD_RESPONSE, this, null, this.response) : i;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Dr.classes.FormData,
    Blob: Dr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Me.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  bu.headers[e] = {};
});
const vu = bu, dR = Me.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), pR = (e) => {
  const t = {};
  let r, o, n;
  return e && e.split(`
`).forEach(function(i) {
    n = i.indexOf(":"), r = i.substring(0, n).trim().toLowerCase(), o = i.substring(n + 1).trim(), !(!r || t[r] && dR[r]) && (r === "set-cookie" ? t[r] ? t[r].push(o) : t[r] = [o] : t[r] = t[r] ? t[r] + ", " + o : o);
  }), t;
}, jd = Symbol("internals");
function $o(e) {
  return e && String(e).trim().toLowerCase();
}
function _a(e) {
  return e === !1 || e == null ? e : Me.isArray(e) ? e.map(_a) : String(e);
}
function hR(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let o;
  for (; o = r.exec(e); )
    t[o[1]] = o[2];
  return t;
}
const yR = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function ml(e, t, r, o, n) {
  if (Me.isFunction(o))
    return o.call(this, t, r);
  if (n && (t = r), !!Me.isString(t)) {
    if (Me.isString(o))
      return t.indexOf(o) !== -1;
    if (Me.isRegExp(o))
      return o.test(t);
  }
}
function mR(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, o) => r.toUpperCase() + o);
}
function gR(e, t) {
  const r = Me.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((o) => {
    Object.defineProperty(e, o + r, {
      value: function(n, i, a) {
        return this[o].call(this, t, n, i, a);
      },
      configurable: !0
    });
  });
}
class ks {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, o) {
    const n = this;
    function i(s, c, p) {
      const l = $o(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = Me.findKey(n, l);
      (!d || n[d] === void 0 || p === !0 || p === void 0 && n[d] !== !1) && (n[d || c] = _a(s));
    }
    const a = (s, c) => Me.forEach(s, (p, l) => i(p, l, c));
    return Me.isPlainObject(t) || t instanceof this.constructor ? a(t, r) : Me.isString(t) && (t = t.trim()) && !yR(t) ? a(pR(t), r) : t != null && i(r, t, o), this;
  }
  get(t, r) {
    if (t = $o(t), t) {
      const o = Me.findKey(this, t);
      if (o) {
        const n = this[o];
        if (!r)
          return n;
        if (r === !0)
          return hR(n);
        if (Me.isFunction(r))
          return r.call(this, n, o);
        if (Me.isRegExp(r))
          return r.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = $o(t), t) {
      const o = Me.findKey(this, t);
      return !!(o && this[o] !== void 0 && (!r || ml(this, this[o], o, r)));
    }
    return !1;
  }
  delete(t, r) {
    const o = this;
    let n = !1;
    function i(a) {
      if (a = $o(a), a) {
        const s = Me.findKey(o, a);
        s && (!r || ml(o, o[s], s, r)) && (delete o[s], n = !0);
      }
    }
    return Me.isArray(t) ? t.forEach(i) : i(t), n;
  }
  clear(t) {
    const r = Object.keys(this);
    let o = r.length, n = !1;
    for (; o--; ) {
      const i = r[o];
      (!t || ml(this, this[i], i, t, !0)) && (delete this[i], n = !0);
    }
    return n;
  }
  normalize(t) {
    const r = this, o = {};
    return Me.forEach(this, (n, i) => {
      const a = Me.findKey(o, i);
      if (a) {
        r[a] = _a(n), delete r[i];
        return;
      }
      const s = t ? mR(i) : String(i).trim();
      s !== i && delete r[i], r[s] = _a(n), o[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return Me.forEach(this, (o, n) => {
      o != null && o !== !1 && (r[n] = t && Me.isArray(o) ? o.join(", ") : o);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const o = new this(t);
    return r.forEach((n) => o.set(n)), o;
  }
  static accessor(t) {
    const r = (this[jd] = this[jd] = {
      accessors: {}
    }).accessors, o = this.prototype;
    function n(i) {
      const a = $o(i);
      r[a] || (gR(o, i), r[a] = !0);
    }
    return Me.isArray(t) ? t.forEach(n) : n(t), this;
  }
}
ks.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Me.reduceDescriptors(ks.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(o) {
      this[r] = o;
    }
  };
});
Me.freezeMethods(ks);
const on = ks;
function gl(e, t) {
  const r = this || vu, o = t || r, n = on.from(o.headers);
  let i = o.data;
  return Me.forEach(e, function(a) {
    i = a.call(r, i, n.normalize(), t ? t.status : void 0);
  }), n.normalize(), i;
}
function tm(e) {
  return !!(e && e.__CANCEL__);
}
function Pi(e, t, r) {
  pt.call(this, e ?? "canceled", pt.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Me.inherits(Pi, pt, {
  __CANCEL__: !0
});
function bR(e, t, r) {
  const o = r.config.validateStatus;
  !r.status || !o || o(r.status) ? e(r) : t(new pt(
    "Request failed with status code " + r.status,
    [pt.ERR_BAD_REQUEST, pt.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
const vR = Dr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, o, n, i) {
      const a = [e + "=" + encodeURIComponent(t)];
      Me.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), Me.isString(o) && a.push("path=" + o), Me.isString(n) && a.push("domain=" + n), i === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function _R(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function wR(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function rm(e, t) {
  return e && !_R(t) ? wR(e, t) : t;
}
const ER = Dr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a");
    let r;
    function o(n) {
      let i = n;
      return e && (t.setAttribute("href", i), i = t.href), t.setAttribute("href", i), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return r = o(window.location.href), function(n) {
      const i = Me.isString(n) ? o(n) : n;
      return i.protocol === r.protocol && i.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function SR(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function TR(e, t) {
  e = e || 10;
  const r = new Array(e), o = new Array(e);
  let n = 0, i = 0, a;
  return t = t !== void 0 ? t : 1e3, function(s) {
    const c = Date.now(), p = o[i];
    a || (a = c), r[n] = s, o[n] = c;
    let l = i, d = 0;
    for (; l !== n; )
      d += r[l++], l = l % e;
    if (n = (n + 1) % e, n === i && (i = (i + 1) % e), c - a < t)
      return;
    const u = p && c - p;
    return u ? Math.round(d * 1e3 / u) : void 0;
  };
}
function Md(e, t) {
  let r = 0;
  const o = TR(50, 250);
  return (n) => {
    const i = n.loaded, a = n.lengthComputable ? n.total : void 0, s = i - r, c = o(s), p = i <= a;
    r = i;
    const l = {
      loaded: i,
      total: a,
      progress: a ? i / a : void 0,
      bytes: s,
      rate: c || void 0,
      estimated: c && a && p ? (a - i) / c : void 0,
      event: n
    };
    l[t ? "download" : "upload"] = !0, e(l);
  };
}
const xR = typeof XMLHttpRequest < "u", RR = xR && function(e) {
  return new Promise(function(t, r) {
    let o = e.data;
    const n = on.from(e.headers).normalize();
    let { responseType: i, withXSRFToken: a } = e, s;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s);
    }
    let p;
    if (Me.isFormData(o)) {
      if (Dr.hasStandardBrowserEnv || Dr.hasStandardBrowserWebWorkerEnv)
        n.setContentType(!1);
      else if ((p = n.getContentType()) !== !1) {
        const [y, ...f] = p ? p.split(";").map((b) => b.trim()).filter(Boolean) : [];
        n.setContentType([y || "multipart/form-data", ...f].join("; "));
      }
    }
    let l = new XMLHttpRequest();
    if (e.auth) {
      const y = e.auth.username || "", f = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      n.set("Authorization", "Basic " + btoa(y + ":" + f));
    }
    const d = rm(e.baseURL, e.url);
    l.open(e.method.toUpperCase(), Xy(d, e.params, e.paramsSerializer), !0), l.timeout = e.timeout;
    function u() {
      if (!l)
        return;
      const y = on.from(
        "getAllResponseHeaders" in l && l.getAllResponseHeaders()
      ), f = {
        data: !i || i === "text" || i === "json" ? l.responseText : l.response,
        status: l.status,
        statusText: l.statusText,
        headers: y,
        config: e,
        request: l
      };
      bR(function(b) {
        t(b), c();
      }, function(b) {
        r(b), c();
      }, f), l = null;
    }
    if ("onloadend" in l ? l.onloadend = u : l.onreadystatechange = function() {
      !l || l.readyState !== 4 || l.status === 0 && !(l.responseURL && l.responseURL.indexOf("file:") === 0) || setTimeout(u);
    }, l.onabort = function() {
      l && (r(new pt("Request aborted", pt.ECONNABORTED, e, l)), l = null);
    }, l.onerror = function() {
      r(new pt("Network Error", pt.ERR_NETWORK, e, l)), l = null;
    }, l.ontimeout = function() {
      let y = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const f = e.transitional || Qy;
      e.timeoutErrorMessage && (y = e.timeoutErrorMessage), r(new pt(
        y,
        f.clarifyTimeoutError ? pt.ETIMEDOUT : pt.ECONNABORTED,
        e,
        l
      )), l = null;
    }, Dr.hasStandardBrowserEnv && (a && Me.isFunction(a) && (a = a(e)), a || a !== !1 && ER(d))) {
      const y = e.xsrfHeaderName && e.xsrfCookieName && vR.read(e.xsrfCookieName);
      y && n.set(e.xsrfHeaderName, y);
    }
    o === void 0 && n.setContentType(null), "setRequestHeader" in l && Me.forEach(n.toJSON(), function(y, f) {
      l.setRequestHeader(f, y);
    }), Me.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), i && i !== "json" && (l.responseType = e.responseType), typeof e.onDownloadProgress == "function" && l.addEventListener("progress", Md(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", Md(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = (y) => {
      l && (r(!y || y.type ? new Pi(null, e, l) : y), l.abort(), l = null);
    }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
    const h = SR(d);
    if (h && Dr.protocols.indexOf(h) === -1) {
      r(new pt("Unsupported protocol " + h + ":", pt.ERR_BAD_REQUEST, e));
      return;
    }
    l.send(o || null);
  });
}, Ql = {
  http: Xx,
  xhr: RR
};
Me.forEach(Ql, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Fd = (e) => `- ${e}`, OR = (e) => Me.isFunction(e) || e === null || e === !1, nm = {
  getAdapter: (e) => {
    e = Me.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, o;
    const n = {};
    for (let i = 0; i < t; i++) {
      r = e[i];
      let a;
      if (o = r, !OR(r) && (o = Ql[(a = String(r)).toLowerCase()], o === void 0))
        throw new pt(`Unknown adapter '${a}'`);
      if (o)
        break;
      n[a || "#" + i] = o;
    }
    if (!o) {
      const i = Object.entries(n).map(
        ([s, c]) => `adapter ${s} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = t ? i.length > 1 ? `since :
` + i.map(Fd).join(`
`) : " " + Fd(i[0]) : "as no adapter specified";
      throw new pt(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return o;
  },
  adapters: Ql
};
function bl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Pi(null, e);
}
function Dd(e) {
  return bl(e), e.headers = on.from(e.headers), e.data = gl.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), nm.getAdapter(e.adapter || vu.adapter)(e).then(function(t) {
    return bl(e), t.data = gl.call(
      e,
      e.transformResponse,
      t
    ), t.headers = on.from(t.headers), t;
  }, function(t) {
    return tm(t) || (bl(e), t && t.response && (t.response.data = gl.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = on.from(t.response.headers))), Promise.reject(t);
  });
}
const Bd = (e) => e instanceof on ? e.toJSON() : e;
function ho(e, t) {
  t = t || {};
  const r = {};
  function o(p, l, d) {
    return Me.isPlainObject(p) && Me.isPlainObject(l) ? Me.merge.call({ caseless: d }, p, l) : Me.isPlainObject(l) ? Me.merge({}, l) : Me.isArray(l) ? l.slice() : l;
  }
  function n(p, l, d) {
    if (Me.isUndefined(l)) {
      if (!Me.isUndefined(p))
        return o(void 0, p, d);
    } else
      return o(p, l, d);
  }
  function i(p, l) {
    if (!Me.isUndefined(l))
      return o(void 0, l);
  }
  function a(p, l) {
    if (Me.isUndefined(l)) {
      if (!Me.isUndefined(p))
        return o(void 0, p);
    } else
      return o(void 0, l);
  }
  function s(p, l, d) {
    if (d in t)
      return o(p, l);
    if (d in e)
      return o(void 0, p);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: s,
    headers: (p, l) => n(Bd(p), Bd(l), !0)
  };
  return Me.forEach(Object.keys(Object.assign({}, e, t)), function(p) {
    const l = c[p] || n, d = l(e[p], t[p], p);
    Me.isUndefined(d) && l !== s || (r[p] = d);
  }), r;
}
const om = "1.6.7", _u = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  _u[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const $d = {};
_u.transitional = function(e, t, r) {
  function o(n, i) {
    return "[Axios v" + om + "] Transitional option '" + n + "'" + i + (r ? ". " + r : "");
  }
  return (n, i, a) => {
    if (e === !1)
      throw new pt(
        o(i, " has been removed" + (t ? " in " + t : "")),
        pt.ERR_DEPRECATED
      );
    return t && !$d[i] && ($d[i] = !0, console.warn(
      o(
        i,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(n, i, a) : !0;
  };
};
function AR(e, t, r) {
  if (typeof e != "object")
    throw new pt("options must be an object", pt.ERR_BAD_OPTION_VALUE);
  const o = Object.keys(e);
  let n = o.length;
  for (; n-- > 0; ) {
    const i = o[n], a = t[i];
    if (a) {
      const s = e[i], c = s === void 0 || a(s, i, e);
      if (c !== !0)
        throw new pt("option " + i + " must be " + c, pt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new pt("Unknown option " + i, pt.ERR_BAD_OPTION);
  }
}
const Jl = {
  assertOptions: AR,
  validators: _u
}, un = Jl.validators;
class Va {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Ld(),
      response: new Ld()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (o) {
      if (o instanceof Error) {
        let n;
        Error.captureStackTrace ? Error.captureStackTrace(n = {}) : n = new Error();
        const i = n.stack ? n.stack.replace(/^.+\n/, "") : "";
        o.stack ? i && !String(o.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (o.stack += `
` + i) : o.stack = i;
      }
      throw o;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = ho(this.defaults, r);
    const { transitional: o, paramsSerializer: n, headers: i } = r;
    o !== void 0 && Jl.assertOptions(o, {
      silentJSONParsing: un.transitional(un.boolean),
      forcedJSONParsing: un.transitional(un.boolean),
      clarifyTimeoutError: un.transitional(un.boolean)
    }, !1), n != null && (Me.isFunction(n) ? r.paramsSerializer = {
      serialize: n
    } : Jl.assertOptions(n, {
      encode: un.function,
      serialize: un.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let a = i && Me.merge(
      i.common,
      i[r.method]
    );
    i && Me.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete i[y];
      }
    ), r.headers = on.concat(a, i);
    const s = [];
    let c = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === !1 || (c = c && y.synchronous, s.unshift(y.fulfilled, y.rejected));
    });
    const p = [];
    this.interceptors.response.forEach(function(y) {
      p.push(y.fulfilled, y.rejected);
    });
    let l, d = 0, u;
    if (!c) {
      const y = [Dd.bind(this), void 0];
      for (y.unshift.apply(y, s), y.push.apply(y, p), u = y.length, l = Promise.resolve(r); d < u; )
        l = l.then(y[d++], y[d++]);
      return l;
    }
    u = s.length;
    let h = r;
    for (d = 0; d < u; ) {
      const y = s[d++], f = s[d++];
      try {
        h = y(h);
      } catch (b) {
        f.call(this, b);
        break;
      }
    }
    try {
      l = Dd.call(this, h);
    } catch (y) {
      return Promise.reject(y);
    }
    for (d = 0, u = p.length; d < u; )
      l = l.then(p[d++], p[d++]);
    return l;
  }
  getUri(t) {
    t = ho(this.defaults, t);
    const r = rm(t.baseURL, t.url);
    return Xy(r, t.params, t.paramsSerializer);
  }
}
Me.forEach(["delete", "get", "head", "options"], function(e) {
  Va.prototype[e] = function(t, r) {
    return this.request(ho(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
Me.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(o, n, i) {
      return this.request(ho(i || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: n
      }));
    };
  }
  Va.prototype[e] = t(), Va.prototype[e + "Form"] = t(!0);
});
const wa = Va;
class wu {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(n) {
      r = n;
    });
    const o = this;
    this.promise.then((n) => {
      if (!o._listeners)
        return;
      let i = o._listeners.length;
      for (; i-- > 0; )
        o._listeners[i](n);
      o._listeners = null;
    }), this.promise.then = (n) => {
      let i;
      const a = new Promise((s) => {
        o.subscribe(s), i = s;
      }).then(n);
      return a.cancel = function() {
        o.unsubscribe(i);
      }, a;
    }, t(function(n, i, a) {
      o.reason || (o.reason = new Pi(n, i, a), r(o.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new wu(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
}
const kR = wu;
function CR(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function PR(e) {
  return Me.isObject(e) && e.isAxiosError === !0;
}
const ec = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(ec).forEach(([e, t]) => {
  ec[t] = e;
});
const IR = ec;
function im(e) {
  const t = new wa(e), r = By(wa.prototype.request, t);
  return Me.extend(r, wa.prototype, t, { allOwnKeys: !0 }), Me.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(o) {
    return im(ho(e, o));
  }, r;
}
const Ht = im(vu);
Ht.Axios = wa;
Ht.CanceledError = Pi;
Ht.CancelToken = kR;
Ht.isCancel = tm;
Ht.VERSION = om;
Ht.toFormData = As;
Ht.AxiosError = pt;
Ht.Cancel = Ht.CanceledError;
Ht.all = function(e) {
  return Promise.all(e);
};
Ht.spread = CR;
Ht.isAxiosError = PR;
Ht.mergeConfig = ho;
Ht.AxiosHeaders = on;
Ht.formToJSON = (e) => em(Me.isHTMLForm(e) ? new FormData(e) : e);
Ht.getAdapter = nm.getAdapter;
Ht.HttpStatusCode = IR;
Ht.default = Ht;
var Gt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ra(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var NR = { exports: {} };
(function(e, t) {
  (function(r) {
    e.exports = r();
  })(function() {
    return (/* @__PURE__ */ function() {
      function r(o, n, i) {
        function a(p, l) {
          if (!n[p]) {
            if (!o[p]) {
              var d = typeof ra == "function" && ra;
              if (!l && d)
                return d(p, !0);
              if (s)
                return s(p, !0);
              var u = new Error("Cannot find module '" + p + "'");
              throw u.code = "MODULE_NOT_FOUND", u;
            }
            var h = n[p] = { exports: {} };
            o[p][0].call(h.exports, function(y) {
              var f = o[p][1][y];
              return a(f || y);
            }, h, h.exports, r, o, n, i);
          }
          return n[p].exports;
        }
        for (var s = typeof ra == "function" && ra, c = 0; c < i.length; c++)
          a(i[c]);
        return a;
      }
      return r;
    }())({ 1: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./interlace"), s = [
            // 0 - dummy entry
            function() {
            },
            // 1 - L
            // 0: 0, 1: 0, 2: 0, 3: 0xff
            function(u, h, y, f) {
              if (f === h.length)
                throw new Error("Ran out of data");
              let b = h[f];
              u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = 255;
            },
            // 2 - LA
            // 0: 0, 1: 0, 2: 0, 3: 1
            function(u, h, y, f) {
              if (f + 1 >= h.length)
                throw new Error("Ran out of data");
              let b = h[f];
              u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = h[f + 1];
            },
            // 3 - RGB
            // 0: 0, 1: 1, 2: 2, 3: 0xff
            function(u, h, y, f) {
              if (f + 2 >= h.length)
                throw new Error("Ran out of data");
              u[y] = h[f], u[y + 1] = h[f + 1], u[y + 2] = h[f + 2], u[y + 3] = 255;
            },
            // 4 - RGBA
            // 0: 0, 1: 1, 2: 2, 3: 3
            function(u, h, y, f) {
              if (f + 3 >= h.length)
                throw new Error("Ran out of data");
              u[y] = h[f], u[y + 1] = h[f + 1], u[y + 2] = h[f + 2], u[y + 3] = h[f + 3];
            }
          ], c = [
            // 0 - dummy entry
            function() {
            },
            // 1 - L
            // 0: 0, 1: 0, 2: 0, 3: 0xff
            function(u, h, y, f) {
              let b = h[0];
              u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = f;
            },
            // 2 - LA
            // 0: 0, 1: 0, 2: 0, 3: 1
            function(u, h, y) {
              let f = h[0];
              u[y] = f, u[y + 1] = f, u[y + 2] = f, u[y + 3] = h[1];
            },
            // 3 - RGB
            // 0: 0, 1: 1, 2: 2, 3: 0xff
            function(u, h, y, f) {
              u[y] = h[0], u[y + 1] = h[1], u[y + 2] = h[2], u[y + 3] = f;
            },
            // 4 - RGBA
            // 0: 0, 1: 1, 2: 2, 3: 3
            function(u, h, y) {
              u[y] = h[0], u[y + 1] = h[1], u[y + 2] = h[2], u[y + 3] = h[3];
            }
          ];
          function p(u, h) {
            let y = [], f = 0;
            function b() {
              if (f === u.length)
                throw new Error("Ran out of data");
              let w = u[f];
              f++;
              let x, E, T, C, R, A, j, N;
              switch (h) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  j = u[f], f++, y.push((w << 8) + j);
                  break;
                case 4:
                  j = w & 15, N = w >> 4, y.push(N, j);
                  break;
                case 2:
                  R = w & 3, A = w >> 2 & 3, j = w >> 4 & 3, N = w >> 6 & 3, y.push(N, j, A, R);
                  break;
                case 1:
                  x = w & 1, E = w >> 1 & 1, T = w >> 2 & 1, C = w >> 3 & 1, R = w >> 4 & 1, A = w >> 5 & 1, j = w >> 6 & 1, N = w >> 7 & 1, y.push(N, j, A, R, C, T, E, x);
                  break;
              }
            }
            return {
              get: function(w) {
                for (; y.length < w; )
                  b();
                let x = y.slice(0, w);
                return y = y.slice(w), x;
              },
              resetAfterLine: function() {
                y.length = 0;
              },
              end: function() {
                if (f !== u.length)
                  throw new Error("extra data found");
              }
            };
          }
          function l(u, h, y, f, b, w) {
            let x = u.width, E = u.height, T = u.index;
            for (let C = 0; C < E; C++)
              for (let R = 0; R < x; R++) {
                let A = y(R, C, T);
                s[f](h, b, A, w), w += f;
              }
            return w;
          }
          function d(u, h, y, f, b, w) {
            let x = u.width, E = u.height, T = u.index;
            for (let C = 0; C < E; C++) {
              for (let R = 0; R < x; R++) {
                let A = b.get(f), j = y(R, C, T);
                c[f](h, A, j, w);
              }
              b.resetAfterLine();
            }
          }
          n.dataToBitMap = function(u, h) {
            let y = h.width, f = h.height, b = h.depth, w = h.bpp, x = h.interlace, E;
            b !== 8 && (E = p(u, b));
            let T;
            b <= 8 ? T = i.alloc(y * f * 4) : T = new Uint16Array(y * f * 4);
            let C = Math.pow(2, b) - 1, R = 0, A, j;
            if (x)
              A = a.getImagePasses(y, f), j = a.getInterlaceIterator(y, f);
            else {
              let N = 0;
              j = function() {
                let O = N;
                return N += 4, O;
              }, A = [{ width: y, height: f }];
            }
            for (let N = 0; N < A.length; N++)
              b === 8 ? R = l(
                A[N],
                T,
                j,
                w,
                u,
                R
              ) : d(
                A[N],
                T,
                j,
                w,
                E,
                C
              );
            if (b === 8) {
              if (R !== u.length)
                throw new Error("extra data found");
            } else
              E.end();
            return T;
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./interlace": 11, buffer: 32 }], 2: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./constants");
          o.exports = function(s, c, p, l) {
            let d = [a.COLORTYPE_COLOR_ALPHA, a.COLORTYPE_ALPHA].indexOf(
              l.colorType
            ) !== -1;
            if (l.colorType === l.inputColorType) {
              let C = function() {
                let R = new ArrayBuffer(2);
                return new DataView(R).setInt16(
                  0,
                  256,
                  !0
                  /* littleEndian */
                ), new Int16Array(R)[0] !== 256;
              }();
              if (l.bitDepth === 8 || l.bitDepth === 16 && C)
                return s;
            }
            let u = l.bitDepth !== 16 ? s : new Uint16Array(s.buffer), h = 255, y = a.COLORTYPE_TO_BPP_MAP[l.inputColorType];
            y === 4 && !l.inputHasAlpha && (y = 3);
            let f = a.COLORTYPE_TO_BPP_MAP[l.colorType];
            l.bitDepth === 16 && (h = 65535, f *= 2);
            let b = i.alloc(c * p * f), w = 0, x = 0, E = l.bgColor || {};
            E.red === void 0 && (E.red = h), E.green === void 0 && (E.green = h), E.blue === void 0 && (E.blue = h);
            function T() {
              let C, R, A, j = h;
              switch (l.inputColorType) {
                case a.COLORTYPE_COLOR_ALPHA:
                  j = u[w + 3], C = u[w], R = u[w + 1], A = u[w + 2];
                  break;
                case a.COLORTYPE_COLOR:
                  C = u[w], R = u[w + 1], A = u[w + 2];
                  break;
                case a.COLORTYPE_ALPHA:
                  j = u[w + 1], C = u[w], R = C, A = C;
                  break;
                case a.COLORTYPE_GRAYSCALE:
                  C = u[w], R = C, A = C;
                  break;
                default:
                  throw new Error(
                    "input color type:" + l.inputColorType + " is not supported at present"
                  );
              }
              return l.inputHasAlpha && (d || (j /= h, C = Math.min(
                Math.max(Math.round((1 - j) * E.red + j * C), 0),
                h
              ), R = Math.min(
                Math.max(Math.round((1 - j) * E.green + j * R), 0),
                h
              ), A = Math.min(
                Math.max(Math.round((1 - j) * E.blue + j * A), 0),
                h
              ))), { red: C, green: R, blue: A, alpha: j };
            }
            for (let C = 0; C < p; C++)
              for (let R = 0; R < c; R++) {
                let A = T();
                switch (l.colorType) {
                  case a.COLORTYPE_COLOR_ALPHA:
                  case a.COLORTYPE_COLOR:
                    l.bitDepth === 8 ? (b[x] = A.red, b[x + 1] = A.green, b[x + 2] = A.blue, d && (b[x + 3] = A.alpha)) : (b.writeUInt16BE(A.red, x), b.writeUInt16BE(A.green, x + 2), b.writeUInt16BE(A.blue, x + 4), d && b.writeUInt16BE(A.alpha, x + 6));
                    break;
                  case a.COLORTYPE_ALPHA:
                  case a.COLORTYPE_GRAYSCALE: {
                    let j = (A.red + A.green + A.blue) / 3;
                    l.bitDepth === 8 ? (b[x] = j, d && (b[x + 1] = A.alpha)) : (b.writeUInt16BE(j, x), d && b.writeUInt16BE(A.alpha, x + 2));
                    break;
                  }
                  default:
                    throw new Error("unrecognised color Type " + l.colorType);
                }
                w += y, x += f;
              }
            return b;
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./constants": 4, buffer: 32 }], 3: [function(r, o, n) {
      (function(i, a) {
        (function() {
          let s = r("util"), c = r("stream"), p = o.exports = function() {
            c.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
          };
          s.inherits(p, c), p.prototype.read = function(l, d) {
            this._reads.push({
              length: Math.abs(l),
              // if length < 0 then at most this length
              allowLess: l < 0,
              func: d
            }), i.nextTick(
              (function() {
                this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
              }).bind(this)
            );
          }, p.prototype.write = function(l, d) {
            if (!this.writable)
              return this.emit("error", new Error("Stream not writable")), !1;
            let u;
            return a.isBuffer(l) ? u = l : u = a.from(l, d || this._encoding), this._buffers.push(u), this._buffered += u.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
          }, p.prototype.end = function(l, d) {
            l && this.write(l, d), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
          }, p.prototype.destroySoon = p.prototype.end, p.prototype._end = function() {
            this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
          }, p.prototype.destroy = function() {
            this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
          }, p.prototype._processReadAllowingLess = function(l) {
            this._reads.shift();
            let d = this._buffers[0];
            d.length > l.length ? (this._buffered -= l.length, this._buffers[0] = d.slice(l.length), l.func.call(this, d.slice(0, l.length))) : (this._buffered -= d.length, this._buffers.shift(), l.func.call(this, d));
          }, p.prototype._processRead = function(l) {
            this._reads.shift();
            let d = 0, u = 0, h = a.alloc(l.length);
            for (; d < l.length; ) {
              let y = this._buffers[u++], f = Math.min(y.length, l.length - d);
              y.copy(h, d, 0, f), d += f, f !== y.length && (this._buffers[--u] = y.slice(f));
            }
            u > 0 && this._buffers.splice(0, u), this._buffered -= l.length, l.func.call(this, h);
          }, p.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                let l = this._reads[0];
                if (l.allowLess)
                  this._processReadAllowingLess(l);
                else if (this._buffered >= l.length)
                  this._processRead(l);
                else
                  break;
              }
              this._buffers && !this.writable && this._end();
            } catch (l) {
              this.emit("error", l);
            }
          };
        }).call(this);
      }).call(this, r("_process"), r("buffer").Buffer);
    }, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(r, o, n) {
      o.exports = {
        PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
        TYPE_IHDR: 1229472850,
        TYPE_IEND: 1229278788,
        TYPE_IDAT: 1229209940,
        TYPE_PLTE: 1347179589,
        TYPE_tRNS: 1951551059,
        // eslint-disable-line camelcase
        TYPE_gAMA: 1732332865,
        // eslint-disable-line camelcase
        // color-type bits
        COLORTYPE_GRAYSCALE: 0,
        COLORTYPE_PALETTE: 1,
        COLORTYPE_COLOR: 2,
        COLORTYPE_ALPHA: 4,
        // e.g. grayscale and alpha
        // color-type combinations
        COLORTYPE_PALETTE_COLOR: 3,
        COLORTYPE_COLOR_ALPHA: 6,
        COLORTYPE_TO_BPP_MAP: {
          0: 1,
          2: 3,
          3: 1,
          4: 2,
          6: 4
        },
        GAMMA_DIVISION: 1e5
      };
    }, {}], 5: [function(r, o, n) {
      let i = [];
      (function() {
        for (let s = 0; s < 256; s++) {
          let c = s;
          for (let p = 0; p < 8; p++)
            c & 1 ? c = 3988292384 ^ c >>> 1 : c = c >>> 1;
          i[s] = c;
        }
      })();
      let a = o.exports = function() {
        this._crc = -1;
      };
      a.prototype.write = function(s) {
        for (let c = 0; c < s.length; c++)
          this._crc = i[(this._crc ^ s[c]) & 255] ^ this._crc >>> 8;
        return !0;
      }, a.prototype.crc32 = function() {
        return this._crc ^ -1;
      }, a.crc32 = function(s) {
        let c = -1;
        for (let p = 0; p < s.length; p++)
          c = i[(c ^ s[p]) & 255] ^ c >>> 8;
        return c ^ -1;
      };
    }, {}], 6: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./paeth-predictor");
          function s(E, T, C, R, A) {
            for (let j = 0; j < C; j++)
              R[A + j] = E[T + j];
          }
          function c(E, T, C) {
            let R = 0, A = T + C;
            for (let j = T; j < A; j++)
              R += Math.abs(E[j]);
            return R;
          }
          function p(E, T, C, R, A, j) {
            for (let N = 0; N < C; N++) {
              let O = N >= j ? E[T + N - j] : 0, D = E[T + N] - O;
              R[A + N] = D;
            }
          }
          function l(E, T, C, R) {
            let A = 0;
            for (let j = 0; j < C; j++) {
              let N = j >= R ? E[T + j - R] : 0, O = E[T + j] - N;
              A += Math.abs(O);
            }
            return A;
          }
          function d(E, T, C, R, A) {
            for (let j = 0; j < C; j++) {
              let N = T > 0 ? E[T + j - C] : 0, O = E[T + j] - N;
              R[A + j] = O;
            }
          }
          function u(E, T, C) {
            let R = 0, A = T + C;
            for (let j = T; j < A; j++) {
              let N = T > 0 ? E[j - C] : 0, O = E[j] - N;
              R += Math.abs(O);
            }
            return R;
          }
          function h(E, T, C, R, A, j) {
            for (let N = 0; N < C; N++) {
              let O = N >= j ? E[T + N - j] : 0, D = T > 0 ? E[T + N - C] : 0, H = E[T + N] - (O + D >> 1);
              R[A + N] = H;
            }
          }
          function y(E, T, C, R) {
            let A = 0;
            for (let j = 0; j < C; j++) {
              let N = j >= R ? E[T + j - R] : 0, O = T > 0 ? E[T + j - C] : 0, D = E[T + j] - (N + O >> 1);
              A += Math.abs(D);
            }
            return A;
          }
          function f(E, T, C, R, A, j) {
            for (let N = 0; N < C; N++) {
              let O = N >= j ? E[T + N - j] : 0, D = T > 0 ? E[T + N - C] : 0, H = T > 0 && N >= j ? E[T + N - (C + j)] : 0, G = E[T + N] - a(O, D, H);
              R[A + N] = G;
            }
          }
          function b(E, T, C, R) {
            let A = 0;
            for (let j = 0; j < C; j++) {
              let N = j >= R ? E[T + j - R] : 0, O = T > 0 ? E[T + j - C] : 0, D = T > 0 && j >= R ? E[T + j - (C + R)] : 0, H = E[T + j] - a(N, O, D);
              A += Math.abs(H);
            }
            return A;
          }
          let w = {
            0: s,
            1: p,
            2: d,
            3: h,
            4: f
          }, x = {
            0: c,
            1: l,
            2: u,
            3: y,
            4: b
          };
          o.exports = function(E, T, C, R, A) {
            let j;
            if (!("filterType" in R) || R.filterType === -1)
              j = [0, 1, 2, 3, 4];
            else if (typeof R.filterType == "number")
              j = [R.filterType];
            else
              throw new Error("unrecognised filter types");
            R.bitDepth === 16 && (A *= 2);
            let N = T * A, O = 0, D = 0, H = i.alloc((N + 1) * C), G = j[0];
            for (let X = 0; X < C; X++) {
              if (j.length > 1) {
                let Q = 1 / 0;
                for (let M = 0; M < j.length; M++) {
                  let k = x[j[M]](E, D, N, A);
                  k < Q && (G = j[M], Q = k);
                }
              }
              H[O] = G, O++, w[G](E, D, N, H, O, A), O += N, D += N;
            }
            return H;
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("util"), s = r("./chunkstream"), c = r("./filter-parse"), p = o.exports = function(l) {
            s.call(this);
            let d = [], u = this;
            this._filter = new c(l, {
              read: this.read.bind(this),
              write: function(h) {
                d.push(h);
              },
              complete: function() {
                u.emit("complete", i.concat(d));
              }
            }), this._filter.start();
          };
          a.inherits(p, s);
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./sync-reader"), s = r("./filter-parse");
          n.process = function(c, p) {
            let l = [], d = new a(c);
            return new s(p, {
              read: d.read.bind(d),
              write: function(u) {
                l.push(u);
              },
              complete: function() {
              }
            }).start(), d.process(), i.concat(l);
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./interlace"), s = r("./paeth-predictor");
          function c(l, d, u) {
            let h = l * d;
            return u !== 8 && (h = Math.ceil(h / (8 / u))), h;
          }
          let p = o.exports = function(l, d) {
            let u = l.width, h = l.height, y = l.interlace, f = l.bpp, b = l.depth;
            if (this.read = d.read, this.write = d.write, this.complete = d.complete, this._imageIndex = 0, this._images = [], y) {
              let w = a.getImagePasses(u, h);
              for (let x = 0; x < w.length; x++)
                this._images.push({
                  byteWidth: c(w[x].width, f, b),
                  height: w[x].height,
                  lineIndex: 0
                });
            } else
              this._images.push({
                byteWidth: c(u, f, b),
                height: h,
                lineIndex: 0
              });
            b === 8 ? this._xComparison = f : b === 16 ? this._xComparison = f * 2 : this._xComparison = 1;
          };
          p.prototype.start = function() {
            this.read(
              this._images[this._imageIndex].byteWidth + 1,
              this._reverseFilterLine.bind(this)
            );
          }, p.prototype._unFilterType1 = function(l, d, u) {
            let h = this._xComparison, y = h - 1;
            for (let f = 0; f < u; f++) {
              let b = l[1 + f], w = f > y ? d[f - h] : 0;
              d[f] = b + w;
            }
          }, p.prototype._unFilterType2 = function(l, d, u) {
            let h = this._lastLine;
            for (let y = 0; y < u; y++) {
              let f = l[1 + y], b = h ? h[y] : 0;
              d[y] = f + b;
            }
          }, p.prototype._unFilterType3 = function(l, d, u) {
            let h = this._xComparison, y = h - 1, f = this._lastLine;
            for (let b = 0; b < u; b++) {
              let w = l[1 + b], x = f ? f[b] : 0, E = b > y ? d[b - h] : 0, T = Math.floor((E + x) / 2);
              d[b] = w + T;
            }
          }, p.prototype._unFilterType4 = function(l, d, u) {
            let h = this._xComparison, y = h - 1, f = this._lastLine;
            for (let b = 0; b < u; b++) {
              let w = l[1 + b], x = f ? f[b] : 0, E = b > y ? d[b - h] : 0, T = b > y && f ? f[b - h] : 0, C = s(E, x, T);
              d[b] = w + C;
            }
          }, p.prototype._reverseFilterLine = function(l) {
            let d = l[0], u, h = this._images[this._imageIndex], y = h.byteWidth;
            if (d === 0)
              u = l.slice(1, y + 1);
            else
              switch (u = i.alloc(y), d) {
                case 1:
                  this._unFilterType1(l, u, y);
                  break;
                case 2:
                  this._unFilterType2(l, u, y);
                  break;
                case 3:
                  this._unFilterType3(l, u, y);
                  break;
                case 4:
                  this._unFilterType4(l, u, y);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + d);
              }
            this.write(u), h.lineIndex++, h.lineIndex >= h.height ? (this._lastLine = null, this._imageIndex++, h = this._images[this._imageIndex]) : this._lastLine = u, h ? this.read(h.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(r, o, n) {
      (function(i) {
        (function() {
          function a(p, l, d, u, h) {
            let y = 0;
            for (let f = 0; f < u; f++)
              for (let b = 0; b < d; b++) {
                let w = h[p[y]];
                if (!w)
                  throw new Error("index " + p[y] + " not in palette");
                for (let x = 0; x < 4; x++)
                  l[y + x] = w[x];
                y += 4;
              }
          }
          function s(p, l, d, u, h) {
            let y = 0;
            for (let f = 0; f < u; f++)
              for (let b = 0; b < d; b++) {
                let w = !1;
                if (h.length === 1 ? h[0] === p[y] && (w = !0) : h[0] === p[y] && h[1] === p[y + 1] && h[2] === p[y + 2] && (w = !0), w)
                  for (let x = 0; x < 4; x++)
                    l[y + x] = 0;
                y += 4;
              }
          }
          function c(p, l, d, u, h) {
            let y = 255, f = Math.pow(2, h) - 1, b = 0;
            for (let w = 0; w < u; w++)
              for (let x = 0; x < d; x++) {
                for (let E = 0; E < 4; E++)
                  l[b + E] = Math.floor(
                    p[b + E] * y / f + 0.5
                  );
                b += 4;
              }
          }
          o.exports = function(p, l, d = !1) {
            let u = l.depth, h = l.width, y = l.height, f = l.colorType, b = l.transColor, w = l.palette, x = p;
            return f === 3 ? a(p, x, h, y, w) : (b && s(p, x, h, y, b), u !== 8 && !d && (u === 16 && (x = i.alloc(h * y * 4)), c(p, x, h, y, u))), x;
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { buffer: 32 }], 11: [function(r, o, n) {
      let i = [
        {
          // pass 1 - 1px
          x: [0],
          y: [0]
        },
        {
          // pass 2 - 1px
          x: [4],
          y: [0]
        },
        {
          // pass 3 - 2px
          x: [0, 4],
          y: [4]
        },
        {
          // pass 4 - 4px
          x: [2, 6],
          y: [0, 4]
        },
        {
          // pass 5 - 8px
          x: [0, 2, 4, 6],
          y: [2, 6]
        },
        {
          // pass 6 - 16px
          x: [1, 3, 5, 7],
          y: [0, 2, 4, 6]
        },
        {
          // pass 7 - 32px
          x: [0, 1, 2, 3, 4, 5, 6, 7],
          y: [1, 3, 5, 7]
        }
      ];
      n.getImagePasses = function(a, s) {
        let c = [], p = a % 8, l = s % 8, d = (a - p) / 8, u = (s - l) / 8;
        for (let h = 0; h < i.length; h++) {
          let y = i[h], f = d * y.x.length, b = u * y.y.length;
          for (let w = 0; w < y.x.length && y.x[w] < p; w++)
            f++;
          for (let w = 0; w < y.y.length && y.y[w] < l; w++)
            b++;
          f > 0 && b > 0 && c.push({ width: f, height: b, index: h });
        }
        return c;
      }, n.getInterlaceIterator = function(a) {
        return function(s, c, p) {
          let l = s % i[p].x.length, d = (s - l) / i[p].x.length * 8 + i[p].x[l], u = c % i[p].y.length, h = (c - u) / i[p].y.length * 8 + i[p].y[u];
          return d * 4 + h * a * 4;
        };
      };
    }, {}], 12: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("util"), s = r("stream"), c = r("./constants"), p = r("./packer"), l = o.exports = function(d) {
            s.call(this);
            let u = d || {};
            this._packer = new p(u), this._deflate = this._packer.createDeflate(), this.readable = !0;
          };
          a.inherits(l, s), l.prototype.pack = function(d, u, h, y) {
            this.emit("data", i.from(c.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(u, h)), y && this.emit("data", this._packer.packGAMA(y));
            let f = this._packer.filterData(d, u, h);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on(
              "data",
              (function(b) {
                this.emit("data", this._packer.packIDAT(b));
              }).bind(this)
            ), this._deflate.on(
              "end",
              (function() {
                this.emit("data", this._packer.packIEND()), this.emit("end");
              }).bind(this)
            ), this._deflate.end(f);
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = !0, s = r("zlib");
          s.deflateSync || (a = !1);
          let c = r("./constants"), p = r("./packer");
          o.exports = function(l, d) {
            if (!a)
              throw new Error(
                "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
              );
            let u = d || {}, h = new p(u), y = [];
            y.push(i.from(c.PNG_SIGNATURE)), y.push(h.packIHDR(l.width, l.height)), l.gamma && y.push(h.packGAMA(l.gamma));
            let f = h.filterData(
              l.data,
              l.width,
              l.height
            ), b = s.deflateSync(
              f,
              h.getDeflateOptions()
            );
            if (f = null, !b || !b.length)
              throw new Error("bad png - invalid compressed data response");
            return y.push(h.packIDAT(b)), y.push(h.packIEND()), i.concat(y);
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./constants"), s = r("./crc"), c = r("./bitpacker"), p = r("./filter-pack"), l = r("zlib"), d = o.exports = function(u) {
            if (this._options = u, u.deflateChunkSize = u.deflateChunkSize || 32 * 1024, u.deflateLevel = u.deflateLevel != null ? u.deflateLevel : 9, u.deflateStrategy = u.deflateStrategy != null ? u.deflateStrategy : 3, u.inputHasAlpha = u.inputHasAlpha != null ? u.inputHasAlpha : !0, u.deflateFactory = u.deflateFactory || l.createDeflate, u.bitDepth = u.bitDepth || 8, u.colorType = typeof u.colorType == "number" ? u.colorType : a.COLORTYPE_COLOR_ALPHA, u.inputColorType = typeof u.inputColorType == "number" ? u.inputColorType : a.COLORTYPE_COLOR_ALPHA, [
              a.COLORTYPE_GRAYSCALE,
              a.COLORTYPE_COLOR,
              a.COLORTYPE_COLOR_ALPHA,
              a.COLORTYPE_ALPHA
            ].indexOf(u.colorType) === -1)
              throw new Error(
                "option color type:" + u.colorType + " is not supported at present"
              );
            if ([
              a.COLORTYPE_GRAYSCALE,
              a.COLORTYPE_COLOR,
              a.COLORTYPE_COLOR_ALPHA,
              a.COLORTYPE_ALPHA
            ].indexOf(u.inputColorType) === -1)
              throw new Error(
                "option input color type:" + u.inputColorType + " is not supported at present"
              );
            if (u.bitDepth !== 8 && u.bitDepth !== 16)
              throw new Error(
                "option bit depth:" + u.bitDepth + " is not supported at present"
              );
          };
          d.prototype.getDeflateOptions = function() {
            return {
              chunkSize: this._options.deflateChunkSize,
              level: this._options.deflateLevel,
              strategy: this._options.deflateStrategy
            };
          }, d.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, d.prototype.filterData = function(u, h, y) {
            let f = c(u, h, y, this._options), b = a.COLORTYPE_TO_BPP_MAP[this._options.colorType];
            return p(f, h, y, this._options, b);
          }, d.prototype._packChunk = function(u, h) {
            let y = h ? h.length : 0, f = i.alloc(y + 12);
            return f.writeUInt32BE(y, 0), f.writeUInt32BE(u, 4), h && h.copy(f, 8), f.writeInt32BE(
              s.crc32(f.slice(4, f.length - 4)),
              f.length - 4
            ), f;
          }, d.prototype.packGAMA = function(u) {
            let h = i.alloc(4);
            return h.writeUInt32BE(Math.floor(u * a.GAMMA_DIVISION), 0), this._packChunk(a.TYPE_gAMA, h);
          }, d.prototype.packIHDR = function(u, h) {
            let y = i.alloc(13);
            return y.writeUInt32BE(u, 0), y.writeUInt32BE(h, 4), y[8] = this._options.bitDepth, y[9] = this._options.colorType, y[10] = 0, y[11] = 0, y[12] = 0, this._packChunk(a.TYPE_IHDR, y);
          }, d.prototype.packIDAT = function(u) {
            return this._packChunk(a.TYPE_IDAT, u);
          }, d.prototype.packIEND = function() {
            return this._packChunk(a.TYPE_IEND, null);
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(r, o, n) {
      o.exports = function(i, a, s) {
        let c = i + a - s, p = Math.abs(c - i), l = Math.abs(c - a), d = Math.abs(c - s);
        return p <= l && p <= d ? i : l <= d ? a : s;
      };
    }, {}], 16: [function(r, o, n) {
      let i = r("util"), a = r("zlib"), s = r("./chunkstream"), c = r("./filter-parse-async"), p = r("./parser"), l = r("./bitmapper"), d = r("./format-normaliser"), u = o.exports = function(h) {
        s.call(this), this._parser = new p(h, {
          read: this.read.bind(this),
          error: this._handleError.bind(this),
          metadata: this._handleMetaData.bind(this),
          gamma: this.emit.bind(this, "gamma"),
          palette: this._handlePalette.bind(this),
          transColor: this._handleTransColor.bind(this),
          finished: this._finished.bind(this),
          inflateData: this._inflateData.bind(this),
          simpleTransparency: this._simpleTransparency.bind(this),
          headersFinished: this._headersFinished.bind(this)
        }), this._options = h, this.writable = !0, this._parser.start();
      };
      i.inherits(u, s), u.prototype._handleError = function(h) {
        this.emit("error", h), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
        })), this.errord = !0;
      }, u.prototype._inflateData = function(h) {
        if (!this._inflate)
          if (this._bitmapInfo.interlace)
            this._inflate = a.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
          else {
            let y = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1) * this._bitmapInfo.height, f = Math.max(y, a.Z_MIN_CHUNK);
            this._inflate = a.createInflate({ chunkSize: f });
            let b = y, w = this.emit.bind(this, "error");
            this._inflate.on("error", function(E) {
              b && w(E);
            }), this._filter.on("complete", this._complete.bind(this));
            let x = this._filter.write.bind(this._filter);
            this._inflate.on("data", function(E) {
              b && (E.length > b && (E = E.slice(0, b)), b -= E.length, x(E));
            }), this._inflate.on("end", this._filter.end.bind(this._filter));
          }
        this._inflate.write(h);
      }, u.prototype._handleMetaData = function(h) {
        this._metaData = h, this._bitmapInfo = Object.create(h), this._filter = new c(this._bitmapInfo);
      }, u.prototype._handleTransColor = function(h) {
        this._bitmapInfo.transColor = h;
      }, u.prototype._handlePalette = function(h) {
        this._bitmapInfo.palette = h;
      }, u.prototype._simpleTransparency = function() {
        this._metaData.alpha = !0;
      }, u.prototype._headersFinished = function() {
        this.emit("metadata", this._metaData);
      }, u.prototype._finished = function() {
        this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
      }, u.prototype._complete = function(h) {
        if (this.errord)
          return;
        let y;
        try {
          let f = l.dataToBitMap(h, this._bitmapInfo);
          y = d(
            f,
            this._bitmapInfo,
            this._options.skipRescale
          ), f = null;
        } catch (f) {
          this._handleError(f);
          return;
        }
        this.emit("parsed", y);
      };
    }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = !0, s = r("zlib"), c = r("./sync-inflate");
          s.deflateSync || (a = !1);
          let p = r("./sync-reader"), l = r("./filter-parse-sync"), d = r("./parser"), u = r("./bitmapper"), h = r("./format-normaliser");
          o.exports = function(y, f) {
            if (!a)
              throw new Error(
                "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
              );
            let b;
            function w(k) {
              b = k;
            }
            let x;
            function E(k) {
              x = k;
            }
            function T(k) {
              x.transColor = k;
            }
            function C(k) {
              x.palette = k;
            }
            function R() {
              x.alpha = !0;
            }
            let A;
            function j(k) {
              A = k;
            }
            let N = [];
            function O(k) {
              N.push(k);
            }
            let D = new p(y);
            if (new d(f, {
              read: D.read.bind(D),
              error: w,
              metadata: E,
              gamma: j,
              palette: C,
              transColor: T,
              inflateData: O,
              simpleTransparency: R
            }).start(), D.process(), b)
              throw b;
            let H = i.concat(N);
            N.length = 0;
            let G;
            if (x.interlace)
              G = s.inflateSync(H);
            else {
              let k = ((x.width * x.bpp * x.depth + 7 >> 3) + 1) * x.height;
              G = c(H, {
                chunkSize: k,
                maxLength: k
              });
            }
            if (H = null, !G || !G.length)
              throw new Error("bad png - invalid inflate data response");
            let X = l.process(G, x);
            H = null;
            let Q = u.dataToBitMap(X, x);
            X = null;
            let M = h(
              Q,
              x,
              f.skipRescale
            );
            return x.data = M, x.gamma = A || 0, x;
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(r, o, n) {
      (function(i) {
        (function() {
          let a = r("./constants"), s = r("./crc"), c = o.exports = function(p, l) {
            this._options = p, p.checkCRC = p.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[a.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[a.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[a.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[a.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[a.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[a.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = l.read, this.error = l.error, this.metadata = l.metadata, this.gamma = l.gamma, this.transColor = l.transColor, this.palette = l.palette, this.parsed = l.parsed, this.inflateData = l.inflateData, this.finished = l.finished, this.simpleTransparency = l.simpleTransparency, this.headersFinished = l.headersFinished || function() {
            };
          };
          c.prototype.start = function() {
            this.read(a.PNG_SIGNATURE.length, this._parseSignature.bind(this));
          }, c.prototype._parseSignature = function(p) {
            let l = a.PNG_SIGNATURE;
            for (let d = 0; d < l.length; d++)
              if (p[d] !== l[d]) {
                this.error(new Error("Invalid file signature"));
                return;
              }
            this.read(8, this._parseChunkBegin.bind(this));
          }, c.prototype._parseChunkBegin = function(p) {
            let l = p.readUInt32BE(0), d = p.readUInt32BE(4), u = "";
            for (let y = 4; y < 8; y++)
              u += String.fromCharCode(p[y]);
            let h = !!(p[4] & 32);
            if (!this._hasIHDR && d !== a.TYPE_IHDR) {
              this.error(new Error("Expected IHDR on beggining"));
              return;
            }
            if (this._crc = new s(), this._crc.write(i.from(u)), this._chunks[d])
              return this._chunks[d](l);
            if (!h) {
              this.error(new Error("Unsupported critical chunk type " + u));
              return;
            }
            this.read(l + 4, this._skipChunk.bind(this));
          }, c.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, c.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, c.prototype._parseChunkEnd = function(p) {
            let l = p.readInt32BE(0), d = this._crc.crc32();
            if (this._options.checkCRC && d !== l) {
              this.error(new Error("Crc error - " + l + " - " + d));
              return;
            }
            this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, c.prototype._handleIHDR = function(p) {
            this.read(p, this._parseIHDR.bind(this));
          }, c.prototype._parseIHDR = function(p) {
            this._crc.write(p);
            let l = p.readUInt32BE(0), d = p.readUInt32BE(4), u = p[8], h = p[9], y = p[10], f = p[11], b = p[12];
            if (u !== 8 && u !== 4 && u !== 2 && u !== 1 && u !== 16) {
              this.error(new Error("Unsupported bit depth " + u));
              return;
            }
            if (!(h in a.COLORTYPE_TO_BPP_MAP)) {
              this.error(new Error("Unsupported color type"));
              return;
            }
            if (y !== 0) {
              this.error(new Error("Unsupported compression method"));
              return;
            }
            if (f !== 0) {
              this.error(new Error("Unsupported filter method"));
              return;
            }
            if (b !== 0 && b !== 1) {
              this.error(new Error("Unsupported interlace method"));
              return;
            }
            this._colorType = h;
            let w = a.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = !0, this.metadata({
              width: l,
              height: d,
              depth: u,
              interlace: !!b,
              palette: !!(h & a.COLORTYPE_PALETTE),
              color: !!(h & a.COLORTYPE_COLOR),
              alpha: !!(h & a.COLORTYPE_ALPHA),
              bpp: w,
              colorType: h
            }), this._handleChunkEnd();
          }, c.prototype._handlePLTE = function(p) {
            this.read(p, this._parsePLTE.bind(this));
          }, c.prototype._parsePLTE = function(p) {
            this._crc.write(p);
            let l = Math.floor(p.length / 3);
            for (let d = 0; d < l; d++)
              this._palette.push([p[d * 3], p[d * 3 + 1], p[d * 3 + 2], 255]);
            this.palette(this._palette), this._handleChunkEnd();
          }, c.prototype._handleTRNS = function(p) {
            this.simpleTransparency(), this.read(p, this._parseTRNS.bind(this));
          }, c.prototype._parseTRNS = function(p) {
            if (this._crc.write(p), this._colorType === a.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0) {
                this.error(new Error("Transparency chunk must be after palette"));
                return;
              }
              if (p.length > this._palette.length) {
                this.error(new Error("More transparent colors than palette size"));
                return;
              }
              for (let l = 0; l < p.length; l++)
                this._palette[l][3] = p[l];
              this.palette(this._palette);
            }
            this._colorType === a.COLORTYPE_GRAYSCALE && this.transColor([p.readUInt16BE(0)]), this._colorType === a.COLORTYPE_COLOR && this.transColor([
              p.readUInt16BE(0),
              p.readUInt16BE(2),
              p.readUInt16BE(4)
            ]), this._handleChunkEnd();
          }, c.prototype._handleGAMA = function(p) {
            this.read(p, this._parseGAMA.bind(this));
          }, c.prototype._parseGAMA = function(p) {
            this._crc.write(p), this.gamma(p.readUInt32BE(0) / a.GAMMA_DIVISION), this._handleChunkEnd();
          }, c.prototype._handleIDAT = function(p) {
            this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), this.read(-p, this._parseIDAT.bind(this, p));
          }, c.prototype._parseIDAT = function(p, l) {
            if (this._crc.write(l), this._colorType === a.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
              throw new Error("Expected palette not found");
            this.inflateData(l);
            let d = p - l.length;
            d > 0 ? this._handleIDAT(d) : this._handleChunkEnd();
          }, c.prototype._handleIEND = function(p) {
            this.read(p, this._parseIEND.bind(this));
          }, c.prototype._parseIEND = function(p) {
            this._crc.write(p), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(r, o, n) {
      let i = r("./parser-sync"), a = r("./packer-sync");
      n.read = function(s, c) {
        return i(s, c || {});
      }, n.write = function(s, c) {
        return a(s, c);
      };
    }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(r, o, n) {
      (function(i, a) {
        (function() {
          let s = r("util"), c = r("stream"), p = r("./parser-async"), l = r("./packer-async"), d = r("./png-sync"), u = n.PNG = function(h) {
            c.call(this), h = h || {}, this.width = h.width | 0, this.height = h.height | 0, this.data = this.width > 0 && this.height > 0 ? a.alloc(4 * this.width * this.height) : null, h.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new p(h), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on(
              "parsed",
              (function(y) {
                this.data = y, this.emit("parsed", y);
              }).bind(this)
            ), this._packer = new l(h), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          s.inherits(u, c), u.sync = d, u.prototype.pack = function() {
            return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (i.nextTick(
              (function() {
                this._packer.pack(this.data, this.width, this.height, this.gamma);
              }).bind(this)
            ), this);
          }, u.prototype.parse = function(h, y) {
            if (y) {
              let f, b;
              f = (function(w) {
                this.removeListener("error", b), this.data = w, y(null, this);
              }).bind(this), b = (function(w) {
                this.removeListener("parsed", f), y(w, null);
              }).bind(this), this.once("parsed", f), this.once("error", b);
            }
            return this.end(h), this;
          }, u.prototype.write = function(h) {
            return this._parser.write(h), !0;
          }, u.prototype.end = function(h) {
            this._parser.end(h);
          }, u.prototype._metadata = function(h) {
            this.width = h.width, this.height = h.height, this.emit("metadata", h);
          }, u.prototype._gamma = function(h) {
            this.gamma = h;
          }, u.prototype._handleClose = function() {
            !this._parser.writable && !this._packer.readable && this.emit("close");
          }, u.bitblt = function(h, y, f, b, w, x, E, T) {
            if (f |= 0, b |= 0, w |= 0, x |= 0, E |= 0, T |= 0, f > h.width || b > h.height || f + w > h.width || b + x > h.height)
              throw new Error("bitblt reading outside image");
            if (E > y.width || T > y.height || E + w > y.width || T + x > y.height)
              throw new Error("bitblt writing outside image");
            for (let C = 0; C < x; C++)
              h.data.copy(
                y.data,
                (T + C) * y.width + E << 2,
                (b + C) * h.width + f << 2,
                (b + C) * h.width + f + w << 2
              );
          }, u.prototype.bitblt = function(h, y, f, b, w, x, E) {
            return u.bitblt(this, h, y, f, b, w, x, E), this;
          }, u.adjustGamma = function(h) {
            if (h.gamma) {
              for (let y = 0; y < h.height; y++)
                for (let f = 0; f < h.width; f++) {
                  let b = h.width * y + f << 2;
                  for (let w = 0; w < 3; w++) {
                    let x = h.data[b + w] / 255;
                    x = Math.pow(x, 1 / 2.2 / h.gamma), h.data[b + w] = Math.round(x * 255);
                  }
                }
              h.gamma = 0;
            }
          }, u.prototype.adjustGamma = function() {
            u.adjustGamma(this);
          };
        }).call(this);
      }).call(this, r("_process"), r("buffer").Buffer);
    }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(r, o, n) {
      (function(i, a) {
        (function() {
          let s = r("assert").ok, c = r("zlib"), p = r("util"), l = r("buffer").kMaxLength;
          function d(b) {
            if (!(this instanceof d))
              return new d(b);
            b && b.chunkSize < c.Z_MIN_CHUNK && (b.chunkSize = c.Z_MIN_CHUNK), c.Inflate.call(this, b), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, b && b.maxLength != null && (this._maxLength = b.maxLength);
          }
          function u(b) {
            return new d(b);
          }
          function h(b, w) {
            b._handle && (b._handle.close(), b._handle = null);
          }
          d.prototype._processChunk = function(b, w, x) {
            if (typeof x == "function")
              return c.Inflate._processChunk.call(this, b, w, x);
            let E = this, T = b && b.length, C = this._chunkSize - this._offset, R = this._maxLength, A = 0, j = [], N = 0, O;
            this.on("error", function(X) {
              O = X;
            });
            function D(X, Q) {
              if (E._hadError)
                return;
              let M = C - Q;
              if (s(M >= 0, "have should not go down"), M > 0) {
                let k = E._buffer.slice(E._offset, E._offset + M);
                if (E._offset += M, k.length > R && (k = k.slice(0, R)), j.push(k), N += k.length, R -= k.length, R === 0)
                  return !1;
              }
              return (Q === 0 || E._offset >= E._chunkSize) && (C = E._chunkSize, E._offset = 0, E._buffer = a.allocUnsafe(E._chunkSize)), Q === 0 ? (A += T - X, T = X, !0) : !1;
            }
            s(this._handle, "zlib binding closed");
            let H;
            do
              H = this._handle.writeSync(
                w,
                b,
                // in
                A,
                // in_off
                T,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                C
              ), H = H || this._writeState;
            while (!this._hadError && D(H[0], H[1]));
            if (this._hadError)
              throw O;
            if (N >= l)
              throw h(this), new RangeError(
                "Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes"
              );
            let G = a.concat(j, N);
            return h(this), G;
          }, p.inherits(d, c.Inflate);
          function y(b, w) {
            if (typeof w == "string" && (w = a.from(w)), !(w instanceof a))
              throw new TypeError("Not a string or buffer");
            let x = b._finishFlushFlag;
            return x == null && (x = c.Z_FINISH), b._processChunk(w, x);
          }
          function f(b, w) {
            return y(new d(w), b);
          }
          o.exports = n = f, n.Inflate = d, n.createInflate = u, n.inflateSync = f;
        }).call(this);
      }).call(this, r("_process"), r("buffer").Buffer);
    }, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(r, o, n) {
      let i = o.exports = function(a) {
        this._buffer = a, this._reads = [];
      };
      i.prototype.read = function(a, s) {
        this._reads.push({
          length: Math.abs(a),
          // if length < 0 then at most this length
          allowLess: a < 0,
          func: s
        });
      }, i.prototype.process = function() {
        for (; this._reads.length > 0 && this._buffer.length; ) {
          let a = this._reads[0];
          if (this._buffer.length && (this._buffer.length >= a.length || a.allowLess)) {
            this._reads.shift();
            let s = this._buffer;
            this._buffer = s.slice(a.length), a.func.call(this, s.slice(0, a.length));
          } else
            break;
        }
        if (this._reads.length > 0)
          throw new Error("There are some read requests waitng on finished stream");
        if (this._buffer.length > 0)
          throw new Error("unrecognised content at end of stream");
      };
    }, {}], 23: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = r("object-assign");
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          function s(M, k) {
            if (M === k)
              return 0;
            for (var $ = M.length, ne = k.length, te = 0, de = Math.min($, ne); te < de; ++te)
              if (M[te] !== k[te]) {
                $ = M[te], ne = k[te];
                break;
              }
            return $ < ne ? -1 : ne < $ ? 1 : 0;
          }
          function c(M) {
            return i.Buffer && typeof i.Buffer.isBuffer == "function" ? i.Buffer.isBuffer(M) : !!(M != null && M._isBuffer);
          }
          var p = r("util/"), l = Object.prototype.hasOwnProperty, d = Array.prototype.slice, u = function() {
            return (function() {
            }).name === "foo";
          }();
          function h(M) {
            return Object.prototype.toString.call(M);
          }
          function y(M) {
            return c(M) || typeof i.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(M) : M ? !!(M instanceof DataView || M.buffer && M.buffer instanceof ArrayBuffer) : !1;
          }
          var f = o.exports = R, b = /\s*function\s+([^\(\s]*)\s*/;
          function w(M) {
            if (p.isFunction(M)) {
              if (u)
                return M.name;
              var k = M.toString(), $ = k.match(b);
              return $ && $[1];
            }
          }
          f.AssertionError = function(M) {
            this.name = "AssertionError", this.actual = M.actual, this.expected = M.expected, this.operator = M.operator, M.message ? (this.message = M.message, this.generatedMessage = !1) : (this.message = T(this), this.generatedMessage = !0);
            var k = M.stackStartFunction || C;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, k);
            else {
              var $ = new Error();
              if ($.stack) {
                var ne = $.stack, te = w(k), de = ne.indexOf(`
` + te);
                if (de >= 0) {
                  var ae = ne.indexOf(`
`, de + 1);
                  ne = ne.substring(ae + 1);
                }
                this.stack = ne;
              }
            }
          }, p.inherits(f.AssertionError, Error);
          function x(M, k) {
            return typeof M == "string" ? M.length < k ? M : M.slice(0, k) : M;
          }
          function E(M) {
            if (u || !p.isFunction(M))
              return p.inspect(M);
            var k = w(M), $ = k ? ": " + k : "";
            return "[Function" + $ + "]";
          }
          function T(M) {
            return x(E(M.actual), 128) + " " + M.operator + " " + x(E(M.expected), 128);
          }
          function C(M, k, $, ne, te) {
            throw new f.AssertionError({
              message: $,
              actual: M,
              expected: k,
              operator: ne,
              stackStartFunction: te
            });
          }
          f.fail = C;
          function R(M, k) {
            M || C(M, !0, k, "==", f.ok);
          }
          f.ok = R, f.equal = function(M, k, $) {
            M != k && C(M, k, $, "==", f.equal);
          }, f.notEqual = function(M, k, $) {
            M == k && C(M, k, $, "!=", f.notEqual);
          }, f.deepEqual = function(M, k, $) {
            A(M, k, !1) || C(M, k, $, "deepEqual", f.deepEqual);
          }, f.deepStrictEqual = function(M, k, $) {
            A(M, k, !0) || C(M, k, $, "deepStrictEqual", f.deepStrictEqual);
          };
          function A(M, k, $, ne) {
            if (M === k)
              return !0;
            if (c(M) && c(k))
              return s(M, k) === 0;
            if (p.isDate(M) && p.isDate(k))
              return M.getTime() === k.getTime();
            if (p.isRegExp(M) && p.isRegExp(k))
              return M.source === k.source && M.global === k.global && M.multiline === k.multiline && M.lastIndex === k.lastIndex && M.ignoreCase === k.ignoreCase;
            if ((M === null || typeof M != "object") && (k === null || typeof k != "object"))
              return $ ? M === k : M == k;
            if (y(M) && y(k) && h(M) === h(k) && !(M instanceof Float32Array || M instanceof Float64Array))
              return s(
                new Uint8Array(M.buffer),
                new Uint8Array(k.buffer)
              ) === 0;
            if (c(M) !== c(k))
              return !1;
            ne = ne || { actual: [], expected: [] };
            var te = ne.actual.indexOf(M);
            return te !== -1 && te === ne.expected.indexOf(k) ? !0 : (ne.actual.push(M), ne.expected.push(k), N(M, k, $, ne));
          }
          function j(M) {
            return Object.prototype.toString.call(M) == "[object Arguments]";
          }
          function N(M, k, $, ne) {
            if (M == null || k === null || k === void 0)
              return !1;
            if (p.isPrimitive(M) || p.isPrimitive(k))
              return M === k;
            if ($ && Object.getPrototypeOf(M) !== Object.getPrototypeOf(k))
              return !1;
            var te = j(M), de = j(k);
            if (te && !de || !te && de)
              return !1;
            if (te)
              return M = d.call(M), k = d.call(k), A(M, k, $);
            var ae = Q(M), z = Q(k), Z, oe;
            if (ae.length !== z.length)
              return !1;
            for (ae.sort(), z.sort(), oe = ae.length - 1; oe >= 0; oe--)
              if (ae[oe] !== z[oe])
                return !1;
            for (oe = ae.length - 1; oe >= 0; oe--)
              if (Z = ae[oe], !A(M[Z], k[Z], $, ne))
                return !1;
            return !0;
          }
          f.notDeepEqual = function(M, k, $) {
            A(M, k, !1) && C(M, k, $, "notDeepEqual", f.notDeepEqual);
          }, f.notDeepStrictEqual = O;
          function O(M, k, $) {
            A(M, k, !0) && C(M, k, $, "notDeepStrictEqual", O);
          }
          f.strictEqual = function(M, k, $) {
            M !== k && C(M, k, $, "===", f.strictEqual);
          }, f.notStrictEqual = function(M, k, $) {
            M === k && C(M, k, $, "!==", f.notStrictEqual);
          };
          function D(M, k) {
            if (!M || !k)
              return !1;
            if (Object.prototype.toString.call(k) == "[object RegExp]")
              return k.test(M);
            try {
              if (M instanceof k)
                return !0;
            } catch {
            }
            return Error.isPrototypeOf(k) ? !1 : k.call({}, M) === !0;
          }
          function H(M) {
            var k;
            try {
              M();
            } catch ($) {
              k = $;
            }
            return k;
          }
          function G(M, k, $, ne) {
            var te;
            if (typeof k != "function")
              throw new TypeError('"block" argument must be a function');
            typeof $ == "string" && (ne = $, $ = null), te = H(k), ne = ($ && $.name ? " (" + $.name + ")." : ".") + (ne ? " " + ne : "."), M && !te && C(te, $, "Missing expected exception" + ne);
            var de = typeof ne == "string", ae = !M && p.isError(te), z = !M && te && !$;
            if ((ae && de && D(te, $) || z) && C(te, $, "Got unwanted exception" + ne), M && te && $ && !D(te, $) || !M && te)
              throw te;
          }
          f.throws = function(M, k, $) {
            G(!0, M, k, $);
          }, f.doesNotThrow = function(M, k, $) {
            G(!1, M, k, $);
          }, f.ifError = function(M) {
            if (M)
              throw M;
          };
          function X(M, k) {
            M || C(M, !0, k, "==", X);
          }
          f.strict = a(X, f, {
            equal: f.strictEqual,
            deepEqual: f.deepStrictEqual,
            notEqual: f.notStrictEqual,
            notDeepEqual: f.notDeepStrictEqual
          }), f.strict.strict = f.strict;
          var Q = Object.keys || function(M) {
            var k = [];
            for (var $ in M)
              l.call(M, $) && k.push($);
            return k;
          };
        }).call(this);
      }).call(this, typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "object-assign": 51, "util/": 26 }], 24: [function(r, o, n) {
      typeof Object.create == "function" ? o.exports = function(i, a) {
        i.super_ = a, i.prototype = Object.create(a.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : o.exports = function(i, a) {
        i.super_ = a;
        var s = function() {
        };
        s.prototype = a.prototype, i.prototype = new s(), i.prototype.constructor = i;
      };
    }, {}], 25: [function(r, o, n) {
      o.exports = function(i) {
        return i && typeof i == "object" && typeof i.copy == "function" && typeof i.fill == "function" && typeof i.readUInt8 == "function";
      };
    }, {}], 26: [function(r, o, n) {
      (function(i, a) {
        (function() {
          var s = /%[sdj%]/g;
          n.format = function(z) {
            if (!N(z)) {
              for (var Z = [], oe = 0; oe < arguments.length; oe++)
                Z.push(l(arguments[oe]));
              return Z.join(" ");
            }
            for (var oe = 1, ye = arguments, V = ye.length, q = String(z).replace(s, function(ge) {
              if (ge === "%%")
                return "%";
              if (oe >= V)
                return ge;
              switch (ge) {
                case "%s":
                  return String(ye[oe++]);
                case "%d":
                  return Number(ye[oe++]);
                case "%j":
                  try {
                    return JSON.stringify(ye[oe++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return ge;
              }
            }), ee = ye[oe]; oe < V; ee = ye[++oe])
              R(ee) || !G(ee) ? q += " " + ee : q += " " + l(ee);
            return q;
          }, n.deprecate = function(z, Z) {
            if (D(a.process))
              return function() {
                return n.deprecate(z, Z).apply(this, arguments);
              };
            if (i.noDeprecation === !0)
              return z;
            var oe = !1;
            function ye() {
              if (!oe) {
                if (i.throwDeprecation)
                  throw new Error(Z);
                i.traceDeprecation ? console.trace(Z) : console.error(Z), oe = !0;
              }
              return z.apply(this, arguments);
            }
            return ye;
          };
          var c = {}, p;
          n.debuglog = function(z) {
            if (D(p) && (p = i.env.NODE_DEBUG || ""), z = z.toUpperCase(), !c[z])
              if (new RegExp("\\b" + z + "\\b", "i").test(p)) {
                var Z = i.pid;
                c[z] = function() {
                  var oe = n.format.apply(n, arguments);
                  console.error("%s %d: %s", z, Z, oe);
                };
              } else
                c[z] = function() {
                };
            return c[z];
          };
          function l(z, Z) {
            var oe = {
              seen: [],
              stylize: u
            };
            return arguments.length >= 3 && (oe.depth = arguments[2]), arguments.length >= 4 && (oe.colors = arguments[3]), C(Z) ? oe.showHidden = Z : Z && n._extend(oe, Z), D(oe.showHidden) && (oe.showHidden = !1), D(oe.depth) && (oe.depth = 2), D(oe.colors) && (oe.colors = !1), D(oe.customInspect) && (oe.customInspect = !0), oe.colors && (oe.stylize = d), y(oe, z, oe.depth);
          }
          n.inspect = l, l.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, l.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function d(z, Z) {
            var oe = l.styles[Z];
            return oe ? "\x1B[" + l.colors[oe][0] + "m" + z + "\x1B[" + l.colors[oe][1] + "m" : z;
          }
          function u(z, Z) {
            return z;
          }
          function h(z) {
            var Z = {};
            return z.forEach(function(oe, ye) {
              Z[oe] = !0;
            }), Z;
          }
          function y(z, Z, oe) {
            if (z.customInspect && Z && M(Z.inspect) && // Filter out the util module, it's inspect function is special
            Z.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
            !(Z.constructor && Z.constructor.prototype === Z)) {
              var ye = Z.inspect(oe, z);
              return N(ye) || (ye = y(z, ye, oe)), ye;
            }
            var V = f(z, Z);
            if (V)
              return V;
            var q = Object.keys(Z), ee = h(q);
            if (z.showHidden && (q = Object.getOwnPropertyNames(Z)), Q(Z) && (q.indexOf("message") >= 0 || q.indexOf("description") >= 0))
              return b(Z);
            if (q.length === 0) {
              if (M(Z)) {
                var ue = Z.name ? ": " + Z.name : "";
                return z.stylize("[Function" + ue + "]", "special");
              }
              if (H(Z))
                return z.stylize(RegExp.prototype.toString.call(Z), "regexp");
              if (X(Z))
                return z.stylize(Date.prototype.toString.call(Z), "date");
              if (Q(Z))
                return b(Z);
            }
            var ge = "", he = !1, W = ["{", "}"];
            if (T(Z) && (he = !0, W = ["[", "]"]), M(Z)) {
              var Y = Z.name ? ": " + Z.name : "";
              ge = " [Function" + Y + "]";
            }
            if (H(Z) && (ge = " " + RegExp.prototype.toString.call(Z)), X(Z) && (ge = " " + Date.prototype.toUTCString.call(Z)), Q(Z) && (ge = " " + b(Z)), q.length === 0 && (!he || Z.length == 0))
              return W[0] + ge + W[1];
            if (oe < 0)
              return H(Z) ? z.stylize(RegExp.prototype.toString.call(Z), "regexp") : z.stylize("[Object]", "special");
            z.seen.push(Z);
            var se;
            return he ? se = w(z, Z, oe, ee, q) : se = q.map(function(Te) {
              return x(z, Z, oe, ee, Te, he);
            }), z.seen.pop(), E(se, ge, W);
          }
          function f(z, Z) {
            if (D(Z))
              return z.stylize("undefined", "undefined");
            if (N(Z)) {
              var oe = "'" + JSON.stringify(Z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return z.stylize(oe, "string");
            }
            if (j(Z))
              return z.stylize("" + Z, "number");
            if (C(Z))
              return z.stylize("" + Z, "boolean");
            if (R(Z))
              return z.stylize("null", "null");
          }
          function b(z) {
            return "[" + Error.prototype.toString.call(z) + "]";
          }
          function w(z, Z, oe, ye, V) {
            for (var q = [], ee = 0, ue = Z.length; ee < ue; ++ee)
              ae(Z, String(ee)) ? q.push(x(
                z,
                Z,
                oe,
                ye,
                String(ee),
                !0
              )) : q.push("");
            return V.forEach(function(ge) {
              ge.match(/^\d+$/) || q.push(x(
                z,
                Z,
                oe,
                ye,
                ge,
                !0
              ));
            }), q;
          }
          function x(z, Z, oe, ye, V, q) {
            var ee, ue, ge;
            if (ge = Object.getOwnPropertyDescriptor(Z, V) || { value: Z[V] }, ge.get ? ge.set ? ue = z.stylize("[Getter/Setter]", "special") : ue = z.stylize("[Getter]", "special") : ge.set && (ue = z.stylize("[Setter]", "special")), ae(ye, V) || (ee = "[" + V + "]"), ue || (z.seen.indexOf(ge.value) < 0 ? (R(oe) ? ue = y(z, ge.value, null) : ue = y(z, ge.value, oe - 1), ue.indexOf(`
`) > -1 && (q ? ue = ue.split(`
`).map(function(he) {
              return "  " + he;
            }).join(`
`).substr(2) : ue = `
` + ue.split(`
`).map(function(he) {
              return "   " + he;
            }).join(`
`))) : ue = z.stylize("[Circular]", "special")), D(ee)) {
              if (q && V.match(/^\d+$/))
                return ue;
              ee = JSON.stringify("" + V), ee.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ee = ee.substr(1, ee.length - 2), ee = z.stylize(ee, "name")) : (ee = ee.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ee = z.stylize(ee, "string"));
            }
            return ee + ": " + ue;
          }
          function E(z, Z, oe) {
            var ye = z.reduce(function(V, q) {
              return q.indexOf(`
`) >= 0, V + q.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return ye > 60 ? oe[0] + (Z === "" ? "" : Z + `
 `) + " " + z.join(`,
  `) + " " + oe[1] : oe[0] + Z + " " + z.join(", ") + " " + oe[1];
          }
          function T(z) {
            return Array.isArray(z);
          }
          n.isArray = T;
          function C(z) {
            return typeof z == "boolean";
          }
          n.isBoolean = C;
          function R(z) {
            return z === null;
          }
          n.isNull = R;
          function A(z) {
            return z == null;
          }
          n.isNullOrUndefined = A;
          function j(z) {
            return typeof z == "number";
          }
          n.isNumber = j;
          function N(z) {
            return typeof z == "string";
          }
          n.isString = N;
          function O(z) {
            return typeof z == "symbol";
          }
          n.isSymbol = O;
          function D(z) {
            return z === void 0;
          }
          n.isUndefined = D;
          function H(z) {
            return G(z) && $(z) === "[object RegExp]";
          }
          n.isRegExp = H;
          function G(z) {
            return typeof z == "object" && z !== null;
          }
          n.isObject = G;
          function X(z) {
            return G(z) && $(z) === "[object Date]";
          }
          n.isDate = X;
          function Q(z) {
            return G(z) && ($(z) === "[object Error]" || z instanceof Error);
          }
          n.isError = Q;
          function M(z) {
            return typeof z == "function";
          }
          n.isFunction = M;
          function k(z) {
            return z === null || typeof z == "boolean" || typeof z == "number" || typeof z == "string" || typeof z == "symbol" || // ES6 symbol
            typeof z > "u";
          }
          n.isPrimitive = k, n.isBuffer = r("./support/isBuffer");
          function $(z) {
            return Object.prototype.toString.call(z);
          }
          function ne(z) {
            return z < 10 ? "0" + z.toString(10) : z.toString(10);
          }
          var te = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function de() {
            var z = /* @__PURE__ */ new Date(), Z = [
              ne(z.getHours()),
              ne(z.getMinutes()),
              ne(z.getSeconds())
            ].join(":");
            return [z.getDate(), te[z.getMonth()], Z].join(" ");
          }
          n.log = function() {
            console.log("%s - %s", de(), n.format.apply(n, arguments));
          }, n.inherits = r("inherits"), n._extend = function(z, Z) {
            if (!Z || !G(Z))
              return z;
            for (var oe = Object.keys(Z), ye = oe.length; ye--; )
              z[oe[ye]] = Z[oe[ye]];
            return z;
          };
          function ae(z, Z) {
            return Object.prototype.hasOwnProperty.call(z, Z);
          }
        }).call(this);
      }).call(this, r("_process"), typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = [
            "BigInt64Array",
            "BigUint64Array",
            "Float32Array",
            "Float64Array",
            "Int16Array",
            "Int32Array",
            "Int8Array",
            "Uint16Array",
            "Uint32Array",
            "Uint8Array",
            "Uint8ClampedArray"
          ], s = typeof globalThis > "u" ? i : globalThis;
          o.exports = function() {
            for (var c = [], p = 0; p < a.length; p++)
              typeof s[a[p]] == "function" && (c[c.length] = a[p]);
            return c;
          };
        }).call(this);
      }).call(this, typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 28: [function(r, o, n) {
      n.byteLength = u, n.toByteArray = y, n.fromByteArray = w;
      for (var i = [], a = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = 0, l = c.length; p < l; ++p)
        i[p] = c[p], a[c.charCodeAt(p)] = p;
      a[45] = 62, a[95] = 63;
      function d(x) {
        var E = x.length;
        if (E % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var T = x.indexOf("=");
        T === -1 && (T = E);
        var C = T === E ? 0 : 4 - T % 4;
        return [T, C];
      }
      function u(x) {
        var E = d(x), T = E[0], C = E[1];
        return (T + C) * 3 / 4 - C;
      }
      function h(x, E, T) {
        return (E + T) * 3 / 4 - T;
      }
      function y(x) {
        var E, T = d(x), C = T[0], R = T[1], A = new s(h(x, C, R)), j = 0, N = R > 0 ? C - 4 : C, O;
        for (O = 0; O < N; O += 4)
          E = a[x.charCodeAt(O)] << 18 | a[x.charCodeAt(O + 1)] << 12 | a[x.charCodeAt(O + 2)] << 6 | a[x.charCodeAt(O + 3)], A[j++] = E >> 16 & 255, A[j++] = E >> 8 & 255, A[j++] = E & 255;
        return R === 2 && (E = a[x.charCodeAt(O)] << 2 | a[x.charCodeAt(O + 1)] >> 4, A[j++] = E & 255), R === 1 && (E = a[x.charCodeAt(O)] << 10 | a[x.charCodeAt(O + 1)] << 4 | a[x.charCodeAt(O + 2)] >> 2, A[j++] = E >> 8 & 255, A[j++] = E & 255), A;
      }
      function f(x) {
        return i[x >> 18 & 63] + i[x >> 12 & 63] + i[x >> 6 & 63] + i[x & 63];
      }
      function b(x, E, T) {
        for (var C, R = [], A = E; A < T; A += 3)
          C = (x[A] << 16 & 16711680) + (x[A + 1] << 8 & 65280) + (x[A + 2] & 255), R.push(f(C));
        return R.join("");
      }
      function w(x) {
        for (var E, T = x.length, C = T % 3, R = [], A = 16383, j = 0, N = T - C; j < N; j += A)
          R.push(b(x, j, j + A > N ? N : j + A));
        return C === 1 ? (E = x[T - 1], R.push(
          i[E >> 2] + i[E << 4 & 63] + "=="
        )) : C === 2 && (E = (x[T - 2] << 8) + x[T - 1], R.push(
          i[E >> 10] + i[E >> 4 & 63] + i[E << 2 & 63] + "="
        )), R.join("");
      }
    }, {}], 29: [function(r, o, n) {
    }, {}], 30: [function(r, o, n) {
      (function(i, a) {
        (function() {
          var s = r("assert"), c = r("pako/lib/zlib/zstream"), p = r("pako/lib/zlib/deflate.js"), l = r("pako/lib/zlib/inflate.js"), d = r("pako/lib/zlib/constants");
          for (var u in d)
            n[u] = d[u];
          n.NONE = 0, n.DEFLATE = 1, n.INFLATE = 2, n.GZIP = 3, n.GUNZIP = 4, n.DEFLATERAW = 5, n.INFLATERAW = 6, n.UNZIP = 7;
          var h = 31, y = 139;
          function f(b) {
            if (typeof b != "number" || b < n.DEFLATE || b > n.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = b, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          f.prototype.close = function() {
            if (this.write_in_progress) {
              this.pending_close = !0;
              return;
            }
            this.pending_close = !1, s(this.init_done, "close before init"), s(this.mode <= n.UNZIP), this.mode === n.DEFLATE || this.mode === n.GZIP || this.mode === n.DEFLATERAW ? p.deflateEnd(this.strm) : (this.mode === n.INFLATE || this.mode === n.GUNZIP || this.mode === n.INFLATERAW || this.mode === n.UNZIP) && l.inflateEnd(this.strm), this.mode = n.NONE, this.dictionary = null;
          }, f.prototype.write = function(b, w, x, E, T, C, R) {
            return this._write(!0, b, w, x, E, T, C, R);
          }, f.prototype.writeSync = function(b, w, x, E, T, C, R) {
            return this._write(!1, b, w, x, E, T, C, R);
          }, f.prototype._write = function(b, w, x, E, T, C, R, A) {
            if (s.equal(arguments.length, 8), s(this.init_done, "write before init"), s(this.mode !== n.NONE, "already finalized"), s.equal(!1, this.write_in_progress, "write already in progress"), s.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, s.equal(!1, w === void 0, "must provide flush value"), this.write_in_progress = !0, w !== n.Z_NO_FLUSH && w !== n.Z_PARTIAL_FLUSH && w !== n.Z_SYNC_FLUSH && w !== n.Z_FULL_FLUSH && w !== n.Z_FINISH && w !== n.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (x == null && (x = a.alloc(0), T = 0, E = 0), this.strm.avail_in = T, this.strm.input = x, this.strm.next_in = E, this.strm.avail_out = A, this.strm.output = C, this.strm.next_out = R, this.flush = w, !b)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var j = this;
            return i.nextTick(function() {
              j._process(), j._after();
            }), this;
          }, f.prototype._afterSync = function() {
            var b = this.strm.avail_out, w = this.strm.avail_in;
            return this.write_in_progress = !1, [w, b];
          }, f.prototype._process = function() {
            var b = null;
            switch (this.mode) {
              case n.DEFLATE:
              case n.GZIP:
              case n.DEFLATERAW:
                this.err = p.deflate(this.strm, this.flush);
                break;
              case n.UNZIP:
                switch (this.strm.avail_in > 0 && (b = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (b === null)
                      break;
                    if (this.strm.input[b] === h) {
                      if (this.gzip_id_bytes_read = 1, b++, this.strm.avail_in === 1)
                        break;
                    } else {
                      this.mode = n.INFLATE;
                      break;
                    }
                  case 1:
                    if (b === null)
                      break;
                    this.strm.input[b] === y ? (this.gzip_id_bytes_read = 2, this.mode = n.GUNZIP) : this.mode = n.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              case n.INFLATE:
              case n.GUNZIP:
              case n.INFLATERAW:
                for (this.err = l.inflate(
                  this.strm,
                  this.flush
                  // If data was encoded with dictionary
                ), this.err === n.Z_NEED_DICT && this.dictionary && (this.err = l.inflateSetDictionary(this.strm, this.dictionary), this.err === n.Z_OK ? this.err = l.inflate(this.strm, this.flush) : this.err === n.Z_DATA_ERROR && (this.err = n.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === n.GUNZIP && this.err === n.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = l.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, f.prototype._checkError = function() {
            switch (this.err) {
              case n.Z_OK:
              case n.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === n.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case n.Z_STREAM_END:
                break;
              case n.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, f.prototype._after = function() {
            if (this._checkError()) {
              var b = this.strm.avail_out, w = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(w, b), this.pending_close && this.close();
            }
          }, f.prototype._error = function(b) {
            this.strm.msg && (b = this.strm.msg), this.onerror(
              b,
              this.err
              // no hope of rescue.
            ), this.write_in_progress = !1, this.pending_close && this.close();
          }, f.prototype.init = function(b, w, x, E, T) {
            s(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), s(b >= 8 && b <= 15, "invalid windowBits"), s(w >= -1 && w <= 9, "invalid compression level"), s(x >= 1 && x <= 9, "invalid memlevel"), s(E === n.Z_FILTERED || E === n.Z_HUFFMAN_ONLY || E === n.Z_RLE || E === n.Z_FIXED || E === n.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(w, b, x, E, T), this._setDictionary();
          }, f.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, f.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, f.prototype._init = function(b, w, x, E, T) {
            switch (this.level = b, this.windowBits = w, this.memLevel = x, this.strategy = E, this.flush = n.Z_NO_FLUSH, this.err = n.Z_OK, (this.mode === n.GZIP || this.mode === n.GUNZIP) && (this.windowBits += 16), this.mode === n.UNZIP && (this.windowBits += 32), (this.mode === n.DEFLATERAW || this.mode === n.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new c(), this.mode) {
              case n.DEFLATE:
              case n.GZIP:
              case n.DEFLATERAW:
                this.err = p.deflateInit2(this.strm, this.level, n.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case n.INFLATE:
              case n.GUNZIP:
              case n.INFLATERAW:
              case n.UNZIP:
                this.err = l.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== n.Z_OK && this._error("Init error"), this.dictionary = T, this.write_in_progress = !1, this.init_done = !0;
          }, f.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = n.Z_OK, this.mode) {
                case n.DEFLATE:
                case n.DEFLATERAW:
                  this.err = p.deflateSetDictionary(this.strm, this.dictionary);
                  break;
              }
              this.err !== n.Z_OK && this._error("Failed to set dictionary");
            }
          }, f.prototype._reset = function() {
            switch (this.err = n.Z_OK, this.mode) {
              case n.DEFLATE:
              case n.DEFLATERAW:
              case n.GZIP:
                this.err = p.deflateReset(this.strm);
                break;
              case n.INFLATE:
              case n.INFLATERAW:
              case n.GUNZIP:
                this.err = l.inflateReset(this.strm);
                break;
            }
            this.err !== n.Z_OK && this._error("Failed to reset stream");
          }, n.Zlib = f;
        }).call(this);
      }).call(this, r("_process"), r("buffer").Buffer);
    }, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = r("buffer").Buffer, s = r("stream").Transform, c = r("./binding"), p = r("util"), l = r("assert").ok, d = r("buffer").kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + d.toString(16) + " bytes";
          c.Z_MIN_WINDOWBITS = 8, c.Z_MAX_WINDOWBITS = 15, c.Z_DEFAULT_WINDOWBITS = 15, c.Z_MIN_CHUNK = 64, c.Z_MAX_CHUNK = 1 / 0, c.Z_DEFAULT_CHUNK = 16 * 1024, c.Z_MIN_MEMLEVEL = 1, c.Z_MAX_MEMLEVEL = 9, c.Z_DEFAULT_MEMLEVEL = 8, c.Z_MIN_LEVEL = -1, c.Z_MAX_LEVEL = 9, c.Z_DEFAULT_LEVEL = c.Z_DEFAULT_COMPRESSION;
          for (var h = Object.keys(c), y = 0; y < h.length; y++) {
            var f = h[y];
            f.match(/^Z/) && Object.defineProperty(n, f, {
              enumerable: !0,
              value: c[f],
              writable: !1
            });
          }
          for (var b = {
            Z_OK: c.Z_OK,
            Z_STREAM_END: c.Z_STREAM_END,
            Z_NEED_DICT: c.Z_NEED_DICT,
            Z_ERRNO: c.Z_ERRNO,
            Z_STREAM_ERROR: c.Z_STREAM_ERROR,
            Z_DATA_ERROR: c.Z_DATA_ERROR,
            Z_MEM_ERROR: c.Z_MEM_ERROR,
            Z_BUF_ERROR: c.Z_BUF_ERROR,
            Z_VERSION_ERROR: c.Z_VERSION_ERROR
          }, w = Object.keys(b), x = 0; x < w.length; x++) {
            var E = w[x];
            b[b[E]] = E;
          }
          Object.defineProperty(n, "codes", {
            enumerable: !0,
            value: Object.freeze(b),
            writable: !1
          }), n.Deflate = R, n.Inflate = A, n.Gzip = j, n.Gunzip = N, n.DeflateRaw = O, n.InflateRaw = D, n.Unzip = H, n.createDeflate = function(k) {
            return new R(k);
          }, n.createInflate = function(k) {
            return new A(k);
          }, n.createDeflateRaw = function(k) {
            return new O(k);
          }, n.createInflateRaw = function(k) {
            return new D(k);
          }, n.createGzip = function(k) {
            return new j(k);
          }, n.createGunzip = function(k) {
            return new N(k);
          }, n.createUnzip = function(k) {
            return new H(k);
          }, n.deflate = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new R($), k, ne);
          }, n.deflateSync = function(k, $) {
            return C(new R($), k);
          }, n.gzip = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new j($), k, ne);
          }, n.gzipSync = function(k, $) {
            return C(new j($), k);
          }, n.deflateRaw = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new O($), k, ne);
          }, n.deflateRawSync = function(k, $) {
            return C(new O($), k);
          }, n.unzip = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new H($), k, ne);
          }, n.unzipSync = function(k, $) {
            return C(new H($), k);
          }, n.inflate = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new A($), k, ne);
          }, n.inflateSync = function(k, $) {
            return C(new A($), k);
          }, n.gunzip = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new N($), k, ne);
          }, n.gunzipSync = function(k, $) {
            return C(new N($), k);
          }, n.inflateRaw = function(k, $, ne) {
            return typeof $ == "function" && (ne = $, $ = {}), T(new D($), k, ne);
          }, n.inflateRawSync = function(k, $) {
            return C(new D($), k);
          };
          function T(k, $, ne) {
            var te = [], de = 0;
            k.on("error", z), k.on("end", Z), k.end($), ae();
            function ae() {
              for (var oe; (oe = k.read()) !== null; )
                te.push(oe), de += oe.length;
              k.once("readable", ae);
            }
            function z(oe) {
              k.removeListener("end", Z), k.removeListener("readable", ae), ne(oe);
            }
            function Z() {
              var oe, ye = null;
              de >= d ? ye = new RangeError(u) : oe = a.concat(te, de), te = [], k.close(), ne(ye, oe);
            }
          }
          function C(k, $) {
            if (typeof $ == "string" && ($ = a.from($)), !a.isBuffer($))
              throw new TypeError("Not a string or buffer");
            var ne = k._finishFlushFlag;
            return k._processChunk($, ne);
          }
          function R(k) {
            if (!(this instanceof R))
              return new R(k);
            X.call(this, k, c.DEFLATE);
          }
          function A(k) {
            if (!(this instanceof A))
              return new A(k);
            X.call(this, k, c.INFLATE);
          }
          function j(k) {
            if (!(this instanceof j))
              return new j(k);
            X.call(this, k, c.GZIP);
          }
          function N(k) {
            if (!(this instanceof N))
              return new N(k);
            X.call(this, k, c.GUNZIP);
          }
          function O(k) {
            if (!(this instanceof O))
              return new O(k);
            X.call(this, k, c.DEFLATERAW);
          }
          function D(k) {
            if (!(this instanceof D))
              return new D(k);
            X.call(this, k, c.INFLATERAW);
          }
          function H(k) {
            if (!(this instanceof H))
              return new H(k);
            X.call(this, k, c.UNZIP);
          }
          function G(k) {
            return k === c.Z_NO_FLUSH || k === c.Z_PARTIAL_FLUSH || k === c.Z_SYNC_FLUSH || k === c.Z_FULL_FLUSH || k === c.Z_FINISH || k === c.Z_BLOCK;
          }
          function X(k, $) {
            var ne = this;
            if (this._opts = k = k || {}, this._chunkSize = k.chunkSize || n.Z_DEFAULT_CHUNK, s.call(this, k), k.flush && !G(k.flush))
              throw new Error("Invalid flush flag: " + k.flush);
            if (k.finishFlush && !G(k.finishFlush))
              throw new Error("Invalid flush flag: " + k.finishFlush);
            if (this._flushFlag = k.flush || c.Z_NO_FLUSH, this._finishFlushFlag = typeof k.finishFlush < "u" ? k.finishFlush : c.Z_FINISH, k.chunkSize && (k.chunkSize < n.Z_MIN_CHUNK || k.chunkSize > n.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + k.chunkSize);
            if (k.windowBits && (k.windowBits < n.Z_MIN_WINDOWBITS || k.windowBits > n.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + k.windowBits);
            if (k.level && (k.level < n.Z_MIN_LEVEL || k.level > n.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + k.level);
            if (k.memLevel && (k.memLevel < n.Z_MIN_MEMLEVEL || k.memLevel > n.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + k.memLevel);
            if (k.strategy && k.strategy != n.Z_FILTERED && k.strategy != n.Z_HUFFMAN_ONLY && k.strategy != n.Z_RLE && k.strategy != n.Z_FIXED && k.strategy != n.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + k.strategy);
            if (k.dictionary && !a.isBuffer(k.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new c.Zlib($);
            var te = this;
            this._hadError = !1, this._handle.onerror = function(z, Z) {
              Q(te), te._hadError = !0;
              var oe = new Error(z);
              oe.errno = Z, oe.code = n.codes[Z], te.emit("error", oe);
            };
            var de = n.Z_DEFAULT_COMPRESSION;
            typeof k.level == "number" && (de = k.level);
            var ae = n.Z_DEFAULT_STRATEGY;
            typeof k.strategy == "number" && (ae = k.strategy), this._handle.init(k.windowBits || n.Z_DEFAULT_WINDOWBITS, de, k.memLevel || n.Z_DEFAULT_MEMLEVEL, ae, k.dictionary), this._buffer = a.allocUnsafe(this._chunkSize), this._offset = 0, this._level = de, this._strategy = ae, this.once("end", this.close), Object.defineProperty(this, "_closed", {
              get: function() {
                return !ne._handle;
              },
              configurable: !0,
              enumerable: !0
            });
          }
          p.inherits(X, s), X.prototype.params = function(k, $, ne) {
            if (k < n.Z_MIN_LEVEL || k > n.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + k);
            if ($ != n.Z_FILTERED && $ != n.Z_HUFFMAN_ONLY && $ != n.Z_RLE && $ != n.Z_FIXED && $ != n.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + $);
            if (this._level !== k || this._strategy !== $) {
              var te = this;
              this.flush(c.Z_SYNC_FLUSH, function() {
                l(te._handle, "zlib binding closed"), te._handle.params(k, $), te._hadError || (te._level = k, te._strategy = $, ne && ne());
              });
            } else
              i.nextTick(ne);
          }, X.prototype.reset = function() {
            return l(this._handle, "zlib binding closed"), this._handle.reset();
          }, X.prototype._flush = function(k) {
            this._transform(a.alloc(0), "", k);
          }, X.prototype.flush = function(k, $) {
            var ne = this, te = this._writableState;
            (typeof k == "function" || k === void 0 && !$) && ($ = k, k = c.Z_FULL_FLUSH), te.ended ? $ && i.nextTick($) : te.ending ? $ && this.once("end", $) : te.needDrain ? $ && this.once("drain", function() {
              return ne.flush(k, $);
            }) : (this._flushFlag = k, this.write(a.alloc(0), "", $));
          }, X.prototype.close = function(k) {
            Q(this, k), i.nextTick(M, this);
          };
          function Q(k, $) {
            $ && i.nextTick($), k._handle && (k._handle.close(), k._handle = null);
          }
          function M(k) {
            k.emit("close");
          }
          X.prototype._transform = function(k, $, ne) {
            var te, de = this._writableState, ae = de.ending || de.ended, z = ae && (!k || de.length === k.length);
            if (k !== null && !a.isBuffer(k))
              return ne(new Error("invalid input"));
            if (!this._handle)
              return ne(new Error("zlib binding closed"));
            z ? te = this._finishFlushFlag : (te = this._flushFlag, k.length >= de.length && (this._flushFlag = this._opts.flush || c.Z_NO_FLUSH)), this._processChunk(k, te, ne);
          }, X.prototype._processChunk = function(k, $, ne) {
            var te = k && k.length, de = this._chunkSize - this._offset, ae = 0, z = this, Z = typeof ne == "function";
            if (!Z) {
              var oe = [], ye = 0, V;
              this.on("error", function(he) {
                V = he;
              }), l(this._handle, "zlib binding closed");
              do
                var q = this._handle.writeSync(
                  $,
                  k,
                  // in
                  ae,
                  // in_off
                  te,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  de
                );
              while (!this._hadError && ge(q[0], q[1]));
              if (this._hadError)
                throw V;
              if (ye >= d)
                throw Q(this), new RangeError(u);
              var ee = a.concat(oe, ye);
              return Q(this), ee;
            }
            l(this._handle, "zlib binding closed");
            var ue = this._handle.write(
              $,
              k,
              // in
              ae,
              // in_off
              te,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              de
            );
            ue.buffer = k, ue.callback = ge;
            function ge(he, W) {
              if (this && (this.buffer = null, this.callback = null), !z._hadError) {
                var Y = de - W;
                if (l(Y >= 0, "have should not go down"), Y > 0) {
                  var se = z._buffer.slice(z._offset, z._offset + Y);
                  z._offset += Y, Z ? z.push(se) : (oe.push(se), ye += se.length);
                }
                if ((W === 0 || z._offset >= z._chunkSize) && (de = z._chunkSize, z._offset = 0, z._buffer = a.allocUnsafe(z._chunkSize)), W === 0) {
                  if (ae += te - he, te = he, !Z)
                    return !0;
                  var Te = z._handle.write($, k, ae, te, z._buffer, z._offset, z._chunkSize);
                  Te.callback = ge, Te.buffer = k;
                  return;
                }
                if (!Z)
                  return !1;
                ne();
              }
            }
          }, p.inherits(R, X), p.inherits(A, X), p.inherits(j, X), p.inherits(N, X), p.inherits(O, X), p.inherits(D, X), p.inherits(H, X);
        }).call(this);
      }).call(this, r("_process"));
    }, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = r("base64-js"), s = r("ieee754");
          n.Buffer = d, n.SlowBuffer = C, n.INSPECT_MAX_BYTES = 50;
          var c = 2147483647;
          n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = p(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
          function p() {
            try {
              var _ = new Uint8Array(1);
              return _.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, _.foo() === 42;
            } catch {
              return !1;
            }
          }
          Object.defineProperty(d.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (d.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(d.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (d.isBuffer(this))
                return this.byteOffset;
            }
          });
          function l(_) {
            if (_ > c)
              throw new RangeError('The value "' + _ + '" is invalid for option "size"');
            var v = new Uint8Array(_);
            return v.__proto__ = d.prototype, v;
          }
          function d(_, v, S) {
            if (typeof _ == "number") {
              if (typeof v == "string")
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return f(_);
            }
            return u(_, v, S);
          }
          typeof Symbol < "u" && Symbol.species != null && d[Symbol.species] === d && Object.defineProperty(d, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), d.poolSize = 8192;
          function u(_, v, S) {
            if (typeof _ == "string")
              return b(_, v);
            if (ArrayBuffer.isView(_))
              return w(_);
            if (_ == null)
              throw TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
              );
            if (B(_, ArrayBuffer) || _ && B(_.buffer, ArrayBuffer))
              return x(_, v, S);
            if (typeof _ == "number")
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            var P = _.valueOf && _.valueOf();
            if (P != null && P !== _)
              return d.from(P, v, S);
            var J = E(_);
            if (J)
              return J;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof _[Symbol.toPrimitive] == "function")
              return d.from(
                _[Symbol.toPrimitive]("string"),
                v,
                S
              );
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
            );
          }
          d.from = function(_, v, S) {
            return u(_, v, S);
          }, d.prototype.__proto__ = Uint8Array.prototype, d.__proto__ = Uint8Array;
          function h(_) {
            if (typeof _ != "number")
              throw new TypeError('"size" argument must be of type number');
            if (_ < 0)
              throw new RangeError('The value "' + _ + '" is invalid for option "size"');
          }
          function y(_, v, S) {
            return h(_), _ <= 0 ? l(_) : v !== void 0 ? typeof S == "string" ? l(_).fill(v, S) : l(_).fill(v) : l(_);
          }
          d.alloc = function(_, v, S) {
            return y(_, v, S);
          };
          function f(_) {
            return h(_), l(_ < 0 ? 0 : T(_) | 0);
          }
          d.allocUnsafe = function(_) {
            return f(_);
          }, d.allocUnsafeSlow = function(_) {
            return f(_);
          };
          function b(_, v) {
            if ((typeof v != "string" || v === "") && (v = "utf8"), !d.isEncoding(v))
              throw new TypeError("Unknown encoding: " + v);
            var S = R(_, v) | 0, P = l(S), J = P.write(_, v);
            return J !== S && (P = P.slice(0, J)), P;
          }
          function w(_) {
            for (var v = _.length < 0 ? 0 : T(_.length) | 0, S = l(v), P = 0; P < v; P += 1)
              S[P] = _[P] & 255;
            return S;
          }
          function x(_, v, S) {
            if (v < 0 || _.byteLength < v)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (_.byteLength < v + (S || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var P;
            return v === void 0 && S === void 0 ? P = new Uint8Array(_) : S === void 0 ? P = new Uint8Array(_, v) : P = new Uint8Array(_, v, S), P.__proto__ = d.prototype, P;
          }
          function E(_) {
            if (d.isBuffer(_)) {
              var v = T(_.length) | 0, S = l(v);
              return S.length === 0 || _.copy(S, 0, 0, v), S;
            }
            if (_.length !== void 0)
              return typeof _.length != "number" || U(_.length) ? l(0) : w(_);
            if (_.type === "Buffer" && Array.isArray(_.data))
              return w(_.data);
          }
          function T(_) {
            if (_ >= c)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
            return _ | 0;
          }
          function C(_) {
            return +_ != _ && (_ = 0), d.alloc(+_);
          }
          d.isBuffer = function(_) {
            return _ != null && _._isBuffer === !0 && _ !== d.prototype;
          }, d.compare = function(_, v) {
            if (B(_, Uint8Array) && (_ = d.from(_, _.offset, _.byteLength)), B(v, Uint8Array) && (v = d.from(v, v.offset, v.byteLength)), !d.isBuffer(_) || !d.isBuffer(v))
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (_ === v)
              return 0;
            for (var S = _.length, P = v.length, J = 0, ve = Math.min(S, P); J < ve; ++J)
              if (_[J] !== v[J]) {
                S = _[J], P = v[J];
                break;
              }
            return S < P ? -1 : P < S ? 1 : 0;
          }, d.isEncoding = function(_) {
            switch (String(_).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, d.concat = function(_, v) {
            if (!Array.isArray(_))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (_.length === 0)
              return d.alloc(0);
            var S;
            if (v === void 0)
              for (v = 0, S = 0; S < _.length; ++S)
                v += _[S].length;
            var P = d.allocUnsafe(v), J = 0;
            for (S = 0; S < _.length; ++S) {
              var ve = _[S];
              if (B(ve, Uint8Array) && (ve = d.from(ve)), !d.isBuffer(ve))
                throw new TypeError('"list" argument must be an Array of Buffers');
              ve.copy(P, J), J += ve.length;
            }
            return P;
          };
          function R(_, v) {
            if (d.isBuffer(_))
              return _.length;
            if (ArrayBuffer.isView(_) || B(_, ArrayBuffer))
              return _.byteLength;
            if (typeof _ != "string")
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof _
              );
            var S = _.length, P = arguments.length > 2 && arguments[2] === !0;
            if (!P && S === 0)
              return 0;
            for (var J = !1; ; )
              switch (v) {
                case "ascii":
                case "latin1":
                case "binary":
                  return S;
                case "utf8":
                case "utf-8":
                  return W(_).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return S * 2;
                case "hex":
                  return S >>> 1;
                case "base64":
                  return Te(_).length;
                default:
                  if (J)
                    return P ? -1 : W(_).length;
                  v = ("" + v).toLowerCase(), J = !0;
              }
          }
          d.byteLength = R;
          function A(_, v, S) {
            var P = !1;
            if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, v >>>= 0, S <= v))
              return "";
            for (_ || (_ = "utf8"); ; )
              switch (_) {
                case "hex":
                  return z(this, v, S);
                case "utf8":
                case "utf-8":
                  return $(this, v, S);
                case "ascii":
                  return de(this, v, S);
                case "latin1":
                case "binary":
                  return ae(this, v, S);
                case "base64":
                  return k(this, v, S);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return Z(this, v, S);
                default:
                  if (P)
                    throw new TypeError("Unknown encoding: " + _);
                  _ = (_ + "").toLowerCase(), P = !0;
              }
          }
          d.prototype._isBuffer = !0;
          function j(_, v, S) {
            var P = _[v];
            _[v] = _[S], _[S] = P;
          }
          d.prototype.swap16 = function() {
            var _ = this.length;
            if (_ % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var v = 0; v < _; v += 2)
              j(this, v, v + 1);
            return this;
          }, d.prototype.swap32 = function() {
            var _ = this.length;
            if (_ % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var v = 0; v < _; v += 4)
              j(this, v, v + 3), j(this, v + 1, v + 2);
            return this;
          }, d.prototype.swap64 = function() {
            var _ = this.length;
            if (_ % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var v = 0; v < _; v += 8)
              j(this, v, v + 7), j(this, v + 1, v + 6), j(this, v + 2, v + 5), j(this, v + 3, v + 4);
            return this;
          }, d.prototype.toString = function() {
            var _ = this.length;
            return _ === 0 ? "" : arguments.length === 0 ? $(this, 0, _) : A.apply(this, arguments);
          }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(_) {
            if (!d.isBuffer(_))
              throw new TypeError("Argument must be a Buffer");
            return this === _ ? !0 : d.compare(this, _) === 0;
          }, d.prototype.inspect = function() {
            var _ = "", v = n.INSPECT_MAX_BYTES;
            return _ = this.toString("hex", 0, v).replace(/(.{2})/g, "$1 ").trim(), this.length > v && (_ += " ... "), "<Buffer " + _ + ">";
          }, d.prototype.compare = function(_, v, S, P, J) {
            if (B(_, Uint8Array) && (_ = d.from(_, _.offset, _.byteLength)), !d.isBuffer(_))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof _
              );
            if (v === void 0 && (v = 0), S === void 0 && (S = _ ? _.length : 0), P === void 0 && (P = 0), J === void 0 && (J = this.length), v < 0 || S > _.length || P < 0 || J > this.length)
              throw new RangeError("out of range index");
            if (P >= J && v >= S)
              return 0;
            if (P >= J)
              return -1;
            if (v >= S)
              return 1;
            if (v >>>= 0, S >>>= 0, P >>>= 0, J >>>= 0, this === _)
              return 0;
            for (var ve = J - P, Re = S - v, je = Math.min(ve, Re), qe = this.slice(P, J), ze = _.slice(v, S), We = 0; We < je; ++We)
              if (qe[We] !== ze[We]) {
                ve = qe[We], Re = ze[We];
                break;
              }
            return ve < Re ? -1 : Re < ve ? 1 : 0;
          };
          function N(_, v, S, P, J) {
            if (_.length === 0)
              return -1;
            if (typeof S == "string" ? (P = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, U(S) && (S = J ? 0 : _.length - 1), S < 0 && (S = _.length + S), S >= _.length) {
              if (J)
                return -1;
              S = _.length - 1;
            } else if (S < 0)
              if (J)
                S = 0;
              else
                return -1;
            if (typeof v == "string" && (v = d.from(v, P)), d.isBuffer(v))
              return v.length === 0 ? -1 : O(_, v, S, P, J);
            if (typeof v == "number")
              return v = v & 255, typeof Uint8Array.prototype.indexOf == "function" ? J ? Uint8Array.prototype.indexOf.call(_, v, S) : Uint8Array.prototype.lastIndexOf.call(_, v, S) : O(_, [v], S, P, J);
            throw new TypeError("val must be string, number or Buffer");
          }
          function O(_, v, S, P, J) {
            var ve = 1, Re = _.length, je = v.length;
            if (P !== void 0 && (P = String(P).toLowerCase(), P === "ucs2" || P === "ucs-2" || P === "utf16le" || P === "utf-16le")) {
              if (_.length < 2 || v.length < 2)
                return -1;
              ve = 2, Re /= 2, je /= 2, S /= 2;
            }
            function qe(Ge, Je) {
              return ve === 1 ? Ge[Je] : Ge.readUInt16BE(Je * ve);
            }
            var ze;
            if (J) {
              var We = -1;
              for (ze = S; ze < Re; ze++)
                if (qe(_, ze) === qe(v, We === -1 ? 0 : ze - We)) {
                  if (We === -1 && (We = ze), ze - We + 1 === je)
                    return We * ve;
                } else
                  We !== -1 && (ze -= ze - We), We = -1;
            } else
              for (S + je > Re && (S = Re - je), ze = S; ze >= 0; ze--) {
                for (var Fe = !0, rt = 0; rt < je; rt++)
                  if (qe(_, ze + rt) !== qe(v, rt)) {
                    Fe = !1;
                    break;
                  }
                if (Fe)
                  return ze;
              }
            return -1;
          }
          d.prototype.includes = function(_, v, S) {
            return this.indexOf(_, v, S) !== -1;
          }, d.prototype.indexOf = function(_, v, S) {
            return N(this, _, v, S, !0);
          }, d.prototype.lastIndexOf = function(_, v, S) {
            return N(this, _, v, S, !1);
          };
          function D(_, v, S, P) {
            S = Number(S) || 0;
            var J = _.length - S;
            P ? (P = Number(P), P > J && (P = J)) : P = J;
            var ve = v.length;
            P > ve / 2 && (P = ve / 2);
            for (var Re = 0; Re < P; ++Re) {
              var je = parseInt(v.substr(Re * 2, 2), 16);
              if (U(je))
                return Re;
              _[S + Re] = je;
            }
            return Re;
          }
          function H(_, v, S, P) {
            return Oe(W(v, _.length - S), _, S, P);
          }
          function G(_, v, S, P) {
            return Oe(Y(v), _, S, P);
          }
          function X(_, v, S, P) {
            return G(_, v, S, P);
          }
          function Q(_, v, S, P) {
            return Oe(Te(v), _, S, P);
          }
          function M(_, v, S, P) {
            return Oe(se(v, _.length - S), _, S, P);
          }
          d.prototype.write = function(_, v, S, P) {
            if (v === void 0)
              P = "utf8", S = this.length, v = 0;
            else if (S === void 0 && typeof v == "string")
              P = v, S = this.length, v = 0;
            else if (isFinite(v))
              v = v >>> 0, isFinite(S) ? (S = S >>> 0, P === void 0 && (P = "utf8")) : (P = S, S = void 0);
            else
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            var J = this.length - v;
            if ((S === void 0 || S > J) && (S = J), _.length > 0 && (S < 0 || v < 0) || v > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            P || (P = "utf8");
            for (var ve = !1; ; )
              switch (P) {
                case "hex":
                  return D(this, _, v, S);
                case "utf8":
                case "utf-8":
                  return H(this, _, v, S);
                case "ascii":
                  return G(this, _, v, S);
                case "latin1":
                case "binary":
                  return X(this, _, v, S);
                case "base64":
                  return Q(this, _, v, S);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return M(this, _, v, S);
                default:
                  if (ve)
                    throw new TypeError("Unknown encoding: " + P);
                  P = ("" + P).toLowerCase(), ve = !0;
              }
          }, d.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function k(_, v, S) {
            return v === 0 && S === _.length ? a.fromByteArray(_) : a.fromByteArray(_.slice(v, S));
          }
          function $(_, v, S) {
            S = Math.min(_.length, S);
            for (var P = [], J = v; J < S; ) {
              var ve = _[J], Re = null, je = ve > 239 ? 4 : ve > 223 ? 3 : ve > 191 ? 2 : 1;
              if (J + je <= S) {
                var qe, ze, We, Fe;
                switch (je) {
                  case 1:
                    ve < 128 && (Re = ve);
                    break;
                  case 2:
                    qe = _[J + 1], (qe & 192) === 128 && (Fe = (ve & 31) << 6 | qe & 63, Fe > 127 && (Re = Fe));
                    break;
                  case 3:
                    qe = _[J + 1], ze = _[J + 2], (qe & 192) === 128 && (ze & 192) === 128 && (Fe = (ve & 15) << 12 | (qe & 63) << 6 | ze & 63, Fe > 2047 && (Fe < 55296 || Fe > 57343) && (Re = Fe));
                    break;
                  case 4:
                    qe = _[J + 1], ze = _[J + 2], We = _[J + 3], (qe & 192) === 128 && (ze & 192) === 128 && (We & 192) === 128 && (Fe = (ve & 15) << 18 | (qe & 63) << 12 | (ze & 63) << 6 | We & 63, Fe > 65535 && Fe < 1114112 && (Re = Fe));
                }
              }
              Re === null ? (Re = 65533, je = 1) : Re > 65535 && (Re -= 65536, P.push(Re >>> 10 & 1023 | 55296), Re = 56320 | Re & 1023), P.push(Re), J += je;
            }
            return te(P);
          }
          var ne = 4096;
          function te(_) {
            var v = _.length;
            if (v <= ne)
              return String.fromCharCode.apply(String, _);
            for (var S = "", P = 0; P < v; )
              S += String.fromCharCode.apply(
                String,
                _.slice(P, P += ne)
              );
            return S;
          }
          function de(_, v, S) {
            var P = "";
            S = Math.min(_.length, S);
            for (var J = v; J < S; ++J)
              P += String.fromCharCode(_[J] & 127);
            return P;
          }
          function ae(_, v, S) {
            var P = "";
            S = Math.min(_.length, S);
            for (var J = v; J < S; ++J)
              P += String.fromCharCode(_[J]);
            return P;
          }
          function z(_, v, S) {
            var P = _.length;
            (!v || v < 0) && (v = 0), (!S || S < 0 || S > P) && (S = P);
            for (var J = "", ve = v; ve < S; ++ve)
              J += he(_[ve]);
            return J;
          }
          function Z(_, v, S) {
            for (var P = _.slice(v, S), J = "", ve = 0; ve < P.length; ve += 2)
              J += String.fromCharCode(P[ve] + P[ve + 1] * 256);
            return J;
          }
          d.prototype.slice = function(_, v) {
            var S = this.length;
            _ = ~~_, v = v === void 0 ? S : ~~v, _ < 0 ? (_ += S, _ < 0 && (_ = 0)) : _ > S && (_ = S), v < 0 ? (v += S, v < 0 && (v = 0)) : v > S && (v = S), v < _ && (v = _);
            var P = this.subarray(_, v);
            return P.__proto__ = d.prototype, P;
          };
          function oe(_, v, S) {
            if (_ % 1 !== 0 || _ < 0)
              throw new RangeError("offset is not uint");
            if (_ + v > S)
              throw new RangeError("Trying to access beyond buffer length");
          }
          d.prototype.readUIntLE = function(_, v, S) {
            _ = _ >>> 0, v = v >>> 0, S || oe(_, v, this.length);
            for (var P = this[_], J = 1, ve = 0; ++ve < v && (J *= 256); )
              P += this[_ + ve] * J;
            return P;
          }, d.prototype.readUIntBE = function(_, v, S) {
            _ = _ >>> 0, v = v >>> 0, S || oe(_, v, this.length);
            for (var P = this[_ + --v], J = 1; v > 0 && (J *= 256); )
              P += this[_ + --v] * J;
            return P;
          }, d.prototype.readUInt8 = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 1, this.length), this[_];
          }, d.prototype.readUInt16LE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 2, this.length), this[_] | this[_ + 1] << 8;
          }, d.prototype.readUInt16BE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 2, this.length), this[_] << 8 | this[_ + 1];
          }, d.prototype.readUInt32LE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), (this[_] | this[_ + 1] << 8 | this[_ + 2] << 16) + this[_ + 3] * 16777216;
          }, d.prototype.readUInt32BE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), this[_] * 16777216 + (this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3]);
          }, d.prototype.readIntLE = function(_, v, S) {
            _ = _ >>> 0, v = v >>> 0, S || oe(_, v, this.length);
            for (var P = this[_], J = 1, ve = 0; ++ve < v && (J *= 256); )
              P += this[_ + ve] * J;
            return J *= 128, P >= J && (P -= Math.pow(2, 8 * v)), P;
          }, d.prototype.readIntBE = function(_, v, S) {
            _ = _ >>> 0, v = v >>> 0, S || oe(_, v, this.length);
            for (var P = v, J = 1, ve = this[_ + --P]; P > 0 && (J *= 256); )
              ve += this[_ + --P] * J;
            return J *= 128, ve >= J && (ve -= Math.pow(2, 8 * v)), ve;
          }, d.prototype.readInt8 = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 1, this.length), this[_] & 128 ? (255 - this[_] + 1) * -1 : this[_];
          }, d.prototype.readInt16LE = function(_, v) {
            _ = _ >>> 0, v || oe(_, 2, this.length);
            var S = this[_] | this[_ + 1] << 8;
            return S & 32768 ? S | 4294901760 : S;
          }, d.prototype.readInt16BE = function(_, v) {
            _ = _ >>> 0, v || oe(_, 2, this.length);
            var S = this[_ + 1] | this[_] << 8;
            return S & 32768 ? S | 4294901760 : S;
          }, d.prototype.readInt32LE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), this[_] | this[_ + 1] << 8 | this[_ + 2] << 16 | this[_ + 3] << 24;
          }, d.prototype.readInt32BE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), this[_] << 24 | this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3];
          }, d.prototype.readFloatLE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), s.read(this, _, !0, 23, 4);
          }, d.prototype.readFloatBE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 4, this.length), s.read(this, _, !1, 23, 4);
          }, d.prototype.readDoubleLE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 8, this.length), s.read(this, _, !0, 52, 8);
          }, d.prototype.readDoubleBE = function(_, v) {
            return _ = _ >>> 0, v || oe(_, 8, this.length), s.read(this, _, !1, 52, 8);
          };
          function ye(_, v, S, P, J, ve) {
            if (!d.isBuffer(_))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (v > J || v < ve)
              throw new RangeError('"value" argument is out of bounds');
            if (S + P > _.length)
              throw new RangeError("Index out of range");
          }
          d.prototype.writeUIntLE = function(_, v, S, P) {
            if (_ = +_, v = v >>> 0, S = S >>> 0, !P) {
              var J = Math.pow(2, 8 * S) - 1;
              ye(this, _, v, S, J, 0);
            }
            var ve = 1, Re = 0;
            for (this[v] = _ & 255; ++Re < S && (ve *= 256); )
              this[v + Re] = _ / ve & 255;
            return v + S;
          }, d.prototype.writeUIntBE = function(_, v, S, P) {
            if (_ = +_, v = v >>> 0, S = S >>> 0, !P) {
              var J = Math.pow(2, 8 * S) - 1;
              ye(this, _, v, S, J, 0);
            }
            var ve = S - 1, Re = 1;
            for (this[v + ve] = _ & 255; --ve >= 0 && (Re *= 256); )
              this[v + ve] = _ / Re & 255;
            return v + S;
          }, d.prototype.writeUInt8 = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 1, 255, 0), this[v] = _ & 255, v + 1;
          }, d.prototype.writeUInt16LE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 2, 65535, 0), this[v] = _ & 255, this[v + 1] = _ >>> 8, v + 2;
          }, d.prototype.writeUInt16BE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 2, 65535, 0), this[v] = _ >>> 8, this[v + 1] = _ & 255, v + 2;
          }, d.prototype.writeUInt32LE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 4, 4294967295, 0), this[v + 3] = _ >>> 24, this[v + 2] = _ >>> 16, this[v + 1] = _ >>> 8, this[v] = _ & 255, v + 4;
          }, d.prototype.writeUInt32BE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 4, 4294967295, 0), this[v] = _ >>> 24, this[v + 1] = _ >>> 16, this[v + 2] = _ >>> 8, this[v + 3] = _ & 255, v + 4;
          }, d.prototype.writeIntLE = function(_, v, S, P) {
            if (_ = +_, v = v >>> 0, !P) {
              var J = Math.pow(2, 8 * S - 1);
              ye(this, _, v, S, J - 1, -J);
            }
            var ve = 0, Re = 1, je = 0;
            for (this[v] = _ & 255; ++ve < S && (Re *= 256); )
              _ < 0 && je === 0 && this[v + ve - 1] !== 0 && (je = 1), this[v + ve] = (_ / Re >> 0) - je & 255;
            return v + S;
          }, d.prototype.writeIntBE = function(_, v, S, P) {
            if (_ = +_, v = v >>> 0, !P) {
              var J = Math.pow(2, 8 * S - 1);
              ye(this, _, v, S, J - 1, -J);
            }
            var ve = S - 1, Re = 1, je = 0;
            for (this[v + ve] = _ & 255; --ve >= 0 && (Re *= 256); )
              _ < 0 && je === 0 && this[v + ve + 1] !== 0 && (je = 1), this[v + ve] = (_ / Re >> 0) - je & 255;
            return v + S;
          }, d.prototype.writeInt8 = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 1, 127, -128), _ < 0 && (_ = 255 + _ + 1), this[v] = _ & 255, v + 1;
          }, d.prototype.writeInt16LE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 2, 32767, -32768), this[v] = _ & 255, this[v + 1] = _ >>> 8, v + 2;
          }, d.prototype.writeInt16BE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 2, 32767, -32768), this[v] = _ >>> 8, this[v + 1] = _ & 255, v + 2;
          }, d.prototype.writeInt32LE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 4, 2147483647, -2147483648), this[v] = _ & 255, this[v + 1] = _ >>> 8, this[v + 2] = _ >>> 16, this[v + 3] = _ >>> 24, v + 4;
          }, d.prototype.writeInt32BE = function(_, v, S) {
            return _ = +_, v = v >>> 0, S || ye(this, _, v, 4, 2147483647, -2147483648), _ < 0 && (_ = 4294967295 + _ + 1), this[v] = _ >>> 24, this[v + 1] = _ >>> 16, this[v + 2] = _ >>> 8, this[v + 3] = _ & 255, v + 4;
          };
          function V(_, v, S, P, J, ve) {
            if (S + P > _.length)
              throw new RangeError("Index out of range");
            if (S < 0)
              throw new RangeError("Index out of range");
          }
          function q(_, v, S, P, J) {
            return v = +v, S = S >>> 0, J || V(_, v, S, 4), s.write(_, v, S, P, 23, 4), S + 4;
          }
          d.prototype.writeFloatLE = function(_, v, S) {
            return q(this, _, v, !0, S);
          }, d.prototype.writeFloatBE = function(_, v, S) {
            return q(this, _, v, !1, S);
          };
          function ee(_, v, S, P, J) {
            return v = +v, S = S >>> 0, J || V(_, v, S, 8), s.write(_, v, S, P, 52, 8), S + 8;
          }
          d.prototype.writeDoubleLE = function(_, v, S) {
            return ee(this, _, v, !0, S);
          }, d.prototype.writeDoubleBE = function(_, v, S) {
            return ee(this, _, v, !1, S);
          }, d.prototype.copy = function(_, v, S, P) {
            if (!d.isBuffer(_))
              throw new TypeError("argument should be a Buffer");
            if (S || (S = 0), !P && P !== 0 && (P = this.length), v >= _.length && (v = _.length), v || (v = 0), P > 0 && P < S && (P = S), P === S || _.length === 0 || this.length === 0)
              return 0;
            if (v < 0)
              throw new RangeError("targetStart out of bounds");
            if (S < 0 || S >= this.length)
              throw new RangeError("Index out of range");
            if (P < 0)
              throw new RangeError("sourceEnd out of bounds");
            P > this.length && (P = this.length), _.length - v < P - S && (P = _.length - v + S);
            var J = P - S;
            if (this === _ && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(v, S, P);
            else if (this === _ && S < v && v < P)
              for (var ve = J - 1; ve >= 0; --ve)
                _[ve + v] = this[ve + S];
            else
              Uint8Array.prototype.set.call(
                _,
                this.subarray(S, P),
                v
              );
            return J;
          }, d.prototype.fill = function(_, v, S, P) {
            if (typeof _ == "string") {
              if (typeof v == "string" ? (P = v, v = 0, S = this.length) : typeof S == "string" && (P = S, S = this.length), P !== void 0 && typeof P != "string")
                throw new TypeError("encoding must be a string");
              if (typeof P == "string" && !d.isEncoding(P))
                throw new TypeError("Unknown encoding: " + P);
              if (_.length === 1) {
                var J = _.charCodeAt(0);
                (P === "utf8" && J < 128 || P === "latin1") && (_ = J);
              }
            } else
              typeof _ == "number" && (_ = _ & 255);
            if (v < 0 || this.length < v || this.length < S)
              throw new RangeError("Out of range index");
            if (S <= v)
              return this;
            v = v >>> 0, S = S === void 0 ? this.length : S >>> 0, _ || (_ = 0);
            var ve;
            if (typeof _ == "number")
              for (ve = v; ve < S; ++ve)
                this[ve] = _;
            else {
              var Re = d.isBuffer(_) ? _ : d.from(_, P), je = Re.length;
              if (je === 0)
                throw new TypeError('The value "' + _ + '" is invalid for argument "value"');
              for (ve = 0; ve < S - v; ++ve)
                this[ve + v] = Re[ve % je];
            }
            return this;
          };
          var ue = /[^+/0-9A-Za-z-_]/g;
          function ge(_) {
            if (_ = _.split("=")[0], _ = _.trim().replace(ue, ""), _.length < 2)
              return "";
            for (; _.length % 4 !== 0; )
              _ = _ + "=";
            return _;
          }
          function he(_) {
            return _ < 16 ? "0" + _.toString(16) : _.toString(16);
          }
          function W(_, v) {
            v = v || 1 / 0;
            for (var S, P = _.length, J = null, ve = [], Re = 0; Re < P; ++Re) {
              if (S = _.charCodeAt(Re), S > 55295 && S < 57344) {
                if (!J) {
                  if (S > 56319) {
                    (v -= 3) > -1 && ve.push(239, 191, 189);
                    continue;
                  } else if (Re + 1 === P) {
                    (v -= 3) > -1 && ve.push(239, 191, 189);
                    continue;
                  }
                  J = S;
                  continue;
                }
                if (S < 56320) {
                  (v -= 3) > -1 && ve.push(239, 191, 189), J = S;
                  continue;
                }
                S = (J - 55296 << 10 | S - 56320) + 65536;
              } else
                J && (v -= 3) > -1 && ve.push(239, 191, 189);
              if (J = null, S < 128) {
                if ((v -= 1) < 0)
                  break;
                ve.push(S);
              } else if (S < 2048) {
                if ((v -= 2) < 0)
                  break;
                ve.push(
                  S >> 6 | 192,
                  S & 63 | 128
                );
              } else if (S < 65536) {
                if ((v -= 3) < 0)
                  break;
                ve.push(
                  S >> 12 | 224,
                  S >> 6 & 63 | 128,
                  S & 63 | 128
                );
              } else if (S < 1114112) {
                if ((v -= 4) < 0)
                  break;
                ve.push(
                  S >> 18 | 240,
                  S >> 12 & 63 | 128,
                  S >> 6 & 63 | 128,
                  S & 63 | 128
                );
              } else
                throw new Error("Invalid code point");
            }
            return ve;
          }
          function Y(_) {
            for (var v = [], S = 0; S < _.length; ++S)
              v.push(_.charCodeAt(S) & 255);
            return v;
          }
          function se(_, v) {
            for (var S, P, J, ve = [], Re = 0; Re < _.length && !((v -= 2) < 0); ++Re)
              S = _.charCodeAt(Re), P = S >> 8, J = S % 256, ve.push(J), ve.push(P);
            return ve;
          }
          function Te(_) {
            return a.toByteArray(ge(_));
          }
          function Oe(_, v, S, P) {
            for (var J = 0; J < P && !(J + S >= v.length || J >= _.length); ++J)
              v[J + S] = _[J];
            return J;
          }
          function B(_, v) {
            return _ instanceof v || _ != null && _.constructor != null && _.constructor.name != null && _.constructor.name === v.name;
          }
          function U(_) {
            return _ !== _;
          }
        }).call(this);
      }).call(this, r("buffer").Buffer);
    }, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(r, o, n) {
      var i = r("get-intrinsic"), a = r("./"), s = a(i("String.prototype.indexOf"));
      o.exports = function(c, p) {
        var l = i(c, !!p);
        return typeof l == "function" && s(c, ".prototype.") > -1 ? a(l) : l;
      };
    }, { "./": 34, "get-intrinsic": 39 }], 34: [function(r, o, n) {
      var i = r("function-bind"), a = r("get-intrinsic"), s = a("%Function.prototype.apply%"), c = a("%Function.prototype.call%"), p = a("%Reflect.apply%", !0) || i.call(c, s), l = a("%Object.getOwnPropertyDescriptor%", !0), d = a("%Object.defineProperty%", !0), u = a("%Math.max%");
      if (d)
        try {
          d({}, "a", { value: 1 });
        } catch {
          d = null;
        }
      o.exports = function(y) {
        var f = p(i, c, arguments);
        if (l && d) {
          var b = l(f, "length");
          b.configurable && d(
            f,
            "length",
            { value: 1 + u(0, y.length - (arguments.length - 1)) }
          );
        }
        return f;
      };
      var h = function() {
        return p(i, s, arguments);
      };
      d ? d(o.exports, "apply", { value: h }) : o.exports.apply = h;
    }, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(r, o, n) {
      var i = typeof Reflect == "object" ? Reflect : null, a = i && typeof i.apply == "function" ? i.apply : function(N, O, D) {
        return Function.prototype.apply.call(N, O, D);
      }, s;
      i && typeof i.ownKeys == "function" ? s = i.ownKeys : Object.getOwnPropertySymbols ? s = function(N) {
        return Object.getOwnPropertyNames(N).concat(Object.getOwnPropertySymbols(N));
      } : s = function(N) {
        return Object.getOwnPropertyNames(N);
      };
      function c(N) {
        console && console.warn && console.warn(N);
      }
      var p = Number.isNaN || function(N) {
        return N !== N;
      };
      function l() {
        l.init.call(this);
      }
      o.exports = l, o.exports.once = R, l.EventEmitter = l, l.prototype._events = void 0, l.prototype._eventsCount = 0, l.prototype._maxListeners = void 0;
      var d = 10;
      function u(N) {
        if (typeof N != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof N);
      }
      Object.defineProperty(l, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
          return d;
        },
        set: function(N) {
          if (typeof N != "number" || N < 0 || p(N))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + N + ".");
          d = N;
        }
      }), l.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, l.prototype.setMaxListeners = function(N) {
        if (typeof N != "number" || N < 0 || p(N))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + N + ".");
        return this._maxListeners = N, this;
      };
      function h(N) {
        return N._maxListeners === void 0 ? l.defaultMaxListeners : N._maxListeners;
      }
      l.prototype.getMaxListeners = function() {
        return h(this);
      }, l.prototype.emit = function(N) {
        for (var O = [], D = 1; D < arguments.length; D++)
          O.push(arguments[D]);
        var H = N === "error", G = this._events;
        if (G !== void 0)
          H = H && G.error === void 0;
        else if (!H)
          return !1;
        if (H) {
          var X;
          if (O.length > 0 && (X = O[0]), X instanceof Error)
            throw X;
          var Q = new Error("Unhandled error." + (X ? " (" + X.message + ")" : ""));
          throw Q.context = X, Q;
        }
        var M = G[N];
        if (M === void 0)
          return !1;
        if (typeof M == "function")
          a(M, this, O);
        else
          for (var k = M.length, $ = E(M, k), D = 0; D < k; ++D)
            a($[D], this, O);
        return !0;
      };
      function y(N, O, D, H) {
        var G, X, Q;
        if (u(D), X = N._events, X === void 0 ? (X = N._events = /* @__PURE__ */ Object.create(null), N._eventsCount = 0) : (X.newListener !== void 0 && (N.emit(
          "newListener",
          O,
          D.listener ? D.listener : D
        ), X = N._events), Q = X[O]), Q === void 0)
          Q = X[O] = D, ++N._eventsCount;
        else if (typeof Q == "function" ? Q = X[O] = H ? [D, Q] : [Q, D] : H ? Q.unshift(D) : Q.push(D), G = h(N), G > 0 && Q.length > G && !Q.warned) {
          Q.warned = !0;
          var M = new Error("Possible EventEmitter memory leak detected. " + Q.length + " " + String(O) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          M.name = "MaxListenersExceededWarning", M.emitter = N, M.type = O, M.count = Q.length, c(M);
        }
        return N;
      }
      l.prototype.addListener = function(N, O) {
        return y(this, N, O, !1);
      }, l.prototype.on = l.prototype.addListener, l.prototype.prependListener = function(N, O) {
        return y(this, N, O, !0);
      };
      function f() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function b(N, O, D) {
        var H = { fired: !1, wrapFn: void 0, target: N, type: O, listener: D }, G = f.bind(H);
        return G.listener = D, H.wrapFn = G, G;
      }
      l.prototype.once = function(N, O) {
        return u(O), this.on(N, b(this, N, O)), this;
      }, l.prototype.prependOnceListener = function(N, O) {
        return u(O), this.prependListener(N, b(this, N, O)), this;
      }, l.prototype.removeListener = function(N, O) {
        var D, H, G, X, Q;
        if (u(O), H = this._events, H === void 0)
          return this;
        if (D = H[N], D === void 0)
          return this;
        if (D === O || D.listener === O)
          --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete H[N], H.removeListener && this.emit("removeListener", N, D.listener || O));
        else if (typeof D != "function") {
          for (G = -1, X = D.length - 1; X >= 0; X--)
            if (D[X] === O || D[X].listener === O) {
              Q = D[X].listener, G = X;
              break;
            }
          if (G < 0)
            return this;
          G === 0 ? D.shift() : T(D, G), D.length === 1 && (H[N] = D[0]), H.removeListener !== void 0 && this.emit("removeListener", N, Q || O);
        }
        return this;
      }, l.prototype.off = l.prototype.removeListener, l.prototype.removeAllListeners = function(N) {
        var O, D, H;
        if (D = this._events, D === void 0)
          return this;
        if (D.removeListener === void 0)
          return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : D[N] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete D[N]), this;
        if (arguments.length === 0) {
          var G = Object.keys(D), X;
          for (H = 0; H < G.length; ++H)
            X = G[H], X !== "removeListener" && this.removeAllListeners(X);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (O = D[N], typeof O == "function")
          this.removeListener(N, O);
        else if (O !== void 0)
          for (H = O.length - 1; H >= 0; H--)
            this.removeListener(N, O[H]);
        return this;
      };
      function w(N, O, D) {
        var H = N._events;
        if (H === void 0)
          return [];
        var G = H[O];
        return G === void 0 ? [] : typeof G == "function" ? D ? [G.listener || G] : [G] : D ? C(G) : E(G, G.length);
      }
      l.prototype.listeners = function(N) {
        return w(this, N, !0);
      }, l.prototype.rawListeners = function(N) {
        return w(this, N, !1);
      }, l.listenerCount = function(N, O) {
        return typeof N.listenerCount == "function" ? N.listenerCount(O) : x.call(N, O);
      }, l.prototype.listenerCount = x;
      function x(N) {
        var O = this._events;
        if (O !== void 0) {
          var D = O[N];
          if (typeof D == "function")
            return 1;
          if (D !== void 0)
            return D.length;
        }
        return 0;
      }
      l.prototype.eventNames = function() {
        return this._eventsCount > 0 ? s(this._events) : [];
      };
      function E(N, O) {
        for (var D = new Array(O), H = 0; H < O; ++H)
          D[H] = N[H];
        return D;
      }
      function T(N, O) {
        for (; O + 1 < N.length; O++)
          N[O] = N[O + 1];
        N.pop();
      }
      function C(N) {
        for (var O = new Array(N.length), D = 0; D < O.length; ++D)
          O[D] = N[D].listener || N[D];
        return O;
      }
      function R(N, O) {
        return new Promise(function(D, H) {
          function G(Q) {
            N.removeListener(O, X), H(Q);
          }
          function X() {
            typeof N.removeListener == "function" && N.removeListener("error", G), D([].slice.call(arguments));
          }
          j(N, O, X, { once: !0 }), O !== "error" && A(N, G, { once: !0 });
        });
      }
      function A(N, O, D) {
        typeof N.on == "function" && j(N, "error", O, D);
      }
      function j(N, O, D, H) {
        if (typeof N.on == "function")
          H.once ? N.once(O, D) : N.on(O, D);
        else if (typeof N.addEventListener == "function")
          N.addEventListener(O, function G(X) {
            H.once && N.removeEventListener(O, G), D(X);
          });
        else
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof N);
      }
    }, {}], 36: [function(r, o, n) {
      var i = r("is-callable"), a = Object.prototype.toString, s = Object.prototype.hasOwnProperty, c = function(u, h, y) {
        for (var f = 0, b = u.length; f < b; f++)
          s.call(u, f) && (y == null ? h(u[f], f, u) : h.call(y, u[f], f, u));
      }, p = function(u, h, y) {
        for (var f = 0, b = u.length; f < b; f++)
          y == null ? h(u.charAt(f), f, u) : h.call(y, u.charAt(f), f, u);
      }, l = function(u, h, y) {
        for (var f in u)
          s.call(u, f) && (y == null ? h(u[f], f, u) : h.call(y, u[f], f, u));
      }, d = function(u, h, y) {
        if (!i(h))
          throw new TypeError("iterator must be a function");
        var f;
        arguments.length >= 3 && (f = y), a.call(u) === "[object Array]" ? c(u, h, f) : typeof u == "string" ? p(u, h, f) : l(u, h, f);
      };
      o.exports = d;
    }, { "is-callable": 48 }], 37: [function(r, o, n) {
      var i = "Function.prototype.bind called on incompatible ", a = Array.prototype.slice, s = Object.prototype.toString, c = "[object Function]";
      o.exports = function(p) {
        var l = this;
        if (typeof l != "function" || s.call(l) !== c)
          throw new TypeError(i + l);
        for (var d = a.call(arguments, 1), u, h = function() {
          if (this instanceof u) {
            var x = l.apply(
              this,
              d.concat(a.call(arguments))
            );
            return Object(x) === x ? x : this;
          } else
            return l.apply(
              p,
              d.concat(a.call(arguments))
            );
        }, y = Math.max(0, l.length - d.length), f = [], b = 0; b < y; b++)
          f.push("$" + b);
        if (u = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(h), l.prototype) {
          var w = function() {
          };
          w.prototype = l.prototype, u.prototype = new w(), w.prototype = null;
        }
        return u;
      };
    }, {}], 38: [function(r, o, n) {
      var i = r("./implementation");
      o.exports = Function.prototype.bind || i;
    }, { "./implementation": 37 }], 39: [function(r, o, n) {
      var i, a = SyntaxError, s = Function, c = TypeError, p = function(M) {
        try {
          return s('"use strict"; return (' + M + ").constructor;")();
        } catch {
        }
      }, l = Object.getOwnPropertyDescriptor;
      if (l)
        try {
          l({}, "");
        } catch {
          l = null;
        }
      var d = function() {
        throw new c();
      }, u = l ? function() {
        try {
          return arguments.callee, d;
        } catch {
          try {
            return l(arguments, "callee").get;
          } catch {
            return d;
          }
        }
      }() : d, h = r("has-symbols")(), y = Object.getPrototypeOf || function(M) {
        return M.__proto__;
      }, f = {}, b = typeof Uint8Array > "u" ? i : y(Uint8Array), w = {
        "%AggregateError%": typeof AggregateError > "u" ? i : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? i : ArrayBuffer,
        "%ArrayIteratorPrototype%": h ? y([][Symbol.iterator]()) : i,
        "%AsyncFromSyncIteratorPrototype%": i,
        "%AsyncFunction%": f,
        "%AsyncGenerator%": f,
        "%AsyncGeneratorFunction%": f,
        "%AsyncIteratorPrototype%": f,
        "%Atomics%": typeof Atomics > "u" ? i : Atomics,
        "%BigInt%": typeof BigInt > "u" ? i : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? i : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? i : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? i : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array > "u" ? i : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? i : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? i : FinalizationRegistry,
        "%Function%": s,
        "%GeneratorFunction%": f,
        "%Int8Array%": typeof Int8Array > "u" ? i : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? i : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? i : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": h ? y(y([][Symbol.iterator]())) : i,
        "%JSON%": typeof JSON == "object" ? JSON : i,
        "%Map%": typeof Map > "u" ? i : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !h ? i : y((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? i : Promise,
        "%Proxy%": typeof Proxy > "u" ? i : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect > "u" ? i : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? i : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !h ? i : y((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? i : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": h ? y(""[Symbol.iterator]()) : i,
        "%Symbol%": h ? Symbol : i,
        "%SyntaxError%": a,
        "%ThrowTypeError%": u,
        "%TypedArray%": b,
        "%TypeError%": c,
        "%Uint8Array%": typeof Uint8Array > "u" ? i : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? i : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? i : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? i : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap > "u" ? i : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? i : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? i : WeakSet
      };
      try {
        null.error;
      } catch (M) {
        var x = y(y(M));
        w["%Error.prototype%"] = x;
      }
      var E = function M(k) {
        var $;
        if (k === "%AsyncFunction%")
          $ = p("async function () {}");
        else if (k === "%GeneratorFunction%")
          $ = p("function* () {}");
        else if (k === "%AsyncGeneratorFunction%")
          $ = p("async function* () {}");
        else if (k === "%AsyncGenerator%") {
          var ne = M("%AsyncGeneratorFunction%");
          ne && ($ = ne.prototype);
        } else if (k === "%AsyncIteratorPrototype%") {
          var te = M("%AsyncGenerator%");
          te && ($ = y(te.prototype));
        }
        return w[k] = $, $;
      }, T = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      }, C = r("function-bind"), R = r("has"), A = C.call(Function.call, Array.prototype.concat), j = C.call(Function.apply, Array.prototype.splice), N = C.call(Function.call, String.prototype.replace), O = C.call(Function.call, String.prototype.slice), D = C.call(Function.call, RegExp.prototype.exec), H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, G = /\\(\\)?/g, X = function(M) {
        var k = O(M, 0, 1), $ = O(M, -1);
        if (k === "%" && $ !== "%")
          throw new a("invalid intrinsic syntax, expected closing `%`");
        if ($ === "%" && k !== "%")
          throw new a("invalid intrinsic syntax, expected opening `%`");
        var ne = [];
        return N(M, H, function(te, de, ae, z) {
          ne[ne.length] = ae ? N(z, G, "$1") : de || te;
        }), ne;
      }, Q = function(M, k) {
        var $ = M, ne;
        if (R(T, $) && (ne = T[$], $ = "%" + ne[0] + "%"), R(w, $)) {
          var te = w[$];
          if (te === f && (te = E($)), typeof te > "u" && !k)
            throw new c("intrinsic " + M + " exists, but is not available. Please file an issue!");
          return {
            alias: ne,
            name: $,
            value: te
          };
        }
        throw new a("intrinsic " + M + " does not exist!");
      };
      o.exports = function(M, k) {
        if (typeof M != "string" || M.length === 0)
          throw new c("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof k != "boolean")
          throw new c('"allowMissing" argument must be a boolean');
        if (D(/^%?[^%]*%?$/, M) === null)
          throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var $ = X(M), ne = $.length > 0 ? $[0] : "", te = Q("%" + ne + "%", k), de = te.name, ae = te.value, z = !1, Z = te.alias;
        Z && (ne = Z[0], j($, A([0, 1], Z)));
        for (var oe = 1, ye = !0; oe < $.length; oe += 1) {
          var V = $[oe], q = O(V, 0, 1), ee = O(V, -1);
          if ((q === '"' || q === "'" || q === "`" || ee === '"' || ee === "'" || ee === "`") && q !== ee)
            throw new a("property names with quotes must have matching quotes");
          if ((V === "constructor" || !ye) && (z = !0), ne += "." + V, de = "%" + ne + "%", R(w, de))
            ae = w[de];
          else if (ae != null) {
            if (!(V in ae)) {
              if (!k)
                throw new c("base intrinsic for " + M + " exists, but the property is not available.");
              return;
            }
            if (l && oe + 1 >= $.length) {
              var ue = l(ae, V);
              ye = !!ue, ye && "get" in ue && !("originalValue" in ue.get) ? ae = ue.get : ae = ae[V];
            } else
              ye = R(ae, V), ae = ae[V];
            ye && !z && (w[de] = ae);
          }
        }
        return ae;
      };
    }, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(r, o, n) {
      var i = r("get-intrinsic"), a = i("%Object.getOwnPropertyDescriptor%", !0);
      if (a)
        try {
          a([], "length");
        } catch {
          a = null;
        }
      o.exports = a;
    }, { "get-intrinsic": 39 }], 41: [function(r, o, n) {
      var i = typeof Symbol < "u" && Symbol, a = r("./shams");
      o.exports = function() {
        return typeof i != "function" || typeof Symbol != "function" || typeof i("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : a();
      };
    }, { "./shams": 42 }], 42: [function(r, o, n) {
      o.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
          return !1;
        if (typeof Symbol.iterator == "symbol")
          return !0;
        var i = {}, a = Symbol("test"), s = Object(a);
        if (typeof a == "string" || Object.prototype.toString.call(a) !== "[object Symbol]" || Object.prototype.toString.call(s) !== "[object Symbol]")
          return !1;
        var c = 42;
        i[a] = c;
        for (a in i)
          return !1;
        if (typeof Object.keys == "function" && Object.keys(i).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(i).length !== 0)
          return !1;
        var p = Object.getOwnPropertySymbols(i);
        if (p.length !== 1 || p[0] !== a || !Object.prototype.propertyIsEnumerable.call(i, a))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var l = Object.getOwnPropertyDescriptor(i, a);
          if (l.value !== c || l.enumerable !== !0)
            return !1;
        }
        return !0;
      };
    }, {}], 43: [function(r, o, n) {
      var i = r("has-symbols/shams");
      o.exports = function() {
        return i() && !!Symbol.toStringTag;
      };
    }, { "has-symbols/shams": 42 }], 44: [function(r, o, n) {
      var i = r("function-bind");
      o.exports = i.call(Function.call, Object.prototype.hasOwnProperty);
    }, { "function-bind": 38 }], 45: [function(r, o, n) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      n.read = function(i, a, s, c, p) {
        var l, d, u = p * 8 - c - 1, h = (1 << u) - 1, y = h >> 1, f = -7, b = s ? p - 1 : 0, w = s ? -1 : 1, x = i[a + b];
        for (b += w, l = x & (1 << -f) - 1, x >>= -f, f += u; f > 0; l = l * 256 + i[a + b], b += w, f -= 8)
          ;
        for (d = l & (1 << -f) - 1, l >>= -f, f += c; f > 0; d = d * 256 + i[a + b], b += w, f -= 8)
          ;
        if (l === 0)
          l = 1 - y;
        else {
          if (l === h)
            return d ? NaN : (x ? -1 : 1) * (1 / 0);
          d = d + Math.pow(2, c), l = l - y;
        }
        return (x ? -1 : 1) * d * Math.pow(2, l - c);
      }, n.write = function(i, a, s, c, p, l) {
        var d, u, h, y = l * 8 - p - 1, f = (1 << y) - 1, b = f >> 1, w = p === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = c ? 0 : l - 1, E = c ? 1 : -1, T = a < 0 || a === 0 && 1 / a < 0 ? 1 : 0;
        for (a = Math.abs(a), isNaN(a) || a === 1 / 0 ? (u = isNaN(a) ? 1 : 0, d = f) : (d = Math.floor(Math.log(a) / Math.LN2), a * (h = Math.pow(2, -d)) < 1 && (d--, h *= 2), d + b >= 1 ? a += w / h : a += w * Math.pow(2, 1 - b), a * h >= 2 && (d++, h /= 2), d + b >= f ? (u = 0, d = f) : d + b >= 1 ? (u = (a * h - 1) * Math.pow(2, p), d = d + b) : (u = a * Math.pow(2, b - 1) * Math.pow(2, p), d = 0)); p >= 8; i[s + x] = u & 255, x += E, u /= 256, p -= 8)
          ;
        for (d = d << p | u, y += p; y > 0; i[s + x] = d & 255, x += E, d /= 256, y -= 8)
          ;
        i[s + x - E] |= T * 128;
      };
    }, {}], 46: [function(r, o, n) {
      typeof Object.create == "function" ? o.exports = function(i, a) {
        a && (i.super_ = a, i.prototype = Object.create(a.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }));
      } : o.exports = function(i, a) {
        if (a) {
          i.super_ = a;
          var s = function() {
          };
          s.prototype = a.prototype, i.prototype = new s(), i.prototype.constructor = i;
        }
      };
    }, {}], 47: [function(r, o, n) {
      var i = r("has-tostringtag/shams")(), a = r("call-bind/callBound"), s = a("Object.prototype.toString"), c = function(d) {
        return i && d && typeof d == "object" && Symbol.toStringTag in d ? !1 : s(d) === "[object Arguments]";
      }, p = function(d) {
        return c(d) ? !0 : d !== null && typeof d == "object" && typeof d.length == "number" && d.length >= 0 && s(d) !== "[object Array]" && s(d.callee) === "[object Function]";
      }, l = function() {
        return c(arguments);
      }();
      c.isLegacyArguments = p, o.exports = l ? c : p;
    }, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(r, o, n) {
      var i = Function.prototype.toString, a = typeof Reflect == "object" && Reflect !== null && Reflect.apply, s, c;
      if (typeof a == "function" && typeof Object.defineProperty == "function")
        try {
          s = Object.defineProperty({}, "length", {
            get: function() {
              throw c;
            }
          }), c = {}, a(function() {
            throw 42;
          }, null, s);
        } catch (A) {
          A !== c && (a = null);
        }
      else
        a = null;
      var p = /^\s*class\b/, l = function(A) {
        try {
          var j = i.call(A);
          return p.test(j);
        } catch {
          return !1;
        }
      }, d = function(A) {
        try {
          return l(A) ? !1 : (i.call(A), !0);
        } catch {
          return !1;
        }
      }, u = Object.prototype.toString, h = "[object Object]", y = "[object Function]", f = "[object GeneratorFunction]", b = "[object HTMLAllCollection]", w = "[object HTML document.all class]", x = "[object HTMLCollection]", E = typeof Symbol == "function" && !!Symbol.toStringTag, T = !(0 in [,]), C = function() {
        return !1;
      };
      if (typeof document == "object") {
        var R = document.all;
        u.call(R) === u.call(document.all) && (C = function(A) {
          if ((T || !A) && (typeof A > "u" || typeof A == "object"))
            try {
              var j = u.call(A);
              return (j === b || j === w || j === x || j === h) && A("") == null;
            } catch {
            }
          return !1;
        });
      }
      o.exports = a ? function(A) {
        if (C(A))
          return !0;
        if (!A || typeof A != "function" && typeof A != "object")
          return !1;
        try {
          a(A, null, s);
        } catch (j) {
          if (j !== c)
            return !1;
        }
        return !l(A) && d(A);
      } : function(A) {
        if (C(A))
          return !0;
        if (!A || typeof A != "function" && typeof A != "object")
          return !1;
        if (E)
          return d(A);
        if (l(A))
          return !1;
        var j = u.call(A);
        return j !== y && j !== f && !/^\[object HTML/.test(j) ? !1 : d(A);
      };
    }, {}], 49: [function(r, o, n) {
      var i = Object.prototype.toString, a = Function.prototype.toString, s = /^\s*(?:function)?\*/, c = r("has-tostringtag/shams")(), p = Object.getPrototypeOf, l = function() {
        if (!c)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }, d;
      o.exports = function(u) {
        if (typeof u != "function")
          return !1;
        if (s.test(a.call(u)))
          return !0;
        if (!c) {
          var h = i.call(u);
          return h === "[object GeneratorFunction]";
        }
        if (!p)
          return !1;
        if (typeof d > "u") {
          var y = l();
          d = y ? p(y) : !1;
        }
        return p(u) === d;
      };
    }, { "has-tostringtag/shams": 43 }], 50: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = r("for-each"), s = r("available-typed-arrays"), c = r("call-bind/callBound"), p = c("Object.prototype.toString"), l = r("has-tostringtag/shams")(), d = r("gopd"), u = typeof globalThis > "u" ? i : globalThis, h = s(), y = c("Array.prototype.indexOf", !0) || function(E, T) {
            for (var C = 0; C < E.length; C += 1)
              if (E[C] === T)
                return C;
            return -1;
          }, f = c("String.prototype.slice"), b = {}, w = Object.getPrototypeOf;
          l && d && w && a(h, function(E) {
            var T = new u[E]();
            if (Symbol.toStringTag in T) {
              var C = w(T), R = d(C, Symbol.toStringTag);
              if (!R) {
                var A = w(C);
                R = d(A, Symbol.toStringTag);
              }
              b[E] = R.get;
            }
          });
          var x = function(E) {
            var T = !1;
            return a(b, function(C, R) {
              if (!T)
                try {
                  T = C.call(E) === R;
                } catch {
                }
            }), T;
          };
          o.exports = function(E) {
            if (!E || typeof E != "object")
              return !1;
            if (!l || !(Symbol.toStringTag in E)) {
              var T = f(p(E), 8, -1);
              return y(h, T) > -1;
            }
            return d ? x(E) : !1;
          };
        }).call(this);
      }).call(this, typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(r, o, n) {
      var i = Object.getOwnPropertySymbols, a = Object.prototype.hasOwnProperty, s = Object.prototype.propertyIsEnumerable;
      function c(l) {
        if (l == null)
          throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(l);
      }
      function p() {
        try {
          if (!Object.assign)
            return !1;
          var l = new String("abc");
          if (l[5] = "de", Object.getOwnPropertyNames(l)[0] === "5")
            return !1;
          for (var d = {}, u = 0; u < 10; u++)
            d["_" + String.fromCharCode(u)] = u;
          var h = Object.getOwnPropertyNames(d).map(function(f) {
            return d[f];
          });
          if (h.join("") !== "0123456789")
            return !1;
          var y = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(f) {
            y[f] = f;
          }), Object.keys(Object.assign({}, y)).join("") === "abcdefghijklmnopqrst";
        } catch {
          return !1;
        }
      }
      o.exports = p() ? Object.assign : function(l, d) {
        for (var u, h = c(l), y, f = 1; f < arguments.length; f++) {
          u = Object(arguments[f]);
          for (var b in u)
            a.call(u, b) && (h[b] = u[b]);
          if (i) {
            y = i(u);
            for (var w = 0; w < y.length; w++)
              s.call(u, y[w]) && (h[y[w]] = u[y[w]]);
          }
        }
        return h;
      };
    }, {}], 52: [function(r, o, n) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      function a(p, l) {
        return Object.prototype.hasOwnProperty.call(p, l);
      }
      n.assign = function(p) {
        for (var l = Array.prototype.slice.call(arguments, 1); l.length; ) {
          var d = l.shift();
          if (d) {
            if (typeof d != "object")
              throw new TypeError(d + "must be non-object");
            for (var u in d)
              a(d, u) && (p[u] = d[u]);
          }
        }
        return p;
      }, n.shrinkBuf = function(p, l) {
        return p.length === l ? p : p.subarray ? p.subarray(0, l) : (p.length = l, p);
      };
      var s = {
        arraySet: function(p, l, d, u, h) {
          if (l.subarray && p.subarray) {
            p.set(l.subarray(d, d + u), h);
            return;
          }
          for (var y = 0; y < u; y++)
            p[h + y] = l[d + y];
        },
        // Join array of chunks to single array.
        flattenChunks: function(p) {
          var l, d, u, h, y, f;
          for (u = 0, l = 0, d = p.length; l < d; l++)
            u += p[l].length;
          for (f = new Uint8Array(u), h = 0, l = 0, d = p.length; l < d; l++)
            y = p[l], f.set(y, h), h += y.length;
          return f;
        }
      }, c = {
        arraySet: function(p, l, d, u, h) {
          for (var y = 0; y < u; y++)
            p[h + y] = l[d + y];
        },
        // Join array of chunks to single array.
        flattenChunks: function(p) {
          return [].concat.apply([], p);
        }
      };
      n.setTyped = function(p) {
        p ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, s)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, c));
      }, n.setTyped(i);
    }, {}], 53: [function(r, o, n) {
      function i(a, s, c, p) {
        for (var l = a & 65535 | 0, d = a >>> 16 & 65535 | 0, u = 0; c !== 0; ) {
          u = c > 2e3 ? 2e3 : c, c -= u;
          do
            l = l + s[p++] | 0, d = d + l | 0;
          while (--u);
          l %= 65521, d %= 65521;
        }
        return l | d << 16 | 0;
      }
      o.exports = i;
    }, {}], 54: [function(r, o, n) {
      o.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 55: [function(r, o, n) {
      function i() {
        for (var c, p = [], l = 0; l < 256; l++) {
          c = l;
          for (var d = 0; d < 8; d++)
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          p[l] = c;
        }
        return p;
      }
      var a = i();
      function s(c, p, l, d) {
        var u = a, h = d + l;
        c ^= -1;
        for (var y = d; y < h; y++)
          c = c >>> 8 ^ u[(c ^ p[y]) & 255];
        return c ^ -1;
      }
      o.exports = s;
    }, {}], 56: [function(r, o, n) {
      var i = r("../utils/common"), a = r("./trees"), s = r("./adler32"), c = r("./crc32"), p = r("./messages"), l = 0, d = 1, u = 3, h = 4, y = 5, f = 0, b = 1, w = -2, x = -3, E = -5, T = -1, C = 1, R = 2, A = 3, j = 4, N = 0, O = 2, D = 8, H = 9, G = 15, X = 8, Q = 29, M = 256, k = M + 1 + Q, $ = 30, ne = 19, te = 2 * k + 1, de = 15, ae = 3, z = 258, Z = z + ae + 1, oe = 32, ye = 42, V = 69, q = 73, ee = 91, ue = 103, ge = 113, he = 666, W = 1, Y = 2, se = 3, Te = 4, Oe = 3;
      function B(g, fe) {
        return g.msg = p[fe], fe;
      }
      function U(g) {
        return (g << 1) - (g > 4 ? 9 : 0);
      }
      function _(g) {
        for (var fe = g.length; --fe >= 0; )
          g[fe] = 0;
      }
      function v(g) {
        var fe = g.state, le = fe.pending;
        le > g.avail_out && (le = g.avail_out), le !== 0 && (i.arraySet(g.output, fe.pending_buf, fe.pending_out, le, g.next_out), g.next_out += le, fe.pending_out += le, g.total_out += le, g.avail_out -= le, fe.pending -= le, fe.pending === 0 && (fe.pending_out = 0));
      }
      function S(g, fe) {
        a._tr_flush_block(g, g.block_start >= 0 ? g.block_start : -1, g.strstart - g.block_start, fe), g.block_start = g.strstart, v(g.strm);
      }
      function P(g, fe) {
        g.pending_buf[g.pending++] = fe;
      }
      function J(g, fe) {
        g.pending_buf[g.pending++] = fe >>> 8 & 255, g.pending_buf[g.pending++] = fe & 255;
      }
      function ve(g, fe, le, L) {
        var K = g.avail_in;
        return K > L && (K = L), K === 0 ? 0 : (g.avail_in -= K, i.arraySet(fe, g.input, g.next_in, K, le), g.state.wrap === 1 ? g.adler = s(g.adler, fe, K, le) : g.state.wrap === 2 && (g.adler = c(g.adler, fe, K, le)), g.next_in += K, g.total_in += K, K);
      }
      function Re(g, fe) {
        var le = g.max_chain_length, L = g.strstart, K, ce, Le = g.prev_length, Ae = g.nice_match, Ie = g.strstart > g.w_size - Z ? g.strstart - (g.w_size - Z) : 0, Ye = g.window, It = g.w_mask, nt = g.prev, pe = g.strstart + z, ie = Ye[L + Le - 1], Se = Ye[L + Le];
        g.prev_length >= g.good_match && (le >>= 2), Ae > g.lookahead && (Ae = g.lookahead);
        do
          if (K = fe, !(Ye[K + Le] !== Se || Ye[K + Le - 1] !== ie || Ye[K] !== Ye[L] || Ye[++K] !== Ye[L + 1])) {
            L += 2, K++;
            do
              ;
            while (Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && L < pe);
            if (ce = z - (pe - L), L = pe - z, ce > Le) {
              if (g.match_start = fe, Le = ce, ce >= Ae)
                break;
              ie = Ye[L + Le - 1], Se = Ye[L + Le];
            }
          }
        while ((fe = nt[fe & It]) > Ie && --le !== 0);
        return Le <= g.lookahead ? Le : g.lookahead;
      }
      function je(g) {
        var fe = g.w_size, le, L, K, ce, Le;
        do {
          if (ce = g.window_size - g.lookahead - g.strstart, g.strstart >= fe + (fe - Z)) {
            i.arraySet(g.window, g.window, fe, fe, 0), g.match_start -= fe, g.strstart -= fe, g.block_start -= fe, L = g.hash_size, le = L;
            do
              K = g.head[--le], g.head[le] = K >= fe ? K - fe : 0;
            while (--L);
            L = fe, le = L;
            do
              K = g.prev[--le], g.prev[le] = K >= fe ? K - fe : 0;
            while (--L);
            ce += fe;
          }
          if (g.strm.avail_in === 0)
            break;
          if (L = ve(g.strm, g.window, g.strstart + g.lookahead, ce), g.lookahead += L, g.lookahead + g.insert >= ae)
            for (Le = g.strstart - g.insert, g.ins_h = g.window[Le], g.ins_h = (g.ins_h << g.hash_shift ^ g.window[Le + 1]) & g.hash_mask; g.insert && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[Le + ae - 1]) & g.hash_mask, g.prev[Le & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = Le, Le++, g.insert--, !(g.lookahead + g.insert < ae)); )
              ;
        } while (g.lookahead < Z && g.strm.avail_in !== 0);
      }
      function qe(g, fe) {
        var le = 65535;
        for (le > g.pending_buf_size - 5 && (le = g.pending_buf_size - 5); ; ) {
          if (g.lookahead <= 1) {
            if (je(g), g.lookahead === 0 && fe === l)
              return W;
            if (g.lookahead === 0)
              break;
          }
          g.strstart += g.lookahead, g.lookahead = 0;
          var L = g.block_start + le;
          if ((g.strstart === 0 || g.strstart >= L) && (g.lookahead = g.strstart - L, g.strstart = L, S(g, !1), g.strm.avail_out === 0) || g.strstart - g.block_start >= g.w_size - Z && (S(g, !1), g.strm.avail_out === 0))
            return W;
        }
        return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : (g.strstart > g.block_start && (S(g, !1), g.strm.avail_out), W);
      }
      function ze(g, fe) {
        for (var le, L; ; ) {
          if (g.lookahead < Z) {
            if (je(g), g.lookahead < Z && fe === l)
              return W;
            if (g.lookahead === 0)
              break;
          }
          if (le = 0, g.lookahead >= ae && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart), le !== 0 && g.strstart - le <= g.w_size - Z && (g.match_length = Re(g, le)), g.match_length >= ae)
            if (L = a._tr_tally(g, g.strstart - g.match_start, g.match_length - ae), g.lookahead -= g.match_length, g.match_length <= g.max_lazy_match && g.lookahead >= ae) {
              g.match_length--;
              do
                g.strstart++, g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart;
              while (--g.match_length !== 0);
              g.strstart++;
            } else
              g.strstart += g.match_length, g.match_length = 0, g.ins_h = g.window[g.strstart], g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + 1]) & g.hash_mask;
          else
            L = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++;
          if (L && (S(g, !1), g.strm.avail_out === 0))
            return W;
        }
        return g.insert = g.strstart < ae - 1 ? g.strstart : ae - 1, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
      }
      function We(g, fe) {
        for (var le, L, K; ; ) {
          if (g.lookahead < Z) {
            if (je(g), g.lookahead < Z && fe === l)
              return W;
            if (g.lookahead === 0)
              break;
          }
          if (le = 0, g.lookahead >= ae && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart), g.prev_length = g.match_length, g.prev_match = g.match_start, g.match_length = ae - 1, le !== 0 && g.prev_length < g.max_lazy_match && g.strstart - le <= g.w_size - Z && (g.match_length = Re(g, le), g.match_length <= 5 && (g.strategy === C || g.match_length === ae && g.strstart - g.match_start > 4096) && (g.match_length = ae - 1)), g.prev_length >= ae && g.match_length <= g.prev_length) {
            K = g.strstart + g.lookahead - ae, L = a._tr_tally(g, g.strstart - 1 - g.prev_match, g.prev_length - ae), g.lookahead -= g.prev_length - 1, g.prev_length -= 2;
            do
              ++g.strstart <= K && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart);
            while (--g.prev_length !== 0);
            if (g.match_available = 0, g.match_length = ae - 1, g.strstart++, L && (S(g, !1), g.strm.avail_out === 0))
              return W;
          } else if (g.match_available) {
            if (L = a._tr_tally(g, 0, g.window[g.strstart - 1]), L && S(g, !1), g.strstart++, g.lookahead--, g.strm.avail_out === 0)
              return W;
          } else
            g.match_available = 1, g.strstart++, g.lookahead--;
        }
        return g.match_available && (L = a._tr_tally(g, 0, g.window[g.strstart - 1]), g.match_available = 0), g.insert = g.strstart < ae - 1 ? g.strstart : ae - 1, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
      }
      function Fe(g, fe) {
        for (var le, L, K, ce, Le = g.window; ; ) {
          if (g.lookahead <= z) {
            if (je(g), g.lookahead <= z && fe === l)
              return W;
            if (g.lookahead === 0)
              break;
          }
          if (g.match_length = 0, g.lookahead >= ae && g.strstart > 0 && (K = g.strstart - 1, L = Le[K], L === Le[++K] && L === Le[++K] && L === Le[++K])) {
            ce = g.strstart + z;
            do
              ;
            while (L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && K < ce);
            g.match_length = z - (ce - K), g.match_length > g.lookahead && (g.match_length = g.lookahead);
          }
          if (g.match_length >= ae ? (le = a._tr_tally(g, 1, g.match_length - ae), g.lookahead -= g.match_length, g.strstart += g.match_length, g.match_length = 0) : (le = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++), le && (S(g, !1), g.strm.avail_out === 0))
            return W;
        }
        return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
      }
      function rt(g, fe) {
        for (var le; ; ) {
          if (g.lookahead === 0 && (je(g), g.lookahead === 0)) {
            if (fe === l)
              return W;
            break;
          }
          if (g.match_length = 0, le = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++, le && (S(g, !1), g.strm.avail_out === 0))
            return W;
        }
        return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
      }
      function Ge(g, fe, le, L, K) {
        this.good_length = g, this.max_lazy = fe, this.nice_length = le, this.max_chain = L, this.func = K;
      }
      var Je;
      Je = [
        /*      good lazy nice chain */
        new Ge(0, 0, 0, 0, qe),
        /* 0 store only */
        new Ge(4, 4, 8, 4, ze),
        /* 1 max speed, no lazy matches */
        new Ge(4, 5, 16, 8, ze),
        /* 2 */
        new Ge(4, 6, 32, 32, ze),
        /* 3 */
        new Ge(4, 4, 16, 16, We),
        /* 4 lazy matches */
        new Ge(8, 16, 32, 32, We),
        /* 5 */
        new Ge(8, 16, 128, 128, We),
        /* 6 */
        new Ge(8, 32, 128, 256, We),
        /* 7 */
        new Ge(32, 128, 258, 1024, We),
        /* 8 */
        new Ge(32, 258, 258, 4096, We)
        /* 9 max compression */
      ];
      function Ze(g) {
        g.window_size = 2 * g.w_size, _(g.head), g.max_lazy_match = Je[g.level].max_lazy, g.good_match = Je[g.level].good_length, g.nice_match = Je[g.level].nice_length, g.max_chain_length = Je[g.level].max_chain, g.strstart = 0, g.block_start = 0, g.lookahead = 0, g.insert = 0, g.match_length = g.prev_length = ae - 1, g.match_available = 0, g.ins_h = 0;
      }
      function F() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = D, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(te * 2), this.dyn_dtree = new i.Buf16((2 * $ + 1) * 2), this.bl_tree = new i.Buf16((2 * ne + 1) * 2), _(this.dyn_ltree), _(this.dyn_dtree), _(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(de + 1), this.heap = new i.Buf16(2 * k + 1), _(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * k + 1), _(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function we(g) {
        var fe;
        return !g || !g.state ? B(g, w) : (g.total_in = g.total_out = 0, g.data_type = O, fe = g.state, fe.pending = 0, fe.pending_out = 0, fe.wrap < 0 && (fe.wrap = -fe.wrap), fe.status = fe.wrap ? ye : ge, g.adler = fe.wrap === 2 ? 0 : 1, fe.last_flush = l, a._tr_init(fe), f);
      }
      function xe(g) {
        var fe = we(g);
        return fe === f && Ze(g.state), fe;
      }
      function Ce(g, fe) {
        return !g || !g.state || g.state.wrap !== 2 ? w : (g.state.gzhead = fe, f);
      }
      function re(g, fe, le, L, K, ce) {
        if (!g)
          return w;
        var Le = 1;
        if (fe === T && (fe = 6), L < 0 ? (Le = 0, L = -L) : L > 15 && (Le = 2, L -= 16), K < 1 || K > H || le !== D || L < 8 || L > 15 || fe < 0 || fe > 9 || ce < 0 || ce > j)
          return B(g, w);
        L === 8 && (L = 9);
        var Ae = new F();
        return g.state = Ae, Ae.strm = g, Ae.wrap = Le, Ae.gzhead = null, Ae.w_bits = L, Ae.w_size = 1 << Ae.w_bits, Ae.w_mask = Ae.w_size - 1, Ae.hash_bits = K + 7, Ae.hash_size = 1 << Ae.hash_bits, Ae.hash_mask = Ae.hash_size - 1, Ae.hash_shift = ~~((Ae.hash_bits + ae - 1) / ae), Ae.window = new i.Buf8(Ae.w_size * 2), Ae.head = new i.Buf16(Ae.hash_size), Ae.prev = new i.Buf16(Ae.w_size), Ae.lit_bufsize = 1 << K + 6, Ae.pending_buf_size = Ae.lit_bufsize * 4, Ae.pending_buf = new i.Buf8(Ae.pending_buf_size), Ae.d_buf = 1 * Ae.lit_bufsize, Ae.l_buf = 3 * Ae.lit_bufsize, Ae.level = fe, Ae.strategy = ce, Ae.method = le, xe(g);
      }
      function me(g, fe) {
        return re(g, fe, D, G, X, N);
      }
      function I(g, fe) {
        var le, L, K, ce;
        if (!g || !g.state || fe > y || fe < 0)
          return g ? B(g, w) : w;
        if (L = g.state, !g.output || !g.input && g.avail_in !== 0 || L.status === he && fe !== h)
          return B(g, g.avail_out === 0 ? E : w);
        if (L.strm = g, le = L.last_flush, L.last_flush = fe, L.status === ye)
          if (L.wrap === 2)
            g.adler = 0, P(L, 31), P(L, 139), P(L, 8), L.gzhead ? (P(
              L,
              (L.gzhead.text ? 1 : 0) + (L.gzhead.hcrc ? 2 : 0) + (L.gzhead.extra ? 4 : 0) + (L.gzhead.name ? 8 : 0) + (L.gzhead.comment ? 16 : 0)
            ), P(L, L.gzhead.time & 255), P(L, L.gzhead.time >> 8 & 255), P(L, L.gzhead.time >> 16 & 255), P(L, L.gzhead.time >> 24 & 255), P(L, L.level === 9 ? 2 : L.strategy >= R || L.level < 2 ? 4 : 0), P(L, L.gzhead.os & 255), L.gzhead.extra && L.gzhead.extra.length && (P(L, L.gzhead.extra.length & 255), P(L, L.gzhead.extra.length >> 8 & 255)), L.gzhead.hcrc && (g.adler = c(g.adler, L.pending_buf, L.pending, 0)), L.gzindex = 0, L.status = V) : (P(L, 0), P(L, 0), P(L, 0), P(L, 0), P(L, 0), P(L, L.level === 9 ? 2 : L.strategy >= R || L.level < 2 ? 4 : 0), P(L, Oe), L.status = ge);
          else {
            var Le = D + (L.w_bits - 8 << 4) << 8, Ae = -1;
            L.strategy >= R || L.level < 2 ? Ae = 0 : L.level < 6 ? Ae = 1 : L.level === 6 ? Ae = 2 : Ae = 3, Le |= Ae << 6, L.strstart !== 0 && (Le |= oe), Le += 31 - Le % 31, L.status = ge, J(L, Le), L.strstart !== 0 && (J(L, g.adler >>> 16), J(L, g.adler & 65535)), g.adler = 1;
          }
        if (L.status === V)
          if (L.gzhead.extra) {
            for (K = L.pending; L.gzindex < (L.gzhead.extra.length & 65535) && !(L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)); )
              P(L, L.gzhead.extra[L.gzindex] & 255), L.gzindex++;
            L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), L.gzindex === L.gzhead.extra.length && (L.gzindex = 0, L.status = q);
          } else
            L.status = q;
        if (L.status === q)
          if (L.gzhead.name) {
            K = L.pending;
            do {
              if (L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)) {
                ce = 1;
                break;
              }
              L.gzindex < L.gzhead.name.length ? ce = L.gzhead.name.charCodeAt(L.gzindex++) & 255 : ce = 0, P(L, ce);
            } while (ce !== 0);
            L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), ce === 0 && (L.gzindex = 0, L.status = ee);
          } else
            L.status = ee;
        if (L.status === ee)
          if (L.gzhead.comment) {
            K = L.pending;
            do {
              if (L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)) {
                ce = 1;
                break;
              }
              L.gzindex < L.gzhead.comment.length ? ce = L.gzhead.comment.charCodeAt(L.gzindex++) & 255 : ce = 0, P(L, ce);
            } while (ce !== 0);
            L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), ce === 0 && (L.status = ue);
          } else
            L.status = ue;
        if (L.status === ue && (L.gzhead.hcrc ? (L.pending + 2 > L.pending_buf_size && v(g), L.pending + 2 <= L.pending_buf_size && (P(L, g.adler & 255), P(L, g.adler >> 8 & 255), g.adler = 0, L.status = ge)) : L.status = ge), L.pending !== 0) {
          if (v(g), g.avail_out === 0)
            return L.last_flush = -1, f;
        } else if (g.avail_in === 0 && U(fe) <= U(le) && fe !== h)
          return B(g, E);
        if (L.status === he && g.avail_in !== 0)
          return B(g, E);
        if (g.avail_in !== 0 || L.lookahead !== 0 || fe !== l && L.status !== he) {
          var Ie = L.strategy === R ? rt(L, fe) : L.strategy === A ? Fe(L, fe) : Je[L.level].func(L, fe);
          if ((Ie === se || Ie === Te) && (L.status = he), Ie === W || Ie === se)
            return g.avail_out === 0 && (L.last_flush = -1), f;
          if (Ie === Y && (fe === d ? a._tr_align(L) : fe !== y && (a._tr_stored_block(L, 0, 0, !1), fe === u && (_(L.head), L.lookahead === 0 && (L.strstart = 0, L.block_start = 0, L.insert = 0))), v(g), g.avail_out === 0))
            return L.last_flush = -1, f;
        }
        return fe !== h ? f : L.wrap <= 0 ? b : (L.wrap === 2 ? (P(L, g.adler & 255), P(L, g.adler >> 8 & 255), P(L, g.adler >> 16 & 255), P(L, g.adler >> 24 & 255), P(L, g.total_in & 255), P(L, g.total_in >> 8 & 255), P(L, g.total_in >> 16 & 255), P(L, g.total_in >> 24 & 255)) : (J(L, g.adler >>> 16), J(L, g.adler & 65535)), v(g), L.wrap > 0 && (L.wrap = -L.wrap), L.pending !== 0 ? f : b);
      }
      function Ee(g) {
        var fe;
        return !g || !g.state ? w : (fe = g.state.status, fe !== ye && fe !== V && fe !== q && fe !== ee && fe !== ue && fe !== ge && fe !== he ? B(g, w) : (g.state = null, fe === ge ? B(g, x) : f));
      }
      function De(g, fe) {
        var le = fe.length, L, K, ce, Le, Ae, Ie, Ye, It;
        if (!g || !g.state || (L = g.state, Le = L.wrap, Le === 2 || Le === 1 && L.status !== ye || L.lookahead))
          return w;
        for (Le === 1 && (g.adler = s(g.adler, fe, le, 0)), L.wrap = 0, le >= L.w_size && (Le === 0 && (_(L.head), L.strstart = 0, L.block_start = 0, L.insert = 0), It = new i.Buf8(L.w_size), i.arraySet(It, fe, le - L.w_size, L.w_size, 0), fe = It, le = L.w_size), Ae = g.avail_in, Ie = g.next_in, Ye = g.input, g.avail_in = le, g.next_in = 0, g.input = fe, je(L); L.lookahead >= ae; ) {
          K = L.strstart, ce = L.lookahead - (ae - 1);
          do
            L.ins_h = (L.ins_h << L.hash_shift ^ L.window[K + ae - 1]) & L.hash_mask, L.prev[K & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = K, K++;
          while (--ce);
          L.strstart = K, L.lookahead = ae - 1, je(L);
        }
        return L.strstart += L.lookahead, L.block_start = L.strstart, L.insert = L.lookahead, L.lookahead = 0, L.match_length = L.prev_length = ae - 1, L.match_available = 0, g.next_in = Ie, g.input = Ye, g.avail_in = Ae, L.wrap = Le, f;
      }
      n.deflateInit = me, n.deflateInit2 = re, n.deflateReset = xe, n.deflateResetKeep = we, n.deflateSetHeader = Ce, n.deflate = I, n.deflateEnd = Ee, n.deflateSetDictionary = De, n.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(r, o, n) {
      var i = 30, a = 12;
      o.exports = function(s, c) {
        var p, l, d, u, h, y, f, b, w, x, E, T, C, R, A, j, N, O, D, H, G, X, Q, M, k;
        p = s.state, l = s.next_in, M = s.input, d = l + (s.avail_in - 5), u = s.next_out, k = s.output, h = u - (c - s.avail_out), y = u + (s.avail_out - 257), f = p.dmax, b = p.wsize, w = p.whave, x = p.wnext, E = p.window, T = p.hold, C = p.bits, R = p.lencode, A = p.distcode, j = (1 << p.lenbits) - 1, N = (1 << p.distbits) - 1;
        e:
          do {
            C < 15 && (T += M[l++] << C, C += 8, T += M[l++] << C, C += 8), O = R[T & j];
            t:
              for (; ; ) {
                if (D = O >>> 24, T >>>= D, C -= D, D = O >>> 16 & 255, D === 0)
                  k[u++] = O & 65535;
                else if (D & 16) {
                  H = O & 65535, D &= 15, D && (C < D && (T += M[l++] << C, C += 8), H += T & (1 << D) - 1, T >>>= D, C -= D), C < 15 && (T += M[l++] << C, C += 8, T += M[l++] << C, C += 8), O = A[T & N];
                  r:
                    for (; ; ) {
                      if (D = O >>> 24, T >>>= D, C -= D, D = O >>> 16 & 255, D & 16) {
                        if (G = O & 65535, D &= 15, C < D && (T += M[l++] << C, C += 8, C < D && (T += M[l++] << C, C += 8)), G += T & (1 << D) - 1, G > f) {
                          s.msg = "invalid distance too far back", p.mode = i;
                          break e;
                        }
                        if (T >>>= D, C -= D, D = u - h, G > D) {
                          if (D = G - D, D > w && p.sane) {
                            s.msg = "invalid distance too far back", p.mode = i;
                            break e;
                          }
                          if (X = 0, Q = E, x === 0) {
                            if (X += b - D, D < H) {
                              H -= D;
                              do
                                k[u++] = E[X++];
                              while (--D);
                              X = u - G, Q = k;
                            }
                          } else if (x < D) {
                            if (X += b + x - D, D -= x, D < H) {
                              H -= D;
                              do
                                k[u++] = E[X++];
                              while (--D);
                              if (X = 0, x < H) {
                                D = x, H -= D;
                                do
                                  k[u++] = E[X++];
                                while (--D);
                                X = u - G, Q = k;
                              }
                            }
                          } else if (X += x - D, D < H) {
                            H -= D;
                            do
                              k[u++] = E[X++];
                            while (--D);
                            X = u - G, Q = k;
                          }
                          for (; H > 2; )
                            k[u++] = Q[X++], k[u++] = Q[X++], k[u++] = Q[X++], H -= 3;
                          H && (k[u++] = Q[X++], H > 1 && (k[u++] = Q[X++]));
                        } else {
                          X = u - G;
                          do
                            k[u++] = k[X++], k[u++] = k[X++], k[u++] = k[X++], H -= 3;
                          while (H > 2);
                          H && (k[u++] = k[X++], H > 1 && (k[u++] = k[X++]));
                        }
                      } else if (D & 64) {
                        s.msg = "invalid distance code", p.mode = i;
                        break e;
                      } else {
                        O = A[(O & 65535) + (T & (1 << D) - 1)];
                        continue r;
                      }
                      break;
                    }
                } else if (D & 64)
                  if (D & 32) {
                    p.mode = a;
                    break e;
                  } else {
                    s.msg = "invalid literal/length code", p.mode = i;
                    break e;
                  }
                else {
                  O = R[(O & 65535) + (T & (1 << D) - 1)];
                  continue t;
                }
                break;
              }
          } while (l < d && u < y);
        H = C >> 3, l -= H, C -= H << 3, T &= (1 << C) - 1, s.next_in = l, s.next_out = u, s.avail_in = l < d ? 5 + (d - l) : 5 - (l - d), s.avail_out = u < y ? 257 + (y - u) : 257 - (u - y), p.hold = T, p.bits = C;
      };
    }, {}], 58: [function(r, o, n) {
      var i = r("../utils/common"), a = r("./adler32"), s = r("./crc32"), c = r("./inffast"), p = r("./inftrees"), l = 0, d = 1, u = 2, h = 4, y = 5, f = 6, b = 0, w = 1, x = 2, E = -2, T = -3, C = -4, R = -5, A = 8, j = 1, N = 2, O = 3, D = 4, H = 5, G = 6, X = 7, Q = 8, M = 9, k = 10, $ = 11, ne = 12, te = 13, de = 14, ae = 15, z = 16, Z = 17, oe = 18, ye = 19, V = 20, q = 21, ee = 22, ue = 23, ge = 24, he = 25, W = 26, Y = 27, se = 28, Te = 29, Oe = 30, B = 31, U = 32, _ = 852, v = 592, S = 15, P = S;
      function J(re) {
        return (re >>> 24 & 255) + (re >>> 8 & 65280) + ((re & 65280) << 8) + ((re & 255) << 24);
      }
      function ve() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function Re(re) {
        var me;
        return !re || !re.state ? E : (me = re.state, re.total_in = re.total_out = me.total = 0, re.msg = "", me.wrap && (re.adler = me.wrap & 1), me.mode = j, me.last = 0, me.havedict = 0, me.dmax = 32768, me.head = null, me.hold = 0, me.bits = 0, me.lencode = me.lendyn = new i.Buf32(_), me.distcode = me.distdyn = new i.Buf32(v), me.sane = 1, me.back = -1, b);
      }
      function je(re) {
        var me;
        return !re || !re.state ? E : (me = re.state, me.wsize = 0, me.whave = 0, me.wnext = 0, Re(re));
      }
      function qe(re, me) {
        var I, Ee;
        return !re || !re.state || (Ee = re.state, me < 0 ? (I = 0, me = -me) : (I = (me >> 4) + 1, me < 48 && (me &= 15)), me && (me < 8 || me > 15)) ? E : (Ee.window !== null && Ee.wbits !== me && (Ee.window = null), Ee.wrap = I, Ee.wbits = me, je(re));
      }
      function ze(re, me) {
        var I, Ee;
        return re ? (Ee = new ve(), re.state = Ee, Ee.window = null, I = qe(re, me), I !== b && (re.state = null), I) : E;
      }
      function We(re) {
        return ze(re, P);
      }
      var Fe = !0, rt, Ge;
      function Je(re) {
        if (Fe) {
          var me;
          for (rt = new i.Buf32(512), Ge = new i.Buf32(32), me = 0; me < 144; )
            re.lens[me++] = 8;
          for (; me < 256; )
            re.lens[me++] = 9;
          for (; me < 280; )
            re.lens[me++] = 7;
          for (; me < 288; )
            re.lens[me++] = 8;
          for (p(d, re.lens, 0, 288, rt, 0, re.work, { bits: 9 }), me = 0; me < 32; )
            re.lens[me++] = 5;
          p(u, re.lens, 0, 32, Ge, 0, re.work, { bits: 5 }), Fe = !1;
        }
        re.lencode = rt, re.lenbits = 9, re.distcode = Ge, re.distbits = 5;
      }
      function Ze(re, me, I, Ee) {
        var De, g = re.state;
        return g.window === null && (g.wsize = 1 << g.wbits, g.wnext = 0, g.whave = 0, g.window = new i.Buf8(g.wsize)), Ee >= g.wsize ? (i.arraySet(g.window, me, I - g.wsize, g.wsize, 0), g.wnext = 0, g.whave = g.wsize) : (De = g.wsize - g.wnext, De > Ee && (De = Ee), i.arraySet(g.window, me, I - Ee, De, g.wnext), Ee -= De, Ee ? (i.arraySet(g.window, me, I - Ee, Ee, 0), g.wnext = Ee, g.whave = g.wsize) : (g.wnext += De, g.wnext === g.wsize && (g.wnext = 0), g.whave < g.wsize && (g.whave += De))), 0;
      }
      function F(re, me) {
        var I, Ee, De, g, fe, le, L, K, ce, Le, Ae, Ie, Ye, It, nt = 0, pe, ie, Se, ke, Ve, Ke, Be, $e, He = new i.Buf8(4), et, Xe, ct = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!re || !re.state || !re.output || !re.input && re.avail_in !== 0)
          return E;
        I = re.state, I.mode === ne && (I.mode = te), fe = re.next_out, De = re.output, L = re.avail_out, g = re.next_in, Ee = re.input, le = re.avail_in, K = I.hold, ce = I.bits, Le = le, Ae = L, $e = b;
        e:
          for (; ; )
            switch (I.mode) {
              case j:
                if (I.wrap === 0) {
                  I.mode = te;
                  break;
                }
                for (; ce < 16; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if (I.wrap & 2 && K === 35615) {
                  I.check = 0, He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0), K = 0, ce = 0, I.mode = N;
                  break;
                }
                if (I.flags = 0, I.head && (I.head.done = !1), !(I.wrap & 1) || /* check if zlib header allowed */
                (((K & 255) << 8) + (K >> 8)) % 31) {
                  re.msg = "incorrect header check", I.mode = Oe;
                  break;
                }
                if ((K & 15) !== A) {
                  re.msg = "unknown compression method", I.mode = Oe;
                  break;
                }
                if (K >>>= 4, ce -= 4, Be = (K & 15) + 8, I.wbits === 0)
                  I.wbits = Be;
                else if (Be > I.wbits) {
                  re.msg = "invalid window size", I.mode = Oe;
                  break;
                }
                I.dmax = 1 << Be, re.adler = I.check = 1, I.mode = K & 512 ? k : ne, K = 0, ce = 0;
                break;
              case N:
                for (; ce < 16; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if (I.flags = K, (I.flags & 255) !== A) {
                  re.msg = "unknown compression method", I.mode = Oe;
                  break;
                }
                if (I.flags & 57344) {
                  re.msg = "unknown header flags set", I.mode = Oe;
                  break;
                }
                I.head && (I.head.text = K >> 8 & 1), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0, I.mode = O;
              case O:
                for (; ce < 32; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                I.head && (I.head.time = K), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, He[2] = K >>> 16 & 255, He[3] = K >>> 24 & 255, I.check = s(I.check, He, 4, 0)), K = 0, ce = 0, I.mode = D;
              case D:
                for (; ce < 16; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                I.head && (I.head.xflags = K & 255, I.head.os = K >> 8), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0, I.mode = H;
              case H:
                if (I.flags & 1024) {
                  for (; ce < 16; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.length = K, I.head && (I.head.extra_len = K), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0;
                } else
                  I.head && (I.head.extra = null);
                I.mode = G;
              case G:
                if (I.flags & 1024 && (Ie = I.length, Ie > le && (Ie = le), Ie && (I.head && (Be = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), i.arraySet(
                  I.head.extra,
                  Ee,
                  g,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  Ie,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  Be
                )), I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, I.length -= Ie), I.length))
                  break e;
                I.length = 0, I.mode = X;
              case X:
                if (I.flags & 2048) {
                  if (le === 0)
                    break e;
                  Ie = 0;
                  do
                    Be = Ee[g + Ie++], I.head && Be && I.length < 65536 && (I.head.name += String.fromCharCode(Be));
                  while (Be && Ie < le);
                  if (I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, Be)
                    break e;
                } else
                  I.head && (I.head.name = null);
                I.length = 0, I.mode = Q;
              case Q:
                if (I.flags & 4096) {
                  if (le === 0)
                    break e;
                  Ie = 0;
                  do
                    Be = Ee[g + Ie++], I.head && Be && I.length < 65536 && (I.head.comment += String.fromCharCode(Be));
                  while (Be && Ie < le);
                  if (I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, Be)
                    break e;
                } else
                  I.head && (I.head.comment = null);
                I.mode = M;
              case M:
                if (I.flags & 512) {
                  for (; ce < 16; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (K !== (I.check & 65535)) {
                    re.msg = "header crc mismatch", I.mode = Oe;
                    break;
                  }
                  K = 0, ce = 0;
                }
                I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), re.adler = I.check = 0, I.mode = ne;
                break;
              case k:
                for (; ce < 32; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                re.adler = I.check = J(K), K = 0, ce = 0, I.mode = $;
              case $:
                if (I.havedict === 0)
                  return re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, x;
                re.adler = I.check = 1, I.mode = ne;
              case ne:
                if (me === y || me === f)
                  break e;
              case te:
                if (I.last) {
                  K >>>= ce & 7, ce -= ce & 7, I.mode = Y;
                  break;
                }
                for (; ce < 3; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                switch (I.last = K & 1, K >>>= 1, ce -= 1, K & 3) {
                  case 0:
                    I.mode = de;
                    break;
                  case 1:
                    if (Je(I), I.mode = V, me === f) {
                      K >>>= 2, ce -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    I.mode = Z;
                    break;
                  case 3:
                    re.msg = "invalid block type", I.mode = Oe;
                }
                K >>>= 2, ce -= 2;
                break;
              case de:
                for (K >>>= ce & 7, ce -= ce & 7; ce < 32; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if ((K & 65535) !== (K >>> 16 ^ 65535)) {
                  re.msg = "invalid stored block lengths", I.mode = Oe;
                  break;
                }
                if (I.length = K & 65535, K = 0, ce = 0, I.mode = ae, me === f)
                  break e;
              case ae:
                I.mode = z;
              case z:
                if (Ie = I.length, Ie) {
                  if (Ie > le && (Ie = le), Ie > L && (Ie = L), Ie === 0)
                    break e;
                  i.arraySet(De, Ee, g, Ie, fe), le -= Ie, g += Ie, L -= Ie, fe += Ie, I.length -= Ie;
                  break;
                }
                I.mode = ne;
                break;
              case Z:
                for (; ce < 14; ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if (I.nlen = (K & 31) + 257, K >>>= 5, ce -= 5, I.ndist = (K & 31) + 1, K >>>= 5, ce -= 5, I.ncode = (K & 15) + 4, K >>>= 4, ce -= 4, I.nlen > 286 || I.ndist > 30) {
                  re.msg = "too many length or distance symbols", I.mode = Oe;
                  break;
                }
                I.have = 0, I.mode = oe;
              case oe:
                for (; I.have < I.ncode; ) {
                  for (; ce < 3; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.lens[ct[I.have++]] = K & 7, K >>>= 3, ce -= 3;
                }
                for (; I.have < 19; )
                  I.lens[ct[I.have++]] = 0;
                if (I.lencode = I.lendyn, I.lenbits = 7, et = { bits: I.lenbits }, $e = p(l, I.lens, 0, 19, I.lencode, 0, I.work, et), I.lenbits = et.bits, $e) {
                  re.msg = "invalid code lengths set", I.mode = Oe;
                  break;
                }
                I.have = 0, I.mode = ye;
              case ye:
                for (; I.have < I.nlen + I.ndist; ) {
                  for (; nt = I.lencode[K & (1 << I.lenbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (Se < 16)
                    K >>>= pe, ce -= pe, I.lens[I.have++] = Se;
                  else {
                    if (Se === 16) {
                      for (Xe = pe + 2; ce < Xe; ) {
                        if (le === 0)
                          break e;
                        le--, K += Ee[g++] << ce, ce += 8;
                      }
                      if (K >>>= pe, ce -= pe, I.have === 0) {
                        re.msg = "invalid bit length repeat", I.mode = Oe;
                        break;
                      }
                      Be = I.lens[I.have - 1], Ie = 3 + (K & 3), K >>>= 2, ce -= 2;
                    } else if (Se === 17) {
                      for (Xe = pe + 3; ce < Xe; ) {
                        if (le === 0)
                          break e;
                        le--, K += Ee[g++] << ce, ce += 8;
                      }
                      K >>>= pe, ce -= pe, Be = 0, Ie = 3 + (K & 7), K >>>= 3, ce -= 3;
                    } else {
                      for (Xe = pe + 7; ce < Xe; ) {
                        if (le === 0)
                          break e;
                        le--, K += Ee[g++] << ce, ce += 8;
                      }
                      K >>>= pe, ce -= pe, Be = 0, Ie = 11 + (K & 127), K >>>= 7, ce -= 7;
                    }
                    if (I.have + Ie > I.nlen + I.ndist) {
                      re.msg = "invalid bit length repeat", I.mode = Oe;
                      break;
                    }
                    for (; Ie--; )
                      I.lens[I.have++] = Be;
                  }
                }
                if (I.mode === Oe)
                  break;
                if (I.lens[256] === 0) {
                  re.msg = "invalid code -- missing end-of-block", I.mode = Oe;
                  break;
                }
                if (I.lenbits = 9, et = { bits: I.lenbits }, $e = p(d, I.lens, 0, I.nlen, I.lencode, 0, I.work, et), I.lenbits = et.bits, $e) {
                  re.msg = "invalid literal/lengths set", I.mode = Oe;
                  break;
                }
                if (I.distbits = 6, I.distcode = I.distdyn, et = { bits: I.distbits }, $e = p(u, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, et), I.distbits = et.bits, $e) {
                  re.msg = "invalid distances set", I.mode = Oe;
                  break;
                }
                if (I.mode = V, me === f)
                  break e;
              case V:
                I.mode = q;
              case q:
                if (le >= 6 && L >= 258) {
                  re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, c(re, Ae), fe = re.next_out, De = re.output, L = re.avail_out, g = re.next_in, Ee = re.input, le = re.avail_in, K = I.hold, ce = I.bits, I.mode === ne && (I.back = -1);
                  break;
                }
                for (I.back = 0; nt = I.lencode[K & (1 << I.lenbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if (ie && !(ie & 240)) {
                  for (ke = pe, Ve = ie, Ke = Se; nt = I.lencode[Ke + ((K & (1 << ke + Ve) - 1) >> ke)], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(ke + pe <= ce); ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  K >>>= ke, ce -= ke, I.back += ke;
                }
                if (K >>>= pe, ce -= pe, I.back += pe, I.length = Se, ie === 0) {
                  I.mode = W;
                  break;
                }
                if (ie & 32) {
                  I.back = -1, I.mode = ne;
                  break;
                }
                if (ie & 64) {
                  re.msg = "invalid literal/length code", I.mode = Oe;
                  break;
                }
                I.extra = ie & 15, I.mode = ee;
              case ee:
                if (I.extra) {
                  for (Xe = I.extra; ce < Xe; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.length += K & (1 << I.extra) - 1, K >>>= I.extra, ce -= I.extra, I.back += I.extra;
                }
                I.was = I.length, I.mode = ue;
              case ue:
                for (; nt = I.distcode[K & (1 << I.distbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                  if (le === 0)
                    break e;
                  le--, K += Ee[g++] << ce, ce += 8;
                }
                if (!(ie & 240)) {
                  for (ke = pe, Ve = ie, Ke = Se; nt = I.distcode[Ke + ((K & (1 << ke + Ve) - 1) >> ke)], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(ke + pe <= ce); ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  K >>>= ke, ce -= ke, I.back += ke;
                }
                if (K >>>= pe, ce -= pe, I.back += pe, ie & 64) {
                  re.msg = "invalid distance code", I.mode = Oe;
                  break;
                }
                I.offset = Se, I.extra = ie & 15, I.mode = ge;
              case ge:
                if (I.extra) {
                  for (Xe = I.extra; ce < Xe; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.offset += K & (1 << I.extra) - 1, K >>>= I.extra, ce -= I.extra, I.back += I.extra;
                }
                if (I.offset > I.dmax) {
                  re.msg = "invalid distance too far back", I.mode = Oe;
                  break;
                }
                I.mode = he;
              case he:
                if (L === 0)
                  break e;
                if (Ie = Ae - L, I.offset > Ie) {
                  if (Ie = I.offset - Ie, Ie > I.whave && I.sane) {
                    re.msg = "invalid distance too far back", I.mode = Oe;
                    break;
                  }
                  Ie > I.wnext ? (Ie -= I.wnext, Ye = I.wsize - Ie) : Ye = I.wnext - Ie, Ie > I.length && (Ie = I.length), It = I.window;
                } else
                  It = De, Ye = fe - I.offset, Ie = I.length;
                Ie > L && (Ie = L), L -= Ie, I.length -= Ie;
                do
                  De[fe++] = It[Ye++];
                while (--Ie);
                I.length === 0 && (I.mode = q);
                break;
              case W:
                if (L === 0)
                  break e;
                De[fe++] = I.length, L--, I.mode = q;
                break;
              case Y:
                if (I.wrap) {
                  for (; ce < 32; ) {
                    if (le === 0)
                      break e;
                    le--, K |= Ee[g++] << ce, ce += 8;
                  }
                  if (Ae -= L, re.total_out += Ae, I.total += Ae, Ae && (re.adler = I.check = /*UPDATE(state.check, put - _out, _out);*/
                  I.flags ? s(I.check, De, Ae, fe - Ae) : a(I.check, De, Ae, fe - Ae)), Ae = L, (I.flags ? K : J(K)) !== I.check) {
                    re.msg = "incorrect data check", I.mode = Oe;
                    break;
                  }
                  K = 0, ce = 0;
                }
                I.mode = se;
              case se:
                if (I.wrap && I.flags) {
                  for (; ce < 32; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (K !== (I.total & 4294967295)) {
                    re.msg = "incorrect length check", I.mode = Oe;
                    break;
                  }
                  K = 0, ce = 0;
                }
                I.mode = Te;
              case Te:
                $e = w;
                break e;
              case Oe:
                $e = T;
                break e;
              case B:
                return C;
              case U:
              default:
                return E;
            }
        return re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, (I.wsize || Ae !== re.avail_out && I.mode < Oe && (I.mode < Y || me !== h)) && Ze(re, re.output, re.next_out, Ae - re.avail_out), Le -= re.avail_in, Ae -= re.avail_out, re.total_in += Le, re.total_out += Ae, I.total += Ae, I.wrap && Ae && (re.adler = I.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        I.flags ? s(I.check, De, Ae, re.next_out - Ae) : a(I.check, De, Ae, re.next_out - Ae)), re.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === ne ? 128 : 0) + (I.mode === V || I.mode === ae ? 256 : 0), (Le === 0 && Ae === 0 || me === h) && $e === b && ($e = R), $e;
      }
      function we(re) {
        if (!re || !re.state)
          return E;
        var me = re.state;
        return me.window && (me.window = null), re.state = null, b;
      }
      function xe(re, me) {
        var I;
        return !re || !re.state || (I = re.state, !(I.wrap & 2)) ? E : (I.head = me, me.done = !1, b);
      }
      function Ce(re, me) {
        var I = me.length, Ee, De, g;
        return !re || !re.state || (Ee = re.state, Ee.wrap !== 0 && Ee.mode !== $) ? E : Ee.mode === $ && (De = 1, De = a(De, me, I, 0), De !== Ee.check) ? T : (g = Ze(re, me, I, I), g ? (Ee.mode = B, C) : (Ee.havedict = 1, b));
      }
      n.inflateReset = je, n.inflateReset2 = qe, n.inflateResetKeep = Re, n.inflateInit = We, n.inflateInit2 = ze, n.inflate = F, n.inflateEnd = we, n.inflateGetHeader = xe, n.inflateSetDictionary = Ce, n.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(r, o, n) {
      var i = r("../utils/common"), a = 15, s = 852, c = 592, p = 0, l = 1, d = 2, u = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ], h = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ], y = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ], f = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      o.exports = function(b, w, x, E, T, C, R, A) {
        var j = A.bits, N = 0, O = 0, D = 0, H = 0, G = 0, X = 0, Q = 0, M = 0, k = 0, $ = 0, ne, te, de, ae, z, Z = null, oe = 0, ye, V = new i.Buf16(a + 1), q = new i.Buf16(a + 1), ee = null, ue = 0, ge, he, W;
        for (N = 0; N <= a; N++)
          V[N] = 0;
        for (O = 0; O < E; O++)
          V[w[x + O]]++;
        for (G = j, H = a; H >= 1 && V[H] === 0; H--)
          ;
        if (G > H && (G = H), H === 0)
          return T[C++] = 1 << 24 | 64 << 16 | 0, T[C++] = 1 << 24 | 64 << 16 | 0, A.bits = 1, 0;
        for (D = 1; D < H && V[D] === 0; D++)
          ;
        for (G < D && (G = D), M = 1, N = 1; N <= a; N++)
          if (M <<= 1, M -= V[N], M < 0)
            return -1;
        if (M > 0 && (b === p || H !== 1))
          return -1;
        for (q[1] = 0, N = 1; N < a; N++)
          q[N + 1] = q[N] + V[N];
        for (O = 0; O < E; O++)
          w[x + O] !== 0 && (R[q[w[x + O]]++] = O);
        if (b === p ? (Z = ee = R, ye = 19) : b === l ? (Z = u, oe -= 257, ee = h, ue -= 257, ye = 256) : (Z = y, ee = f, ye = -1), $ = 0, O = 0, N = D, z = C, X = G, Q = 0, de = -1, k = 1 << G, ae = k - 1, b === l && k > s || b === d && k > c)
          return 1;
        for (; ; ) {
          ge = N - Q, R[O] < ye ? (he = 0, W = R[O]) : R[O] > ye ? (he = ee[ue + R[O]], W = Z[oe + R[O]]) : (he = 96, W = 0), ne = 1 << N - Q, te = 1 << X, D = te;
          do
            te -= ne, T[z + ($ >> Q) + te] = ge << 24 | he << 16 | W | 0;
          while (te !== 0);
          for (ne = 1 << N - 1; $ & ne; )
            ne >>= 1;
          if (ne !== 0 ? ($ &= ne - 1, $ += ne) : $ = 0, O++, --V[N] === 0) {
            if (N === H)
              break;
            N = w[x + R[O]];
          }
          if (N > G && ($ & ae) !== de) {
            for (Q === 0 && (Q = G), z += D, X = N - Q, M = 1 << X; X + Q < H && (M -= V[X + Q], !(M <= 0)); )
              X++, M <<= 1;
            if (k += 1 << X, b === l && k > s || b === d && k > c)
              return 1;
            de = $ & ae, T[de] = G << 24 | X << 16 | z - C | 0;
          }
        }
        return $ !== 0 && (T[z + $] = N - Q << 24 | 64 << 16 | 0), A.bits = G, 0;
      };
    }, { "../utils/common": 52 }], 60: [function(r, o, n) {
      o.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 61: [function(r, o, n) {
      var i = r("../utils/common"), a = 4, s = 0, c = 1, p = 2;
      function l(F) {
        for (var we = F.length; --we >= 0; )
          F[we] = 0;
      }
      var d = 0, u = 1, h = 2, y = 3, f = 258, b = 29, w = 256, x = w + 1 + b, E = 30, T = 19, C = 2 * x + 1, R = 15, A = 16, j = 7, N = 256, O = 16, D = 17, H = 18, G = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      ), X = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      ), Q = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      ), M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], k = 512, $ = new Array((x + 2) * 2);
      l($);
      var ne = new Array(E * 2);
      l(ne);
      var te = new Array(k);
      l(te);
      var de = new Array(f - y + 1);
      l(de);
      var ae = new Array(b);
      l(ae);
      var z = new Array(E);
      l(z);
      function Z(F, we, xe, Ce, re) {
        this.static_tree = F, this.extra_bits = we, this.extra_base = xe, this.elems = Ce, this.max_length = re, this.has_stree = F && F.length;
      }
      var oe, ye, V;
      function q(F, we) {
        this.dyn_tree = F, this.max_code = 0, this.stat_desc = we;
      }
      function ee(F) {
        return F < 256 ? te[F] : te[256 + (F >>> 7)];
      }
      function ue(F, we) {
        F.pending_buf[F.pending++] = we & 255, F.pending_buf[F.pending++] = we >>> 8 & 255;
      }
      function ge(F, we, xe) {
        F.bi_valid > A - xe ? (F.bi_buf |= we << F.bi_valid & 65535, ue(F, F.bi_buf), F.bi_buf = we >> A - F.bi_valid, F.bi_valid += xe - A) : (F.bi_buf |= we << F.bi_valid & 65535, F.bi_valid += xe);
      }
      function he(F, we, xe) {
        ge(
          F,
          xe[we * 2],
          xe[we * 2 + 1]
          /*.Len*/
        );
      }
      function W(F, we) {
        var xe = 0;
        do
          xe |= F & 1, F >>>= 1, xe <<= 1;
        while (--we > 0);
        return xe >>> 1;
      }
      function Y(F) {
        F.bi_valid === 16 ? (ue(F, F.bi_buf), F.bi_buf = 0, F.bi_valid = 0) : F.bi_valid >= 8 && (F.pending_buf[F.pending++] = F.bi_buf & 255, F.bi_buf >>= 8, F.bi_valid -= 8);
      }
      function se(F, we) {
        var xe = we.dyn_tree, Ce = we.max_code, re = we.stat_desc.static_tree, me = we.stat_desc.has_stree, I = we.stat_desc.extra_bits, Ee = we.stat_desc.extra_base, De = we.stat_desc.max_length, g, fe, le, L, K, ce, Le = 0;
        for (L = 0; L <= R; L++)
          F.bl_count[L] = 0;
        for (xe[F.heap[F.heap_max] * 2 + 1] = 0, g = F.heap_max + 1; g < C; g++)
          fe = F.heap[g], L = xe[xe[fe * 2 + 1] * 2 + 1] + 1, L > De && (L = De, Le++), xe[fe * 2 + 1] = L, !(fe > Ce) && (F.bl_count[L]++, K = 0, fe >= Ee && (K = I[fe - Ee]), ce = xe[fe * 2], F.opt_len += ce * (L + K), me && (F.static_len += ce * (re[fe * 2 + 1] + K)));
        if (Le !== 0) {
          do {
            for (L = De - 1; F.bl_count[L] === 0; )
              L--;
            F.bl_count[L]--, F.bl_count[L + 1] += 2, F.bl_count[De]--, Le -= 2;
          } while (Le > 0);
          for (L = De; L !== 0; L--)
            for (fe = F.bl_count[L]; fe !== 0; )
              le = F.heap[--g], !(le > Ce) && (xe[le * 2 + 1] !== L && (F.opt_len += (L - xe[le * 2 + 1]) * xe[le * 2], xe[le * 2 + 1] = L), fe--);
        }
      }
      function Te(F, we, xe) {
        var Ce = new Array(R + 1), re = 0, me, I;
        for (me = 1; me <= R; me++)
          Ce[me] = re = re + xe[me - 1] << 1;
        for (I = 0; I <= we; I++) {
          var Ee = F[I * 2 + 1];
          Ee !== 0 && (F[I * 2] = W(Ce[Ee]++, Ee));
        }
      }
      function Oe() {
        var F, we, xe, Ce, re, me = new Array(R + 1);
        for (xe = 0, Ce = 0; Ce < b - 1; Ce++)
          for (ae[Ce] = xe, F = 0; F < 1 << G[Ce]; F++)
            de[xe++] = Ce;
        for (de[xe - 1] = Ce, re = 0, Ce = 0; Ce < 16; Ce++)
          for (z[Ce] = re, F = 0; F < 1 << X[Ce]; F++)
            te[re++] = Ce;
        for (re >>= 7; Ce < E; Ce++)
          for (z[Ce] = re << 7, F = 0; F < 1 << X[Ce] - 7; F++)
            te[256 + re++] = Ce;
        for (we = 0; we <= R; we++)
          me[we] = 0;
        for (F = 0; F <= 143; )
          $[F * 2 + 1] = 8, F++, me[8]++;
        for (; F <= 255; )
          $[F * 2 + 1] = 9, F++, me[9]++;
        for (; F <= 279; )
          $[F * 2 + 1] = 7, F++, me[7]++;
        for (; F <= 287; )
          $[F * 2 + 1] = 8, F++, me[8]++;
        for (Te($, x + 1, me), F = 0; F < E; F++)
          ne[F * 2 + 1] = 5, ne[F * 2] = W(F, 5);
        oe = new Z($, G, w + 1, x, R), ye = new Z(ne, X, 0, E, R), V = new Z(new Array(0), Q, 0, T, j);
      }
      function B(F) {
        var we;
        for (we = 0; we < x; we++)
          F.dyn_ltree[we * 2] = 0;
        for (we = 0; we < E; we++)
          F.dyn_dtree[we * 2] = 0;
        for (we = 0; we < T; we++)
          F.bl_tree[we * 2] = 0;
        F.dyn_ltree[N * 2] = 1, F.opt_len = F.static_len = 0, F.last_lit = F.matches = 0;
      }
      function U(F) {
        F.bi_valid > 8 ? ue(F, F.bi_buf) : F.bi_valid > 0 && (F.pending_buf[F.pending++] = F.bi_buf), F.bi_buf = 0, F.bi_valid = 0;
      }
      function _(F, we, xe, Ce) {
        U(F), ue(F, xe), ue(F, ~xe), i.arraySet(F.pending_buf, F.window, we, xe, F.pending), F.pending += xe;
      }
      function v(F, we, xe, Ce) {
        var re = we * 2, me = xe * 2;
        return F[re] < F[me] || F[re] === F[me] && Ce[we] <= Ce[xe];
      }
      function S(F, we, xe) {
        for (var Ce = F.heap[xe], re = xe << 1; re <= F.heap_len && (re < F.heap_len && v(we, F.heap[re + 1], F.heap[re], F.depth) && re++, !v(we, Ce, F.heap[re], F.depth)); )
          F.heap[xe] = F.heap[re], xe = re, re <<= 1;
        F.heap[xe] = Ce;
      }
      function P(F, we, xe) {
        var Ce, re, me = 0, I, Ee;
        if (F.last_lit !== 0)
          do
            Ce = F.pending_buf[F.d_buf + me * 2] << 8 | F.pending_buf[F.d_buf + me * 2 + 1], re = F.pending_buf[F.l_buf + me], me++, Ce === 0 ? he(F, re, we) : (I = de[re], he(F, I + w + 1, we), Ee = G[I], Ee !== 0 && (re -= ae[I], ge(F, re, Ee)), Ce--, I = ee(Ce), he(F, I, xe), Ee = X[I], Ee !== 0 && (Ce -= z[I], ge(F, Ce, Ee)));
          while (me < F.last_lit);
        he(F, N, we);
      }
      function J(F, we) {
        var xe = we.dyn_tree, Ce = we.stat_desc.static_tree, re = we.stat_desc.has_stree, me = we.stat_desc.elems, I, Ee, De = -1, g;
        for (F.heap_len = 0, F.heap_max = C, I = 0; I < me; I++)
          xe[I * 2] !== 0 ? (F.heap[++F.heap_len] = De = I, F.depth[I] = 0) : xe[I * 2 + 1] = 0;
        for (; F.heap_len < 2; )
          g = F.heap[++F.heap_len] = De < 2 ? ++De : 0, xe[g * 2] = 1, F.depth[g] = 0, F.opt_len--, re && (F.static_len -= Ce[g * 2 + 1]);
        for (we.max_code = De, I = F.heap_len >> 1; I >= 1; I--)
          S(F, xe, I);
        g = me;
        do
          I = F.heap[
            1
            /*SMALLEST*/
          ], F.heap[
            1
            /*SMALLEST*/
          ] = F.heap[F.heap_len--], S(
            F,
            xe,
            1
            /*SMALLEST*/
          ), Ee = F.heap[
            1
            /*SMALLEST*/
          ], F.heap[--F.heap_max] = I, F.heap[--F.heap_max] = Ee, xe[g * 2] = xe[I * 2] + xe[Ee * 2], F.depth[g] = (F.depth[I] >= F.depth[Ee] ? F.depth[I] : F.depth[Ee]) + 1, xe[I * 2 + 1] = xe[Ee * 2 + 1] = g, F.heap[
            1
            /*SMALLEST*/
          ] = g++, S(
            F,
            xe,
            1
            /*SMALLEST*/
          );
        while (F.heap_len >= 2);
        F.heap[--F.heap_max] = F.heap[
          1
          /*SMALLEST*/
        ], se(F, we), Te(xe, De, F.bl_count);
      }
      function ve(F, we, xe) {
        var Ce, re = -1, me, I = we[0 * 2 + 1], Ee = 0, De = 7, g = 4;
        for (I === 0 && (De = 138, g = 3), we[(xe + 1) * 2 + 1] = 65535, Ce = 0; Ce <= xe; Ce++)
          me = I, I = we[(Ce + 1) * 2 + 1], !(++Ee < De && me === I) && (Ee < g ? F.bl_tree[me * 2] += Ee : me !== 0 ? (me !== re && F.bl_tree[me * 2]++, F.bl_tree[O * 2]++) : Ee <= 10 ? F.bl_tree[D * 2]++ : F.bl_tree[H * 2]++, Ee = 0, re = me, I === 0 ? (De = 138, g = 3) : me === I ? (De = 6, g = 3) : (De = 7, g = 4));
      }
      function Re(F, we, xe) {
        var Ce, re = -1, me, I = we[0 * 2 + 1], Ee = 0, De = 7, g = 4;
        for (I === 0 && (De = 138, g = 3), Ce = 0; Ce <= xe; Ce++)
          if (me = I, I = we[(Ce + 1) * 2 + 1], !(++Ee < De && me === I)) {
            if (Ee < g)
              do
                he(F, me, F.bl_tree);
              while (--Ee !== 0);
            else
              me !== 0 ? (me !== re && (he(F, me, F.bl_tree), Ee--), he(F, O, F.bl_tree), ge(F, Ee - 3, 2)) : Ee <= 10 ? (he(F, D, F.bl_tree), ge(F, Ee - 3, 3)) : (he(F, H, F.bl_tree), ge(F, Ee - 11, 7));
            Ee = 0, re = me, I === 0 ? (De = 138, g = 3) : me === I ? (De = 6, g = 3) : (De = 7, g = 4);
          }
      }
      function je(F) {
        var we;
        for (ve(F, F.dyn_ltree, F.l_desc.max_code), ve(F, F.dyn_dtree, F.d_desc.max_code), J(F, F.bl_desc), we = T - 1; we >= 3 && F.bl_tree[M[we] * 2 + 1] === 0; we--)
          ;
        return F.opt_len += 3 * (we + 1) + 5 + 5 + 4, we;
      }
      function qe(F, we, xe, Ce) {
        var re;
        for (ge(F, we - 257, 5), ge(F, xe - 1, 5), ge(F, Ce - 4, 4), re = 0; re < Ce; re++)
          ge(F, F.bl_tree[M[re] * 2 + 1], 3);
        Re(F, F.dyn_ltree, we - 1), Re(F, F.dyn_dtree, xe - 1);
      }
      function ze(F) {
        var we = 4093624447, xe;
        for (xe = 0; xe <= 31; xe++, we >>>= 1)
          if (we & 1 && F.dyn_ltree[xe * 2] !== 0)
            return s;
        if (F.dyn_ltree[9 * 2] !== 0 || F.dyn_ltree[10 * 2] !== 0 || F.dyn_ltree[13 * 2] !== 0)
          return c;
        for (xe = 32; xe < w; xe++)
          if (F.dyn_ltree[xe * 2] !== 0)
            return c;
        return s;
      }
      var We = !1;
      function Fe(F) {
        We || (Oe(), We = !0), F.l_desc = new q(F.dyn_ltree, oe), F.d_desc = new q(F.dyn_dtree, ye), F.bl_desc = new q(F.bl_tree, V), F.bi_buf = 0, F.bi_valid = 0, B(F);
      }
      function rt(F, we, xe, Ce) {
        ge(F, (d << 1) + (Ce ? 1 : 0), 3), _(F, we, xe);
      }
      function Ge(F) {
        ge(F, u << 1, 3), he(F, N, $), Y(F);
      }
      function Je(F, we, xe, Ce) {
        var re, me, I = 0;
        F.level > 0 ? (F.strm.data_type === p && (F.strm.data_type = ze(F)), J(F, F.l_desc), J(F, F.d_desc), I = je(F), re = F.opt_len + 3 + 7 >>> 3, me = F.static_len + 3 + 7 >>> 3, me <= re && (re = me)) : re = me = xe + 5, xe + 4 <= re && we !== -1 ? rt(F, we, xe, Ce) : F.strategy === a || me === re ? (ge(F, (u << 1) + (Ce ? 1 : 0), 3), P(F, $, ne)) : (ge(F, (h << 1) + (Ce ? 1 : 0), 3), qe(F, F.l_desc.max_code + 1, F.d_desc.max_code + 1, I + 1), P(F, F.dyn_ltree, F.dyn_dtree)), B(F), Ce && U(F);
      }
      function Ze(F, we, xe) {
        return F.pending_buf[F.d_buf + F.last_lit * 2] = we >>> 8 & 255, F.pending_buf[F.d_buf + F.last_lit * 2 + 1] = we & 255, F.pending_buf[F.l_buf + F.last_lit] = xe & 255, F.last_lit++, we === 0 ? F.dyn_ltree[xe * 2]++ : (F.matches++, we--, F.dyn_ltree[(de[xe] + w + 1) * 2]++, F.dyn_dtree[ee(we) * 2]++), F.last_lit === F.lit_bufsize - 1;
      }
      n._tr_init = Fe, n._tr_stored_block = rt, n._tr_flush_block = Je, n._tr_tally = Ze, n._tr_align = Ge;
    }, { "../utils/common": 52 }], 62: [function(r, o, n) {
      function i() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      o.exports = i;
    }, {}], 63: [function(r, o, n) {
      var i = o.exports = {}, a, s;
      function c() {
        throw new Error("setTimeout has not been defined");
      }
      function p() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? a = setTimeout : a = c;
        } catch {
          a = c;
        }
        try {
          typeof clearTimeout == "function" ? s = clearTimeout : s = p;
        } catch {
          s = p;
        }
      })();
      function l(T) {
        if (a === setTimeout)
          return setTimeout(T, 0);
        if ((a === c || !a) && setTimeout)
          return a = setTimeout, setTimeout(T, 0);
        try {
          return a(T, 0);
        } catch {
          try {
            return a.call(null, T, 0);
          } catch {
            return a.call(this, T, 0);
          }
        }
      }
      function d(T) {
        if (s === clearTimeout)
          return clearTimeout(T);
        if ((s === p || !s) && clearTimeout)
          return s = clearTimeout, clearTimeout(T);
        try {
          return s(T);
        } catch {
          try {
            return s.call(null, T);
          } catch {
            return s.call(this, T);
          }
        }
      }
      var u = [], h = !1, y, f = -1;
      function b() {
        !h || !y || (h = !1, y.length ? u = y.concat(u) : f = -1, u.length && w());
      }
      function w() {
        if (!h) {
          var T = l(b);
          h = !0;
          for (var C = u.length; C; ) {
            for (y = u, u = []; ++f < C; )
              y && y[f].run();
            f = -1, C = u.length;
          }
          y = null, h = !1, d(T);
        }
      }
      i.nextTick = function(T) {
        var C = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var R = 1; R < arguments.length; R++)
            C[R - 1] = arguments[R];
        u.push(new x(T, C)), u.length === 1 && !h && l(w);
      };
      function x(T, C) {
        this.fun = T, this.array = C;
      }
      x.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
      function E() {
      }
      i.on = E, i.addListener = E, i.once = E, i.off = E, i.removeListener = E, i.removeAllListeners = E, i.emit = E, i.prependListener = E, i.prependOnceListener = E, i.listeners = function(T) {
        return [];
      }, i.binding = function(T) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(T) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    }, {}], 64: [function(r, o, n) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var i = r("buffer"), a = i.Buffer;
      function s(p, l) {
        for (var d in p)
          l[d] = p[d];
      }
      a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? o.exports = i : (s(i, n), n.Buffer = c);
      function c(p, l, d) {
        return a(p, l, d);
      }
      c.prototype = Object.create(a.prototype), s(a, c), c.from = function(p, l, d) {
        if (typeof p == "number")
          throw new TypeError("Argument must not be a number");
        return a(p, l, d);
      }, c.alloc = function(p, l, d) {
        if (typeof p != "number")
          throw new TypeError("Argument must be a number");
        var u = a(p);
        return l !== void 0 ? typeof d == "string" ? u.fill(l, d) : u.fill(l) : u.fill(0), u;
      }, c.allocUnsafe = function(p) {
        if (typeof p != "number")
          throw new TypeError("Argument must be a number");
        return a(p);
      }, c.allocUnsafeSlow = function(p) {
        if (typeof p != "number")
          throw new TypeError("Argument must be a number");
        return i.SlowBuffer(p);
      };
    }, { buffer: 32 }], 65: [function(r, o, n) {
      o.exports = s;
      var i = r("events").EventEmitter, a = r("inherits");
      a(s, i), s.Readable = r("readable-stream/lib/_stream_readable.js"), s.Writable = r("readable-stream/lib/_stream_writable.js"), s.Duplex = r("readable-stream/lib/_stream_duplex.js"), s.Transform = r("readable-stream/lib/_stream_transform.js"), s.PassThrough = r("readable-stream/lib/_stream_passthrough.js"), s.finished = r("readable-stream/lib/internal/streams/end-of-stream.js"), s.pipeline = r("readable-stream/lib/internal/streams/pipeline.js"), s.Stream = s;
      function s() {
        i.call(this);
      }
      s.prototype.pipe = function(c, p) {
        var l = this;
        function d(x) {
          c.writable && c.write(x) === !1 && l.pause && l.pause();
        }
        l.on("data", d);
        function u() {
          l.readable && l.resume && l.resume();
        }
        c.on("drain", u), !c._isStdio && (!p || p.end !== !1) && (l.on("end", y), l.on("close", f));
        var h = !1;
        function y() {
          h || (h = !0, c.end());
        }
        function f() {
          h || (h = !0, typeof c.destroy == "function" && c.destroy());
        }
        function b(x) {
          if (w(), i.listenerCount(this, "error") === 0)
            throw x;
        }
        l.on("error", b), c.on("error", b);
        function w() {
          l.removeListener("data", d), c.removeListener("drain", u), l.removeListener("end", y), l.removeListener("close", f), l.removeListener("error", b), c.removeListener("error", b), l.removeListener("end", w), l.removeListener("close", w), c.removeListener("close", w);
        }
        return l.on("end", w), l.on("close", w), c.on("close", w), c.emit("pipe", l), c;
      };
    }, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(r, o, n) {
      function i(u, h) {
        u.prototype = Object.create(h.prototype), u.prototype.constructor = u, u.__proto__ = h;
      }
      var a = {};
      function s(u, h, y) {
        y || (y = Error);
        function f(w, x, E) {
          return typeof h == "string" ? h : h(w, x, E);
        }
        var b = /* @__PURE__ */ function(w) {
          i(x, w);
          function x(E, T, C) {
            return w.call(this, f(E, T, C)) || this;
          }
          return x;
        }(y);
        b.prototype.name = y.name, b.prototype.code = u, a[u] = b;
      }
      function c(u, h) {
        if (Array.isArray(u)) {
          var y = u.length;
          return u = u.map(function(f) {
            return String(f);
          }), y > 2 ? "one of ".concat(h, " ").concat(u.slice(0, y - 1).join(", "), ", or ") + u[y - 1] : y === 2 ? "one of ".concat(h, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(h, " ").concat(u[0]);
        } else
          return "of ".concat(h, " ").concat(String(u));
      }
      function p(u, h, y) {
        return u.substr(0, h.length) === h;
      }
      function l(u, h, y) {
        return (y === void 0 || y > u.length) && (y = u.length), u.substring(y - h.length, y) === h;
      }
      function d(u, h, y) {
        return typeof y != "number" && (y = 0), y + h.length > u.length ? !1 : u.indexOf(h, y) !== -1;
      }
      s("ERR_INVALID_OPT_VALUE", function(u, h) {
        return 'The value "' + h + '" is invalid for option "' + u + '"';
      }, TypeError), s("ERR_INVALID_ARG_TYPE", function(u, h, y) {
        var f;
        typeof h == "string" && p(h, "not ") ? (f = "must not be", h = h.replace(/^not /, "")) : f = "must be";
        var b;
        if (l(u, " argument"))
          b = "The ".concat(u, " ").concat(f, " ").concat(c(h, "type"));
        else {
          var w = d(u, ".") ? "property" : "argument";
          b = 'The "'.concat(u, '" ').concat(w, " ").concat(f, " ").concat(c(h, "type"));
        }
        return b += ". Received type ".concat(typeof y), b;
      }, TypeError), s("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), s("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
        return "The " + u + " method is not implemented";
      }), s("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), s("ERR_STREAM_DESTROYED", function(u) {
        return "Cannot call " + u + " after a stream was destroyed";
      }), s("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), s("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), s("ERR_STREAM_WRITE_AFTER_END", "write after end"), s("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), s("ERR_UNKNOWN_ENCODING", function(u) {
        return "Unknown encoding: " + u;
      }, TypeError), s("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), o.exports.codes = a;
    }, {}], 67: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = Object.keys || function(f) {
            var b = [];
            for (var w in f)
              b.push(w);
            return b;
          };
          o.exports = u;
          var s = r("./_stream_readable"), c = r("./_stream_writable");
          r("inherits")(u, s);
          for (var p = a(c.prototype), l = 0; l < p.length; l++) {
            var d = p[l];
            u.prototype[d] || (u.prototype[d] = c.prototype[d]);
          }
          function u(f) {
            if (!(this instanceof u))
              return new u(f);
            s.call(this, f), c.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h)));
          }
          Object.defineProperty(u.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          }), Object.defineProperty(u.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(u.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function h() {
            this._writableState.ended || i.nextTick(y, this);
          }
          function y(f) {
            f.end();
          }
          Object.defineProperty(u.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function(f) {
              this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
            }
          });
        }).call(this);
      }).call(this, r("_process"));
    }, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(r, o, n) {
      o.exports = a;
      var i = r("./_stream_transform");
      r("inherits")(a, i);
      function a(s) {
        if (!(this instanceof a))
          return new a(s);
        i.call(this, s);
      }
      a.prototype._transform = function(s, c, p) {
        p(null, s);
      };
    }, { "./_stream_transform": 70, inherits: 46 }], 69: [function(r, o, n) {
      (function(i, a) {
        (function() {
          o.exports = M;
          var s;
          M.ReadableState = Q, r("events").EventEmitter;
          var c = function(B, U) {
            return B.listeners(U).length;
          }, p = r("./internal/streams/stream"), l = r("buffer").Buffer, d = a.Uint8Array || function() {
          };
          function u(B) {
            return l.from(B);
          }
          function h(B) {
            return l.isBuffer(B) || B instanceof d;
          }
          var y = r("util"), f;
          y && y.debuglog ? f = y.debuglog("stream") : f = function() {
          };
          var b = r("./internal/streams/buffer_list"), w = r("./internal/streams/destroy"), x = r("./internal/streams/state"), E = x.getHighWaterMark, T = r("../errors").codes, C = T.ERR_INVALID_ARG_TYPE, R = T.ERR_STREAM_PUSH_AFTER_EOF, A = T.ERR_METHOD_NOT_IMPLEMENTED, j = T.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, N, O, D;
          r("inherits")(M, p);
          var H = w.errorOrDestroy, G = ["error", "close", "destroy", "pause", "resume"];
          function X(B, U, _) {
            if (typeof B.prependListener == "function")
              return B.prependListener(U, _);
            !B._events || !B._events[U] ? B.on(U, _) : Array.isArray(B._events[U]) ? B._events[U].unshift(_) : B._events[U] = [_, B._events[U]];
          }
          function Q(B, U, _) {
            s = s || r("./_stream_duplex"), B = B || {}, typeof _ != "boolean" && (_ = U instanceof s), this.objectMode = !!B.objectMode, _ && (this.objectMode = this.objectMode || !!B.readableObjectMode), this.highWaterMark = E(this, B, "readableHighWaterMark", _), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = B.emitClose !== !1, this.autoDestroy = !!B.autoDestroy, this.destroyed = !1, this.defaultEncoding = B.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, B.encoding && (N || (N = r("string_decoder/").StringDecoder), this.decoder = new N(B.encoding), this.encoding = B.encoding);
          }
          function M(B) {
            if (s = s || r("./_stream_duplex"), !(this instanceof M))
              return new M(B);
            var U = this instanceof s;
            this._readableState = new Q(B, this, U), this.readable = !0, B && (typeof B.read == "function" && (this._read = B.read), typeof B.destroy == "function" && (this._destroy = B.destroy)), p.call(this);
          }
          Object.defineProperty(M.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(B) {
              this._readableState && (this._readableState.destroyed = B);
            }
          }), M.prototype.destroy = w.destroy, M.prototype._undestroy = w.undestroy, M.prototype._destroy = function(B, U) {
            U(B);
          }, M.prototype.push = function(B, U) {
            var _ = this._readableState, v;
            return _.objectMode ? v = !0 : typeof B == "string" && (U = U || _.defaultEncoding, U !== _.encoding && (B = l.from(B, U), U = ""), v = !0), k(this, B, U, !1, v);
          }, M.prototype.unshift = function(B) {
            return k(this, B, null, !0, !1);
          };
          function k(B, U, _, v, S) {
            f("readableAddChunk", U);
            var P = B._readableState;
            if (U === null)
              P.reading = !1, z(B, P);
            else {
              var J;
              if (S || (J = ne(P, U)), J)
                H(B, J);
              else if (P.objectMode || U && U.length > 0)
                if (typeof U != "string" && !P.objectMode && Object.getPrototypeOf(U) !== l.prototype && (U = u(U)), v)
                  P.endEmitted ? H(B, new j()) : $(B, P, U, !0);
                else if (P.ended)
                  H(B, new R());
                else {
                  if (P.destroyed)
                    return !1;
                  P.reading = !1, P.decoder && !_ ? (U = P.decoder.write(U), P.objectMode || U.length !== 0 ? $(B, P, U, !1) : ye(B, P)) : $(B, P, U, !1);
                }
              else
                v || (P.reading = !1, ye(B, P));
            }
            return !P.ended && (P.length < P.highWaterMark || P.length === 0);
          }
          function $(B, U, _, v) {
            U.flowing && U.length === 0 && !U.sync ? (U.awaitDrain = 0, B.emit("data", _)) : (U.length += U.objectMode ? 1 : _.length, v ? U.buffer.unshift(_) : U.buffer.push(_), U.needReadable && Z(B)), ye(B, U);
          }
          function ne(B, U) {
            var _;
            return !h(U) && typeof U != "string" && U !== void 0 && !B.objectMode && (_ = new C("chunk", ["string", "Buffer", "Uint8Array"], U)), _;
          }
          M.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, M.prototype.setEncoding = function(B) {
            N || (N = r("string_decoder/").StringDecoder);
            var U = new N(B);
            this._readableState.decoder = U, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var _ = this._readableState.buffer.head, v = ""; _ !== null; )
              v += U.write(_.data), _ = _.next;
            return this._readableState.buffer.clear(), v !== "" && this._readableState.buffer.push(v), this._readableState.length = v.length, this;
          };
          var te = 1073741824;
          function de(B) {
            return B >= te ? B = te : (B--, B |= B >>> 1, B |= B >>> 2, B |= B >>> 4, B |= B >>> 8, B |= B >>> 16, B++), B;
          }
          function ae(B, U) {
            return B <= 0 || U.length === 0 && U.ended ? 0 : U.objectMode ? 1 : B !== B ? U.flowing && U.length ? U.buffer.head.data.length : U.length : (B > U.highWaterMark && (U.highWaterMark = de(B)), B <= U.length ? B : U.ended ? U.length : (U.needReadable = !0, 0));
          }
          M.prototype.read = function(B) {
            f("read", B), B = parseInt(B, 10);
            var U = this._readableState, _ = B;
            if (B !== 0 && (U.emittedReadable = !1), B === 0 && U.needReadable && ((U.highWaterMark !== 0 ? U.length >= U.highWaterMark : U.length > 0) || U.ended))
              return f("read: emitReadable", U.length, U.ended), U.length === 0 && U.ended ? se(this) : Z(this), null;
            if (B = ae(B, U), B === 0 && U.ended)
              return U.length === 0 && se(this), null;
            var v = U.needReadable;
            f("need readable", v), (U.length === 0 || U.length - B < U.highWaterMark) && (v = !0, f("length less than watermark", v)), U.ended || U.reading ? (v = !1, f("reading or ended", v)) : v && (f("do read"), U.reading = !0, U.sync = !0, U.length === 0 && (U.needReadable = !0), this._read(U.highWaterMark), U.sync = !1, U.reading || (B = ae(_, U)));
            var S;
            return B > 0 ? S = Y(B, U) : S = null, S === null ? (U.needReadable = U.length <= U.highWaterMark, B = 0) : (U.length -= B, U.awaitDrain = 0), U.length === 0 && (U.ended || (U.needReadable = !0), _ !== B && U.ended && se(this)), S !== null && this.emit("data", S), S;
          };
          function z(B, U) {
            if (f("onEofChunk"), !U.ended) {
              if (U.decoder) {
                var _ = U.decoder.end();
                _ && _.length && (U.buffer.push(_), U.length += U.objectMode ? 1 : _.length);
              }
              U.ended = !0, U.sync ? Z(B) : (U.needReadable = !1, U.emittedReadable || (U.emittedReadable = !0, oe(B)));
            }
          }
          function Z(B) {
            var U = B._readableState;
            f("emitReadable", U.needReadable, U.emittedReadable), U.needReadable = !1, U.emittedReadable || (f("emitReadable", U.flowing), U.emittedReadable = !0, i.nextTick(oe, B));
          }
          function oe(B) {
            var U = B._readableState;
            f("emitReadable_", U.destroyed, U.length, U.ended), !U.destroyed && (U.length || U.ended) && (B.emit("readable"), U.emittedReadable = !1), U.needReadable = !U.flowing && !U.ended && U.length <= U.highWaterMark, W(B);
          }
          function ye(B, U) {
            U.readingMore || (U.readingMore = !0, i.nextTick(V, B, U));
          }
          function V(B, U) {
            for (; !U.reading && !U.ended && (U.length < U.highWaterMark || U.flowing && U.length === 0); ) {
              var _ = U.length;
              if (f("maybeReadMore read 0"), B.read(0), _ === U.length)
                break;
            }
            U.readingMore = !1;
          }
          M.prototype._read = function(B) {
            H(this, new A("_read()"));
          }, M.prototype.pipe = function(B, U) {
            var _ = this, v = this._readableState;
            switch (v.pipesCount) {
              case 0:
                v.pipes = B;
                break;
              case 1:
                v.pipes = [v.pipes, B];
                break;
              default:
                v.pipes.push(B);
                break;
            }
            v.pipesCount += 1, f("pipe count=%d opts=%j", v.pipesCount, U);
            var S = (!U || U.end !== !1) && B !== i.stdout && B !== i.stderr, P = S ? ve : Ge;
            v.endEmitted ? i.nextTick(P) : _.once("end", P), B.on("unpipe", J);
            function J(Je, Ze) {
              f("onunpipe"), Je === _ && Ze && Ze.hasUnpiped === !1 && (Ze.hasUnpiped = !0, qe());
            }
            function ve() {
              f("onend"), B.end();
            }
            var Re = q(_);
            B.on("drain", Re);
            var je = !1;
            function qe() {
              f("cleanup"), B.removeListener("close", Fe), B.removeListener("finish", rt), B.removeListener("drain", Re), B.removeListener("error", We), B.removeListener("unpipe", J), _.removeListener("end", ve), _.removeListener("end", Ge), _.removeListener("data", ze), je = !0, v.awaitDrain && (!B._writableState || B._writableState.needDrain) && Re();
            }
            _.on("data", ze);
            function ze(Je) {
              f("ondata");
              var Ze = B.write(Je);
              f("dest.write", Ze), Ze === !1 && ((v.pipesCount === 1 && v.pipes === B || v.pipesCount > 1 && Oe(v.pipes, B) !== -1) && !je && (f("false write response, pause", v.awaitDrain), v.awaitDrain++), _.pause());
            }
            function We(Je) {
              f("onerror", Je), Ge(), B.removeListener("error", We), c(B, "error") === 0 && H(B, Je);
            }
            X(B, "error", We);
            function Fe() {
              B.removeListener("finish", rt), Ge();
            }
            B.once("close", Fe);
            function rt() {
              f("onfinish"), B.removeListener("close", Fe), Ge();
            }
            B.once("finish", rt);
            function Ge() {
              f("unpipe"), _.unpipe(B);
            }
            return B.emit("pipe", _), v.flowing || (f("pipe resume"), _.resume()), B;
          };
          function q(B) {
            return function() {
              var U = B._readableState;
              f("pipeOnDrain", U.awaitDrain), U.awaitDrain && U.awaitDrain--, U.awaitDrain === 0 && c(B, "data") && (U.flowing = !0, W(B));
            };
          }
          M.prototype.unpipe = function(B) {
            var U = this._readableState, _ = {
              hasUnpiped: !1
            };
            if (U.pipesCount === 0)
              return this;
            if (U.pipesCount === 1)
              return B && B !== U.pipes ? this : (B || (B = U.pipes), U.pipes = null, U.pipesCount = 0, U.flowing = !1, B && B.emit("unpipe", this, _), this);
            if (!B) {
              var v = U.pipes, S = U.pipesCount;
              U.pipes = null, U.pipesCount = 0, U.flowing = !1;
              for (var P = 0; P < S; P++)
                v[P].emit("unpipe", this, {
                  hasUnpiped: !1
                });
              return this;
            }
            var J = Oe(U.pipes, B);
            return J === -1 ? this : (U.pipes.splice(J, 1), U.pipesCount -= 1, U.pipesCount === 1 && (U.pipes = U.pipes[0]), B.emit("unpipe", this, _), this);
          }, M.prototype.on = function(B, U) {
            var _ = p.prototype.on.call(this, B, U), v = this._readableState;
            return B === "data" ? (v.readableListening = this.listenerCount("readable") > 0, v.flowing !== !1 && this.resume()) : B === "readable" && !v.endEmitted && !v.readableListening && (v.readableListening = v.needReadable = !0, v.flowing = !1, v.emittedReadable = !1, f("on readable", v.length, v.reading), v.length ? Z(this) : v.reading || i.nextTick(ue, this)), _;
          }, M.prototype.addListener = M.prototype.on, M.prototype.removeListener = function(B, U) {
            var _ = p.prototype.removeListener.call(this, B, U);
            return B === "readable" && i.nextTick(ee, this), _;
          }, M.prototype.removeAllListeners = function(B) {
            var U = p.prototype.removeAllListeners.apply(this, arguments);
            return (B === "readable" || B === void 0) && i.nextTick(ee, this), U;
          };
          function ee(B) {
            var U = B._readableState;
            U.readableListening = B.listenerCount("readable") > 0, U.resumeScheduled && !U.paused ? U.flowing = !0 : B.listenerCount("data") > 0 && B.resume();
          }
          function ue(B) {
            f("readable nexttick read 0"), B.read(0);
          }
          M.prototype.resume = function() {
            var B = this._readableState;
            return B.flowing || (f("resume"), B.flowing = !B.readableListening, ge(this, B)), B.paused = !1, this;
          };
          function ge(B, U) {
            U.resumeScheduled || (U.resumeScheduled = !0, i.nextTick(he, B, U));
          }
          function he(B, U) {
            f("resume", U.reading), U.reading || B.read(0), U.resumeScheduled = !1, B.emit("resume"), W(B), U.flowing && !U.reading && B.read(0);
          }
          M.prototype.pause = function() {
            return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          };
          function W(B) {
            var U = B._readableState;
            for (f("flow", U.flowing); U.flowing && B.read() !== null; )
              ;
          }
          M.prototype.wrap = function(B) {
            var U = this, _ = this._readableState, v = !1;
            B.on("end", function() {
              if (f("wrapped end"), _.decoder && !_.ended) {
                var J = _.decoder.end();
                J && J.length && U.push(J);
              }
              U.push(null);
            }), B.on("data", function(J) {
              if (f("wrapped data"), _.decoder && (J = _.decoder.write(J)), !(_.objectMode && J == null) && !(!_.objectMode && (!J || !J.length))) {
                var ve = U.push(J);
                ve || (v = !0, B.pause());
              }
            });
            for (var S in B)
              this[S] === void 0 && typeof B[S] == "function" && (this[S] = /* @__PURE__ */ function(J) {
                return function() {
                  return B[J].apply(B, arguments);
                };
              }(S));
            for (var P = 0; P < G.length; P++)
              B.on(G[P], this.emit.bind(this, G[P]));
            return this._read = function(J) {
              f("wrapped _read", J), v && (v = !1, B.resume());
            }, this;
          }, typeof Symbol == "function" && (M.prototype[Symbol.asyncIterator] = function() {
            return O === void 0 && (O = r("./internal/streams/async_iterator")), O(this);
          }), Object.defineProperty(M.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), Object.defineProperty(M.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState && this._readableState.buffer;
            }
          }), Object.defineProperty(M.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.flowing;
            },
            set: function(B) {
              this._readableState && (this._readableState.flowing = B);
            }
          }), M._fromList = Y, Object.defineProperty(M.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.length;
            }
          });
          function Y(B, U) {
            if (U.length === 0)
              return null;
            var _;
            return U.objectMode ? _ = U.buffer.shift() : !B || B >= U.length ? (U.decoder ? _ = U.buffer.join("") : U.buffer.length === 1 ? _ = U.buffer.first() : _ = U.buffer.concat(U.length), U.buffer.clear()) : _ = U.buffer.consume(B, U.decoder), _;
          }
          function se(B) {
            var U = B._readableState;
            f("endReadable", U.endEmitted), U.endEmitted || (U.ended = !0, i.nextTick(Te, U, B));
          }
          function Te(B, U) {
            if (f("endReadableNT", B.endEmitted, B.length), !B.endEmitted && B.length === 0 && (B.endEmitted = !0, U.readable = !1, U.emit("end"), B.autoDestroy)) {
              var _ = U._writableState;
              (!_ || _.autoDestroy && _.finished) && U.destroy();
            }
          }
          typeof Symbol == "function" && (M.from = function(B, U) {
            return D === void 0 && (D = r("./internal/streams/from")), D(M, B, U);
          });
          function Oe(B, U) {
            for (var _ = 0, v = B.length; _ < v; _++)
              if (B[_] === U)
                return _;
            return -1;
          }
        }).call(this);
      }).call(this, r("_process"), typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(r, o, n) {
      o.exports = u;
      var i = r("../errors").codes, a = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, c = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, p = i.ERR_TRANSFORM_WITH_LENGTH_0, l = r("./_stream_duplex");
      r("inherits")(u, l);
      function d(f, b) {
        var w = this._transformState;
        w.transforming = !1;
        var x = w.writecb;
        if (x === null)
          return this.emit("error", new s());
        w.writechunk = null, w.writecb = null, b != null && this.push(b), x(f);
        var E = this._readableState;
        E.reading = !1, (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
      }
      function u(f) {
        if (!(this instanceof u))
          return new u(f);
        l.call(this, f), this._transformState = {
          afterTransform: d.bind(this),
          needTransform: !1,
          transforming: !1,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, f && (typeof f.transform == "function" && (this._transform = f.transform), typeof f.flush == "function" && (this._flush = f.flush)), this.on("prefinish", h);
      }
      function h() {
        var f = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(b, w) {
          y(f, b, w);
        }) : y(this, null, null);
      }
      u.prototype.push = function(f, b) {
        return this._transformState.needTransform = !1, l.prototype.push.call(this, f, b);
      }, u.prototype._transform = function(f, b, w) {
        w(new a("_transform()"));
      }, u.prototype._write = function(f, b, w) {
        var x = this._transformState;
        if (x.writecb = w, x.writechunk = f, x.writeencoding = b, !x.transforming) {
          var E = this._readableState;
          (x.needTransform || E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
        }
      }, u.prototype._read = function(f) {
        var b = this._transformState;
        b.writechunk !== null && !b.transforming ? (b.transforming = !0, this._transform(b.writechunk, b.writeencoding, b.afterTransform)) : b.needTransform = !0;
      }, u.prototype._destroy = function(f, b) {
        l.prototype._destroy.call(this, f, function(w) {
          b(w);
        });
      };
      function y(f, b, w) {
        if (b)
          return f.emit("error", b);
        if (w != null && f.push(w), f._writableState.length)
          throw new p();
        if (f._transformState.transforming)
          throw new c();
        return f.push(null);
      }
    }, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(r, o, n) {
      (function(i, a) {
        (function() {
          o.exports = Q;
          function s(W) {
            var Y = this;
            this.next = null, this.entry = null, this.finish = function() {
              he(Y, W);
            };
          }
          var c;
          Q.WritableState = G;
          var p = {
            deprecate: r("util-deprecate")
          }, l = r("./internal/streams/stream"), d = r("buffer").Buffer, u = a.Uint8Array || function() {
          };
          function h(W) {
            return d.from(W);
          }
          function y(W) {
            return d.isBuffer(W) || W instanceof u;
          }
          var f = r("./internal/streams/destroy"), b = r("./internal/streams/state"), w = b.getHighWaterMark, x = r("../errors").codes, E = x.ERR_INVALID_ARG_TYPE, T = x.ERR_METHOD_NOT_IMPLEMENTED, C = x.ERR_MULTIPLE_CALLBACK, R = x.ERR_STREAM_CANNOT_PIPE, A = x.ERR_STREAM_DESTROYED, j = x.ERR_STREAM_NULL_VALUES, N = x.ERR_STREAM_WRITE_AFTER_END, O = x.ERR_UNKNOWN_ENCODING, D = f.errorOrDestroy;
          r("inherits")(Q, l);
          function H() {
          }
          function G(W, Y, se) {
            c = c || r("./_stream_duplex"), W = W || {}, typeof se != "boolean" && (se = Y instanceof c), this.objectMode = !!W.objectMode, se && (this.objectMode = this.objectMode || !!W.writableObjectMode), this.highWaterMark = w(this, W, "writableHighWaterMark", se), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var Te = W.decodeStrings === !1;
            this.decodeStrings = !Te, this.defaultEncoding = W.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Oe) {
              z(Y, Oe);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = W.emitClose !== !1, this.autoDestroy = !!W.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
          }
          G.prototype.getBuffer = function() {
            for (var W = this.bufferedRequest, Y = []; W; )
              Y.push(W), W = W.next;
            return Y;
          }, function() {
            try {
              Object.defineProperty(G.prototype, "buffer", {
                get: p.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var X;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (X = Function.prototype[Symbol.hasInstance], Object.defineProperty(Q, Symbol.hasInstance, {
            value: function(W) {
              return X.call(this, W) ? !0 : this !== Q ? !1 : W && W._writableState instanceof G;
            }
          })) : X = function(W) {
            return W instanceof this;
          };
          function Q(W) {
            c = c || r("./_stream_duplex");
            var Y = this instanceof c;
            if (!Y && !X.call(Q, this))
              return new Q(W);
            this._writableState = new G(W, this, Y), this.writable = !0, W && (typeof W.write == "function" && (this._write = W.write), typeof W.writev == "function" && (this._writev = W.writev), typeof W.destroy == "function" && (this._destroy = W.destroy), typeof W.final == "function" && (this._final = W.final)), l.call(this);
          }
          Q.prototype.pipe = function() {
            D(this, new R());
          };
          function M(W, Y) {
            var se = new N();
            D(W, se), i.nextTick(Y, se);
          }
          function k(W, Y, se, Te) {
            var Oe;
            return se === null ? Oe = new j() : typeof se != "string" && !Y.objectMode && (Oe = new E("chunk", ["string", "Buffer"], se)), Oe ? (D(W, Oe), i.nextTick(Te, Oe), !1) : !0;
          }
          Q.prototype.write = function(W, Y, se) {
            var Te = this._writableState, Oe = !1, B = !Te.objectMode && y(W);
            return B && !d.isBuffer(W) && (W = h(W)), typeof Y == "function" && (se = Y, Y = null), B ? Y = "buffer" : Y || (Y = Te.defaultEncoding), typeof se != "function" && (se = H), Te.ending ? M(this, se) : (B || k(this, Te, W, se)) && (Te.pendingcb++, Oe = ne(this, Te, B, W, Y, se)), Oe;
          }, Q.prototype.cork = function() {
            this._writableState.corked++;
          }, Q.prototype.uncork = function() {
            var W = this._writableState;
            W.corked && (W.corked--, !W.writing && !W.corked && !W.bufferProcessing && W.bufferedRequest && ye(this, W));
          }, Q.prototype.setDefaultEncoding = function(W) {
            if (typeof W == "string" && (W = W.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((W + "").toLowerCase()) > -1))
              throw new O(W);
            return this._writableState.defaultEncoding = W, this;
          }, Object.defineProperty(Q.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function $(W, Y, se) {
            return !W.objectMode && W.decodeStrings !== !1 && typeof Y == "string" && (Y = d.from(Y, se)), Y;
          }
          Object.defineProperty(Q.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function ne(W, Y, se, Te, Oe, B) {
            if (!se) {
              var U = $(Y, Te, Oe);
              Te !== U && (se = !0, Oe = "buffer", Te = U);
            }
            var _ = Y.objectMode ? 1 : Te.length;
            Y.length += _;
            var v = Y.length < Y.highWaterMark;
            if (v || (Y.needDrain = !0), Y.writing || Y.corked) {
              var S = Y.lastBufferedRequest;
              Y.lastBufferedRequest = {
                chunk: Te,
                encoding: Oe,
                isBuf: se,
                callback: B,
                next: null
              }, S ? S.next = Y.lastBufferedRequest : Y.bufferedRequest = Y.lastBufferedRequest, Y.bufferedRequestCount += 1;
            } else
              te(W, Y, !1, _, Te, Oe, B);
            return v;
          }
          function te(W, Y, se, Te, Oe, B, U) {
            Y.writelen = Te, Y.writecb = U, Y.writing = !0, Y.sync = !0, Y.destroyed ? Y.onwrite(new A("write")) : se ? W._writev(Oe, Y.onwrite) : W._write(Oe, B, Y.onwrite), Y.sync = !1;
          }
          function de(W, Y, se, Te, Oe) {
            --Y.pendingcb, se ? (i.nextTick(Oe, Te), i.nextTick(ue, W, Y), W._writableState.errorEmitted = !0, D(W, Te)) : (Oe(Te), W._writableState.errorEmitted = !0, D(W, Te), ue(W, Y));
          }
          function ae(W) {
            W.writing = !1, W.writecb = null, W.length -= W.writelen, W.writelen = 0;
          }
          function z(W, Y) {
            var se = W._writableState, Te = se.sync, Oe = se.writecb;
            if (typeof Oe != "function")
              throw new C();
            if (ae(se), Y)
              de(W, se, Te, Y, Oe);
            else {
              var B = V(se) || W.destroyed;
              !B && !se.corked && !se.bufferProcessing && se.bufferedRequest && ye(W, se), Te ? i.nextTick(Z, W, se, B, Oe) : Z(W, se, B, Oe);
            }
          }
          function Z(W, Y, se, Te) {
            se || oe(W, Y), Y.pendingcb--, Te(), ue(W, Y);
          }
          function oe(W, Y) {
            Y.length === 0 && Y.needDrain && (Y.needDrain = !1, W.emit("drain"));
          }
          function ye(W, Y) {
            Y.bufferProcessing = !0;
            var se = Y.bufferedRequest;
            if (W._writev && se && se.next) {
              var Te = Y.bufferedRequestCount, Oe = new Array(Te), B = Y.corkedRequestsFree;
              B.entry = se;
              for (var U = 0, _ = !0; se; )
                Oe[U] = se, se.isBuf || (_ = !1), se = se.next, U += 1;
              Oe.allBuffers = _, te(W, Y, !0, Y.length, Oe, "", B.finish), Y.pendingcb++, Y.lastBufferedRequest = null, B.next ? (Y.corkedRequestsFree = B.next, B.next = null) : Y.corkedRequestsFree = new s(Y), Y.bufferedRequestCount = 0;
            } else {
              for (; se; ) {
                var v = se.chunk, S = se.encoding, P = se.callback, J = Y.objectMode ? 1 : v.length;
                if (te(W, Y, !1, J, v, S, P), se = se.next, Y.bufferedRequestCount--, Y.writing)
                  break;
              }
              se === null && (Y.lastBufferedRequest = null);
            }
            Y.bufferedRequest = se, Y.bufferProcessing = !1;
          }
          Q.prototype._write = function(W, Y, se) {
            se(new T("_write()"));
          }, Q.prototype._writev = null, Q.prototype.end = function(W, Y, se) {
            var Te = this._writableState;
            return typeof W == "function" ? (se = W, W = null, Y = null) : typeof Y == "function" && (se = Y, Y = null), W != null && this.write(W, Y), Te.corked && (Te.corked = 1, this.uncork()), Te.ending || ge(this, Te, se), this;
          }, Object.defineProperty(Q.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function V(W) {
            return W.ending && W.length === 0 && W.bufferedRequest === null && !W.finished && !W.writing;
          }
          function q(W, Y) {
            W._final(function(se) {
              Y.pendingcb--, se && D(W, se), Y.prefinished = !0, W.emit("prefinish"), ue(W, Y);
            });
          }
          function ee(W, Y) {
            !Y.prefinished && !Y.finalCalled && (typeof W._final == "function" && !Y.destroyed ? (Y.pendingcb++, Y.finalCalled = !0, i.nextTick(q, W, Y)) : (Y.prefinished = !0, W.emit("prefinish")));
          }
          function ue(W, Y) {
            var se = V(Y);
            if (se && (ee(W, Y), Y.pendingcb === 0 && (Y.finished = !0, W.emit("finish"), Y.autoDestroy))) {
              var Te = W._readableState;
              (!Te || Te.autoDestroy && Te.endEmitted) && W.destroy();
            }
            return se;
          }
          function ge(W, Y, se) {
            Y.ending = !0, ue(W, Y), se && (Y.finished ? i.nextTick(se) : W.once("finish", se)), Y.ended = !0, W.writable = !1;
          }
          function he(W, Y, se) {
            var Te = W.entry;
            for (W.entry = null; Te; ) {
              var Oe = Te.callback;
              Y.pendingcb--, Oe(se), Te = Te.next;
            }
            Y.corkedRequestsFree.next = W;
          }
          Object.defineProperty(Q.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(W) {
              this._writableState && (this._writableState.destroyed = W);
            }
          }), Q.prototype.destroy = f.destroy, Q.prototype._undestroy = f.undestroy, Q.prototype._destroy = function(W, Y) {
            Y(W);
          };
        }).call(this);
      }).call(this, r("_process"), typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(r, o, n) {
      (function(i) {
        (function() {
          var a;
          function s(A, j, N) {
            return j in A ? Object.defineProperty(A, j, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : A[j] = N, A;
          }
          var c = r("./end-of-stream"), p = Symbol("lastResolve"), l = Symbol("lastReject"), d = Symbol("error"), u = Symbol("ended"), h = Symbol("lastPromise"), y = Symbol("handlePromise"), f = Symbol("stream");
          function b(A, j) {
            return {
              value: A,
              done: j
            };
          }
          function w(A) {
            var j = A[p];
            if (j !== null) {
              var N = A[f].read();
              N !== null && (A[h] = null, A[p] = null, A[l] = null, j(b(N, !1)));
            }
          }
          function x(A) {
            i.nextTick(w, A);
          }
          function E(A, j) {
            return function(N, O) {
              A.then(function() {
                if (j[u]) {
                  N(b(void 0, !0));
                  return;
                }
                j[y](N, O);
              }, O);
            };
          }
          var T = Object.getPrototypeOf(function() {
          }), C = Object.setPrototypeOf((a = {
            get stream() {
              return this[f];
            },
            next: function() {
              var A = this, j = this[d];
              if (j !== null)
                return Promise.reject(j);
              if (this[u])
                return Promise.resolve(b(void 0, !0));
              if (this[f].destroyed)
                return new Promise(function(H, G) {
                  i.nextTick(function() {
                    A[d] ? G(A[d]) : H(b(void 0, !0));
                  });
                });
              var N = this[h], O;
              if (N)
                O = new Promise(E(N, this));
              else {
                var D = this[f].read();
                if (D !== null)
                  return Promise.resolve(b(D, !1));
                O = new Promise(this[y]);
              }
              return this[h] = O, O;
            }
          }, s(a, Symbol.asyncIterator, function() {
            return this;
          }), s(a, "return", function() {
            var A = this;
            return new Promise(function(j, N) {
              A[f].destroy(null, function(O) {
                if (O) {
                  N(O);
                  return;
                }
                j(b(void 0, !0));
              });
            });
          }), a), T), R = function(A) {
            var j, N = Object.create(C, (j = {}, s(j, f, {
              value: A,
              writable: !0
            }), s(j, p, {
              value: null,
              writable: !0
            }), s(j, l, {
              value: null,
              writable: !0
            }), s(j, d, {
              value: null,
              writable: !0
            }), s(j, u, {
              value: A._readableState.endEmitted,
              writable: !0
            }), s(j, y, {
              value: function(O, D) {
                var H = N[f].read();
                H ? (N[h] = null, N[p] = null, N[l] = null, O(b(H, !1))) : (N[p] = O, N[l] = D);
              },
              writable: !0
            }), j));
            return N[h] = null, c(A, function(O) {
              if (O && O.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var D = N[l];
                D !== null && (N[h] = null, N[p] = null, N[l] = null, D(O)), N[d] = O;
                return;
              }
              var H = N[p];
              H !== null && (N[h] = null, N[p] = null, N[l] = null, H(b(void 0, !0))), N[u] = !0;
            }), A.on("readable", x.bind(null, N)), N;
          };
          o.exports = R;
        }).call(this);
      }).call(this, r("_process"));
    }, { "./end-of-stream": 75, _process: 63 }], 73: [function(r, o, n) {
      function i(w, x) {
        var E = Object.keys(w);
        if (Object.getOwnPropertySymbols) {
          var T = Object.getOwnPropertySymbols(w);
          x && (T = T.filter(function(C) {
            return Object.getOwnPropertyDescriptor(w, C).enumerable;
          })), E.push.apply(E, T);
        }
        return E;
      }
      function a(w) {
        for (var x = 1; x < arguments.length; x++) {
          var E = arguments[x] != null ? arguments[x] : {};
          x % 2 ? i(Object(E), !0).forEach(function(T) {
            s(w, T, E[T]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : i(Object(E)).forEach(function(T) {
            Object.defineProperty(w, T, Object.getOwnPropertyDescriptor(E, T));
          });
        }
        return w;
      }
      function s(w, x, E) {
        return x in w ? Object.defineProperty(w, x, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : w[x] = E, w;
      }
      function c(w, x) {
        if (!(w instanceof x))
          throw new TypeError("Cannot call a class as a function");
      }
      function p(w, x) {
        for (var E = 0; E < x.length; E++) {
          var T = x[E];
          T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(w, T.key, T);
        }
      }
      function l(w, x, E) {
        return x && p(w.prototype, x), w;
      }
      var d = r("buffer"), u = d.Buffer, h = r("util"), y = h.inspect, f = y && y.custom || "inspect";
      function b(w, x, E) {
        u.prototype.copy.call(w, x, E);
      }
      o.exports = /* @__PURE__ */ function() {
        function w() {
          c(this, w), this.head = null, this.tail = null, this.length = 0;
        }
        return l(w, [{
          key: "push",
          value: function(x) {
            var E = {
              data: x,
              next: null
            };
            this.length > 0 ? this.tail.next = E : this.head = E, this.tail = E, ++this.length;
          }
        }, {
          key: "unshift",
          value: function(x) {
            var E = {
              data: x,
              next: this.head
            };
            this.length === 0 && (this.tail = E), this.head = E, ++this.length;
          }
        }, {
          key: "shift",
          value: function() {
            if (this.length !== 0) {
              var x = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, x;
            }
          }
        }, {
          key: "clear",
          value: function() {
            this.head = this.tail = null, this.length = 0;
          }
        }, {
          key: "join",
          value: function(x) {
            if (this.length === 0)
              return "";
            for (var E = this.head, T = "" + E.data; E = E.next; )
              T += x + E.data;
            return T;
          }
        }, {
          key: "concat",
          value: function(x) {
            if (this.length === 0)
              return u.alloc(0);
            for (var E = u.allocUnsafe(x >>> 0), T = this.head, C = 0; T; )
              b(T.data, E, C), C += T.data.length, T = T.next;
            return E;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function(x, E) {
            var T;
            return x < this.head.data.length ? (T = this.head.data.slice(0, x), this.head.data = this.head.data.slice(x)) : x === this.head.data.length ? T = this.shift() : T = E ? this._getString(x) : this._getBuffer(x), T;
          }
        }, {
          key: "first",
          value: function() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function(x) {
            var E = this.head, T = 1, C = E.data;
            for (x -= C.length; E = E.next; ) {
              var R = E.data, A = x > R.length ? R.length : x;
              if (A === R.length ? C += R : C += R.slice(0, x), x -= A, x === 0) {
                A === R.length ? (++T, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = R.slice(A));
                break;
              }
              ++T;
            }
            return this.length -= T, C;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function(x) {
            var E = u.allocUnsafe(x), T = this.head, C = 1;
            for (T.data.copy(E), x -= T.data.length; T = T.next; ) {
              var R = T.data, A = x > R.length ? R.length : x;
              if (R.copy(E, E.length - x, 0, A), x -= A, x === 0) {
                A === R.length ? (++C, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = R.slice(A));
                break;
              }
              ++C;
            }
            return this.length -= C, E;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: f,
          value: function(x, E) {
            return y(this, a({}, E, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: !1
            }));
          }
        }]), w;
      }();
    }, { buffer: 32, util: 29 }], 74: [function(r, o, n) {
      (function(i) {
        (function() {
          function a(u, h) {
            var y = this, f = this._readableState && this._readableState.destroyed, b = this._writableState && this._writableState.destroyed;
            return f || b ? (h ? h(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, i.nextTick(l, this, u)) : i.nextTick(l, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(w) {
              !h && w ? y._writableState ? y._writableState.errorEmitted ? i.nextTick(c, y) : (y._writableState.errorEmitted = !0, i.nextTick(s, y, w)) : i.nextTick(s, y, w) : h ? (i.nextTick(c, y), h(w)) : i.nextTick(c, y);
            }), this);
          }
          function s(u, h) {
            l(u, h), c(u);
          }
          function c(u) {
            u._writableState && !u._writableState.emitClose || u._readableState && !u._readableState.emitClose || u.emit("close");
          }
          function p() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function l(u, h) {
            u.emit("error", h);
          }
          function d(u, h) {
            var y = u._readableState, f = u._writableState;
            y && y.autoDestroy || f && f.autoDestroy ? u.destroy(h) : u.emit("error", h);
          }
          o.exports = {
            destroy: a,
            undestroy: p,
            errorOrDestroy: d
          };
        }).call(this);
      }).call(this, r("_process"));
    }, { _process: 63 }], 75: [function(r, o, n) {
      var i = r("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function a(l) {
        var d = !1;
        return function() {
          if (!d) {
            d = !0;
            for (var u = arguments.length, h = new Array(u), y = 0; y < u; y++)
              h[y] = arguments[y];
            l.apply(this, h);
          }
        };
      }
      function s() {
      }
      function c(l) {
        return l.setHeader && typeof l.abort == "function";
      }
      function p(l, d, u) {
        if (typeof d == "function")
          return p(l, null, d);
        d || (d = {}), u = a(u || s);
        var h = d.readable || d.readable !== !1 && l.readable, y = d.writable || d.writable !== !1 && l.writable, f = function() {
          l.writable || w();
        }, b = l._writableState && l._writableState.finished, w = function() {
          y = !1, b = !0, h || u.call(l);
        }, x = l._readableState && l._readableState.endEmitted, E = function() {
          h = !1, x = !0, y || u.call(l);
        }, T = function(A) {
          u.call(l, A);
        }, C = function() {
          var A;
          if (h && !x)
            return (!l._readableState || !l._readableState.ended) && (A = new i()), u.call(l, A);
          if (y && !b)
            return (!l._writableState || !l._writableState.ended) && (A = new i()), u.call(l, A);
        }, R = function() {
          l.req.on("finish", w);
        };
        return c(l) ? (l.on("complete", w), l.on("abort", C), l.req ? R() : l.on("request", R)) : y && !l._writableState && (l.on("end", f), l.on("close", f)), l.on("end", E), l.on("finish", w), d.error !== !1 && l.on("error", T), l.on("close", C), function() {
          l.removeListener("complete", w), l.removeListener("abort", C), l.removeListener("request", R), l.req && l.req.removeListener("finish", w), l.removeListener("end", f), l.removeListener("close", f), l.removeListener("finish", w), l.removeListener("end", E), l.removeListener("error", T), l.removeListener("close", C);
        };
      }
      o.exports = p;
    }, { "../../../errors": 66 }], 76: [function(r, o, n) {
      o.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 77: [function(r, o, n) {
      var i;
      function a(w) {
        var x = !1;
        return function() {
          x || (x = !0, w.apply(void 0, arguments));
        };
      }
      var s = r("../../../errors").codes, c = s.ERR_MISSING_ARGS, p = s.ERR_STREAM_DESTROYED;
      function l(w) {
        if (w)
          throw w;
      }
      function d(w) {
        return w.setHeader && typeof w.abort == "function";
      }
      function u(w, x, E, T) {
        T = a(T);
        var C = !1;
        w.on("close", function() {
          C = !0;
        }), i === void 0 && (i = r("./end-of-stream")), i(w, {
          readable: x,
          writable: E
        }, function(A) {
          if (A)
            return T(A);
          C = !0, T();
        });
        var R = !1;
        return function(A) {
          if (!C && !R) {
            if (R = !0, d(w))
              return w.abort();
            if (typeof w.destroy == "function")
              return w.destroy();
            T(A || new p("pipe"));
          }
        };
      }
      function h(w) {
        w();
      }
      function y(w, x) {
        return w.pipe(x);
      }
      function f(w) {
        return !w.length || typeof w[w.length - 1] != "function" ? l : w.pop();
      }
      function b() {
        for (var w = arguments.length, x = new Array(w), E = 0; E < w; E++)
          x[E] = arguments[E];
        var T = f(x);
        if (Array.isArray(x[0]) && (x = x[0]), x.length < 2)
          throw new c("streams");
        var C, R = x.map(function(A, j) {
          var N = j < x.length - 1, O = j > 0;
          return u(A, N, O, function(D) {
            C || (C = D), D && R.forEach(h), !N && (R.forEach(h), T(C));
          });
        });
        return x.reduce(y);
      }
      o.exports = b;
    }, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(r, o, n) {
      var i = r("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function a(c, p, l) {
        return c.highWaterMark != null ? c.highWaterMark : p ? c[l] : null;
      }
      function s(c, p, l, d) {
        var u = a(p, d, l);
        if (u != null) {
          if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
            var h = d ? l : "highWaterMark";
            throw new i(h, u);
          }
          return Math.floor(u);
        }
        return c.objectMode ? 16 : 16 * 1024;
      }
      o.exports = {
        getHighWaterMark: s
      };
    }, { "../../../errors": 66 }], 79: [function(r, o, n) {
      o.exports = r("events").EventEmitter;
    }, { events: 35 }], 80: [function(r, o, n) {
      var i = r("safe-buffer").Buffer, a = i.isEncoding || function(R) {
        switch (R = "" + R, R && R.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function s(R) {
        if (!R)
          return "utf8";
        for (var A; ; )
          switch (R) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return R;
            default:
              if (A)
                return;
              R = ("" + R).toLowerCase(), A = !0;
          }
      }
      function c(R) {
        var A = s(R);
        if (typeof A != "string" && (i.isEncoding === a || !a(R)))
          throw new Error("Unknown encoding: " + R);
        return A || R;
      }
      n.StringDecoder = p;
      function p(R) {
        this.encoding = c(R);
        var A;
        switch (this.encoding) {
          case "utf16le":
            this.text = b, this.end = w, A = 4;
            break;
          case "utf8":
            this.fillLast = h, A = 4;
            break;
          case "base64":
            this.text = x, this.end = E, A = 3;
            break;
          default:
            this.write = T, this.end = C;
            return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = i.allocUnsafe(A);
      }
      p.prototype.write = function(R) {
        if (R.length === 0)
          return "";
        var A, j;
        if (this.lastNeed) {
          if (A = this.fillLast(R), A === void 0)
            return "";
          j = this.lastNeed, this.lastNeed = 0;
        } else
          j = 0;
        return j < R.length ? A ? A + this.text(R, j) : this.text(R, j) : A || "";
      }, p.prototype.end = f, p.prototype.text = y, p.prototype.fillLast = function(R) {
        if (this.lastNeed <= R.length)
          return R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, R.length), this.lastNeed -= R.length;
      };
      function l(R) {
        return R <= 127 ? 0 : R >> 5 === 6 ? 2 : R >> 4 === 14 ? 3 : R >> 3 === 30 ? 4 : R >> 6 === 2 ? -1 : -2;
      }
      function d(R, A, j) {
        var N = A.length - 1;
        if (N < j)
          return 0;
        var O = l(A[N]);
        return O >= 0 ? (O > 0 && (R.lastNeed = O - 1), O) : --N < j || O === -2 ? 0 : (O = l(A[N]), O >= 0 ? (O > 0 && (R.lastNeed = O - 2), O) : --N < j || O === -2 ? 0 : (O = l(A[N]), O >= 0 ? (O > 0 && (O === 2 ? O = 0 : R.lastNeed = O - 3), O) : 0));
      }
      function u(R, A, j) {
        if ((A[0] & 192) !== 128)
          return R.lastNeed = 0, "�";
        if (R.lastNeed > 1 && A.length > 1) {
          if ((A[1] & 192) !== 128)
            return R.lastNeed = 1, "�";
          if (R.lastNeed > 2 && A.length > 2 && (A[2] & 192) !== 128)
            return R.lastNeed = 2, "�";
        }
      }
      function h(R) {
        var A = this.lastTotal - this.lastNeed, j = u(this, R);
        if (j !== void 0)
          return j;
        if (this.lastNeed <= R.length)
          return R.copy(this.lastChar, A, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        R.copy(this.lastChar, A, 0, R.length), this.lastNeed -= R.length;
      }
      function y(R, A) {
        var j = d(this, R, A);
        if (!this.lastNeed)
          return R.toString("utf8", A);
        this.lastTotal = j;
        var N = R.length - (j - this.lastNeed);
        return R.copy(this.lastChar, 0, N), R.toString("utf8", A, N);
      }
      function f(R) {
        var A = R && R.length ? this.write(R) : "";
        return this.lastNeed ? A + "�" : A;
      }
      function b(R, A) {
        if ((R.length - A) % 2 === 0) {
          var j = R.toString("utf16le", A);
          if (j) {
            var N = j.charCodeAt(j.length - 1);
            if (N >= 55296 && N <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1], j.slice(0, -1);
          }
          return j;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = R[R.length - 1], R.toString("utf16le", A, R.length - 1);
      }
      function w(R) {
        var A = R && R.length ? this.write(R) : "";
        if (this.lastNeed) {
          var j = this.lastTotal - this.lastNeed;
          return A + this.lastChar.toString("utf16le", 0, j);
        }
        return A;
      }
      function x(R, A) {
        var j = (R.length - A) % 3;
        return j === 0 ? R.toString("base64", A) : (this.lastNeed = 3 - j, this.lastTotal = 3, j === 1 ? this.lastChar[0] = R[R.length - 1] : (this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1]), R.toString("base64", A, R.length - j));
      }
      function E(R) {
        var A = R && R.length ? this.write(R) : "";
        return this.lastNeed ? A + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : A;
      }
      function T(R) {
        return R.toString(this.encoding);
      }
      function C(R) {
        return R && R.length ? this.write(R) : "";
      }
    }, { "safe-buffer": 64 }], 81: [function(r, o, n) {
      (function(i) {
        (function() {
          o.exports = a;
          function a(c, p) {
            if (s("noDeprecation"))
              return c;
            var l = !1;
            function d() {
              if (!l) {
                if (s("throwDeprecation"))
                  throw new Error(p);
                s("traceDeprecation") ? console.trace(p) : console.warn(p), l = !0;
              }
              return c.apply(this, arguments);
            }
            return d;
          }
          function s(c) {
            try {
              if (!i.localStorage)
                return !1;
            } catch {
              return !1;
            }
            var p = i.localStorage[c];
            return p == null ? !1 : String(p).toLowerCase() === "true";
          }
        }).call(this);
      }).call(this, typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 82: [function(r, o, n) {
      arguments[4][25][0].apply(n, arguments);
    }, { dup: 25 }], 83: [function(r, o, n) {
      var i = r("is-arguments"), a = r("is-generator-function"), s = r("which-typed-array"), c = r("is-typed-array");
      function p(P) {
        return P.call.bind(P);
      }
      var l = typeof BigInt < "u", d = typeof Symbol < "u", u = p(Object.prototype.toString), h = p(Number.prototype.valueOf), y = p(String.prototype.valueOf), f = p(Boolean.prototype.valueOf);
      if (l)
        var b = p(BigInt.prototype.valueOf);
      if (d)
        var w = p(Symbol.prototype.valueOf);
      function x(P, J) {
        if (typeof P != "object")
          return !1;
        try {
          return J(P), !0;
        } catch {
          return !1;
        }
      }
      n.isArgumentsObject = i, n.isGeneratorFunction = a, n.isTypedArray = c;
      function E(P) {
        return typeof Promise < "u" && P instanceof Promise || P !== null && typeof P == "object" && typeof P.then == "function" && typeof P.catch == "function";
      }
      n.isPromise = E;
      function T(P) {
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(P) : c(P) || V(P);
      }
      n.isArrayBufferView = T;
      function C(P) {
        return s(P) === "Uint8Array";
      }
      n.isUint8Array = C;
      function R(P) {
        return s(P) === "Uint8ClampedArray";
      }
      n.isUint8ClampedArray = R;
      function A(P) {
        return s(P) === "Uint16Array";
      }
      n.isUint16Array = A;
      function j(P) {
        return s(P) === "Uint32Array";
      }
      n.isUint32Array = j;
      function N(P) {
        return s(P) === "Int8Array";
      }
      n.isInt8Array = N;
      function O(P) {
        return s(P) === "Int16Array";
      }
      n.isInt16Array = O;
      function D(P) {
        return s(P) === "Int32Array";
      }
      n.isInt32Array = D;
      function H(P) {
        return s(P) === "Float32Array";
      }
      n.isFloat32Array = H;
      function G(P) {
        return s(P) === "Float64Array";
      }
      n.isFloat64Array = G;
      function X(P) {
        return s(P) === "BigInt64Array";
      }
      n.isBigInt64Array = X;
      function Q(P) {
        return s(P) === "BigUint64Array";
      }
      n.isBigUint64Array = Q;
      function M(P) {
        return u(P) === "[object Map]";
      }
      M.working = typeof Map < "u" && M(/* @__PURE__ */ new Map());
      function k(P) {
        return typeof Map > "u" ? !1 : M.working ? M(P) : P instanceof Map;
      }
      n.isMap = k;
      function $(P) {
        return u(P) === "[object Set]";
      }
      $.working = typeof Set < "u" && $(/* @__PURE__ */ new Set());
      function ne(P) {
        return typeof Set > "u" ? !1 : $.working ? $(P) : P instanceof Set;
      }
      n.isSet = ne;
      function te(P) {
        return u(P) === "[object WeakMap]";
      }
      te.working = typeof WeakMap < "u" && te(/* @__PURE__ */ new WeakMap());
      function de(P) {
        return typeof WeakMap > "u" ? !1 : te.working ? te(P) : P instanceof WeakMap;
      }
      n.isWeakMap = de;
      function ae(P) {
        return u(P) === "[object WeakSet]";
      }
      ae.working = typeof WeakSet < "u" && ae(/* @__PURE__ */ new WeakSet());
      function z(P) {
        return ae(P);
      }
      n.isWeakSet = z;
      function Z(P) {
        return u(P) === "[object ArrayBuffer]";
      }
      Z.working = typeof ArrayBuffer < "u" && Z(new ArrayBuffer());
      function oe(P) {
        return typeof ArrayBuffer > "u" ? !1 : Z.working ? Z(P) : P instanceof ArrayBuffer;
      }
      n.isArrayBuffer = oe;
      function ye(P) {
        return u(P) === "[object DataView]";
      }
      ye.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ye(new DataView(new ArrayBuffer(1), 0, 1));
      function V(P) {
        return typeof DataView > "u" ? !1 : ye.working ? ye(P) : P instanceof DataView;
      }
      n.isDataView = V;
      var q = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
      function ee(P) {
        return u(P) === "[object SharedArrayBuffer]";
      }
      function ue(P) {
        return typeof q > "u" ? !1 : (typeof ee.working > "u" && (ee.working = ee(new q())), ee.working ? ee(P) : P instanceof q);
      }
      n.isSharedArrayBuffer = ue;
      function ge(P) {
        return u(P) === "[object AsyncFunction]";
      }
      n.isAsyncFunction = ge;
      function he(P) {
        return u(P) === "[object Map Iterator]";
      }
      n.isMapIterator = he;
      function W(P) {
        return u(P) === "[object Set Iterator]";
      }
      n.isSetIterator = W;
      function Y(P) {
        return u(P) === "[object Generator]";
      }
      n.isGeneratorObject = Y;
      function se(P) {
        return u(P) === "[object WebAssembly.Module]";
      }
      n.isWebAssemblyCompiledModule = se;
      function Te(P) {
        return x(P, h);
      }
      n.isNumberObject = Te;
      function Oe(P) {
        return x(P, y);
      }
      n.isStringObject = Oe;
      function B(P) {
        return x(P, f);
      }
      n.isBooleanObject = B;
      function U(P) {
        return l && x(P, b);
      }
      n.isBigIntObject = U;
      function _(P) {
        return d && x(P, w);
      }
      n.isSymbolObject = _;
      function v(P) {
        return Te(P) || Oe(P) || B(P) || U(P) || _(P);
      }
      n.isBoxedPrimitive = v;
      function S(P) {
        return typeof Uint8Array < "u" && (oe(P) || ue(P));
      }
      n.isAnyArrayBuffer = S, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(P) {
        Object.defineProperty(n, P, {
          enumerable: !1,
          value: function() {
            throw new Error(P + " is not supported in userland");
          }
        });
      });
    }, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = Object.getOwnPropertyDescriptors || function(V) {
            for (var q = Object.keys(V), ee = {}, ue = 0; ue < q.length; ue++)
              ee[q[ue]] = Object.getOwnPropertyDescriptor(V, q[ue]);
            return ee;
          }, s = /%[sdj%]/g;
          n.format = function(V) {
            if (!O(V)) {
              for (var q = [], ee = 0; ee < arguments.length; ee++)
                q.push(d(arguments[ee]));
              return q.join(" ");
            }
            for (var ee = 1, ue = arguments, ge = ue.length, he = String(V).replace(s, function(se) {
              if (se === "%%")
                return "%";
              if (ee >= ge)
                return se;
              switch (se) {
                case "%s":
                  return String(ue[ee++]);
                case "%d":
                  return Number(ue[ee++]);
                case "%j":
                  try {
                    return JSON.stringify(ue[ee++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return se;
              }
            }), W = ue[ee]; ee < ge; W = ue[++ee])
              A(W) || !X(W) ? he += " " + W : he += " " + d(W);
            return he;
          }, n.deprecate = function(V, q) {
            if (typeof i < "u" && i.noDeprecation === !0)
              return V;
            if (typeof i > "u")
              return function() {
                return n.deprecate(V, q).apply(this, arguments);
              };
            var ee = !1;
            function ue() {
              if (!ee) {
                if (i.throwDeprecation)
                  throw new Error(q);
                i.traceDeprecation ? console.trace(q) : console.error(q), ee = !0;
              }
              return V.apply(this, arguments);
            }
            return ue;
          };
          var c = {}, p = /^$/;
          if (i.env.NODE_DEBUG) {
            var l = i.env.NODE_DEBUG;
            l = l.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), p = new RegExp("^" + l + "$", "i");
          }
          n.debuglog = function(V) {
            if (V = V.toUpperCase(), !c[V])
              if (p.test(V)) {
                var q = i.pid;
                c[V] = function() {
                  var ee = n.format.apply(n, arguments);
                  console.error("%s %d: %s", V, q, ee);
                };
              } else
                c[V] = function() {
                };
            return c[V];
          };
          function d(V, q) {
            var ee = {
              seen: [],
              stylize: h
            };
            return arguments.length >= 3 && (ee.depth = arguments[2]), arguments.length >= 4 && (ee.colors = arguments[3]), R(q) ? ee.showHidden = q : q && n._extend(ee, q), H(ee.showHidden) && (ee.showHidden = !1), H(ee.depth) && (ee.depth = 2), H(ee.colors) && (ee.colors = !1), H(ee.customInspect) && (ee.customInspect = !0), ee.colors && (ee.stylize = u), f(ee, V, ee.depth);
          }
          n.inspect = d, d.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, d.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function u(V, q) {
            var ee = d.styles[q];
            return ee ? "\x1B[" + d.colors[ee][0] + "m" + V + "\x1B[" + d.colors[ee][1] + "m" : V;
          }
          function h(V, q) {
            return V;
          }
          function y(V) {
            var q = {};
            return V.forEach(function(ee, ue) {
              q[ee] = !0;
            }), q;
          }
          function f(V, q, ee) {
            if (V.customInspect && q && k(q.inspect) && // Filter out the util module, it's inspect function is special
            q.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
            !(q.constructor && q.constructor.prototype === q)) {
              var ue = q.inspect(ee, V);
              return O(ue) || (ue = f(V, ue, ee)), ue;
            }
            var ge = b(V, q);
            if (ge)
              return ge;
            var he = Object.keys(q), W = y(he);
            if (V.showHidden && (he = Object.getOwnPropertyNames(q)), M(q) && (he.indexOf("message") >= 0 || he.indexOf("description") >= 0))
              return w(q);
            if (he.length === 0) {
              if (k(q)) {
                var Y = q.name ? ": " + q.name : "";
                return V.stylize("[Function" + Y + "]", "special");
              }
              if (G(q))
                return V.stylize(RegExp.prototype.toString.call(q), "regexp");
              if (Q(q))
                return V.stylize(Date.prototype.toString.call(q), "date");
              if (M(q))
                return w(q);
            }
            var se = "", Te = !1, Oe = ["{", "}"];
            if (C(q) && (Te = !0, Oe = ["[", "]"]), k(q)) {
              var B = q.name ? ": " + q.name : "";
              se = " [Function" + B + "]";
            }
            if (G(q) && (se = " " + RegExp.prototype.toString.call(q)), Q(q) && (se = " " + Date.prototype.toUTCString.call(q)), M(q) && (se = " " + w(q)), he.length === 0 && (!Te || q.length == 0))
              return Oe[0] + se + Oe[1];
            if (ee < 0)
              return G(q) ? V.stylize(RegExp.prototype.toString.call(q), "regexp") : V.stylize("[Object]", "special");
            V.seen.push(q);
            var U;
            return Te ? U = x(V, q, ee, W, he) : U = he.map(function(_) {
              return E(V, q, ee, W, _, Te);
            }), V.seen.pop(), T(U, se, Oe);
          }
          function b(V, q) {
            if (H(q))
              return V.stylize("undefined", "undefined");
            if (O(q)) {
              var ee = "'" + JSON.stringify(q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return V.stylize(ee, "string");
            }
            if (N(q))
              return V.stylize("" + q, "number");
            if (R(q))
              return V.stylize("" + q, "boolean");
            if (A(q))
              return V.stylize("null", "null");
          }
          function w(V) {
            return "[" + Error.prototype.toString.call(V) + "]";
          }
          function x(V, q, ee, ue, ge) {
            for (var he = [], W = 0, Y = q.length; W < Y; ++W)
              z(q, String(W)) ? he.push(E(
                V,
                q,
                ee,
                ue,
                String(W),
                !0
              )) : he.push("");
            return ge.forEach(function(se) {
              se.match(/^\d+$/) || he.push(E(
                V,
                q,
                ee,
                ue,
                se,
                !0
              ));
            }), he;
          }
          function E(V, q, ee, ue, ge, he) {
            var W, Y, se;
            if (se = Object.getOwnPropertyDescriptor(q, ge) || { value: q[ge] }, se.get ? se.set ? Y = V.stylize("[Getter/Setter]", "special") : Y = V.stylize("[Getter]", "special") : se.set && (Y = V.stylize("[Setter]", "special")), z(ue, ge) || (W = "[" + ge + "]"), Y || (V.seen.indexOf(se.value) < 0 ? (A(ee) ? Y = f(V, se.value, null) : Y = f(V, se.value, ee - 1), Y.indexOf(`
`) > -1 && (he ? Y = Y.split(`
`).map(function(Te) {
              return "  " + Te;
            }).join(`
`).slice(2) : Y = `
` + Y.split(`
`).map(function(Te) {
              return "   " + Te;
            }).join(`
`))) : Y = V.stylize("[Circular]", "special")), H(W)) {
              if (he && ge.match(/^\d+$/))
                return Y;
              W = JSON.stringify("" + ge), W.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (W = W.slice(1, -1), W = V.stylize(W, "name")) : (W = W.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), W = V.stylize(W, "string"));
            }
            return W + ": " + Y;
          }
          function T(V, q, ee) {
            var ue = V.reduce(function(ge, he) {
              return he.indexOf(`
`) >= 0, ge + he.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return ue > 60 ? ee[0] + (q === "" ? "" : q + `
 `) + " " + V.join(`,
  `) + " " + ee[1] : ee[0] + q + " " + V.join(", ") + " " + ee[1];
          }
          n.types = r("./support/types");
          function C(V) {
            return Array.isArray(V);
          }
          n.isArray = C;
          function R(V) {
            return typeof V == "boolean";
          }
          n.isBoolean = R;
          function A(V) {
            return V === null;
          }
          n.isNull = A;
          function j(V) {
            return V == null;
          }
          n.isNullOrUndefined = j;
          function N(V) {
            return typeof V == "number";
          }
          n.isNumber = N;
          function O(V) {
            return typeof V == "string";
          }
          n.isString = O;
          function D(V) {
            return typeof V == "symbol";
          }
          n.isSymbol = D;
          function H(V) {
            return V === void 0;
          }
          n.isUndefined = H;
          function G(V) {
            return X(V) && ne(V) === "[object RegExp]";
          }
          n.isRegExp = G, n.types.isRegExp = G;
          function X(V) {
            return typeof V == "object" && V !== null;
          }
          n.isObject = X;
          function Q(V) {
            return X(V) && ne(V) === "[object Date]";
          }
          n.isDate = Q, n.types.isDate = Q;
          function M(V) {
            return X(V) && (ne(V) === "[object Error]" || V instanceof Error);
          }
          n.isError = M, n.types.isNativeError = M;
          function k(V) {
            return typeof V == "function";
          }
          n.isFunction = k;
          function $(V) {
            return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || // ES6 symbol
            typeof V > "u";
          }
          n.isPrimitive = $, n.isBuffer = r("./support/isBuffer");
          function ne(V) {
            return Object.prototype.toString.call(V);
          }
          function te(V) {
            return V < 10 ? "0" + V.toString(10) : V.toString(10);
          }
          var de = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function ae() {
            var V = /* @__PURE__ */ new Date(), q = [
              te(V.getHours()),
              te(V.getMinutes()),
              te(V.getSeconds())
            ].join(":");
            return [V.getDate(), de[V.getMonth()], q].join(" ");
          }
          n.log = function() {
            console.log("%s - %s", ae(), n.format.apply(n, arguments));
          }, n.inherits = r("inherits"), n._extend = function(V, q) {
            if (!q || !X(q))
              return V;
            for (var ee = Object.keys(q), ue = ee.length; ue--; )
              V[ee[ue]] = q[ee[ue]];
            return V;
          };
          function z(V, q) {
            return Object.prototype.hasOwnProperty.call(V, q);
          }
          var Z = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
          n.promisify = function(V) {
            if (typeof V != "function")
              throw new TypeError('The "original" argument must be of type Function');
            if (Z && V[Z]) {
              var q = V[Z];
              if (typeof q != "function")
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              return Object.defineProperty(q, Z, {
                value: q,
                enumerable: !1,
                writable: !1,
                configurable: !0
              }), q;
            }
            function q() {
              for (var ee, ue, ge = new Promise(function(Y, se) {
                ee = Y, ue = se;
              }), he = [], W = 0; W < arguments.length; W++)
                he.push(arguments[W]);
              he.push(function(Y, se) {
                Y ? ue(Y) : ee(se);
              });
              try {
                V.apply(this, he);
              } catch (Y) {
                ue(Y);
              }
              return ge;
            }
            return Object.setPrototypeOf(q, Object.getPrototypeOf(V)), Z && Object.defineProperty(q, Z, {
              value: q,
              enumerable: !1,
              writable: !1,
              configurable: !0
            }), Object.defineProperties(
              q,
              a(V)
            );
          }, n.promisify.custom = Z;
          function oe(V, q) {
            if (!V) {
              var ee = new Error("Promise was rejected with a falsy value");
              ee.reason = V, V = ee;
            }
            return q(V);
          }
          function ye(V) {
            if (typeof V != "function")
              throw new TypeError('The "original" argument must be of type Function');
            function q() {
              for (var ee = [], ue = 0; ue < arguments.length; ue++)
                ee.push(arguments[ue]);
              var ge = ee.pop();
              if (typeof ge != "function")
                throw new TypeError("The last argument must be of type Function");
              var he = this, W = function() {
                return ge.apply(he, arguments);
              };
              V.apply(this, ee).then(
                function(Y) {
                  i.nextTick(W.bind(null, null, Y));
                },
                function(Y) {
                  i.nextTick(oe.bind(null, Y, W));
                }
              );
            }
            return Object.setPrototypeOf(q, Object.getPrototypeOf(V)), Object.defineProperties(
              q,
              a(V)
            ), q;
          }
          n.callbackify = ye;
        }).call(this);
      }).call(this, r("_process"));
    }, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(r, o, n) {
      (function(i) {
        (function() {
          var a = r("for-each"), s = r("available-typed-arrays"), c = r("call-bind/callBound"), p = r("gopd"), l = c("Object.prototype.toString"), d = r("has-tostringtag/shams")(), u = typeof globalThis > "u" ? i : globalThis, h = s(), y = c("String.prototype.slice"), f = {}, b = Object.getPrototypeOf;
          d && p && b && a(h, function(E) {
            if (typeof u[E] == "function") {
              var T = new u[E]();
              if (Symbol.toStringTag in T) {
                var C = b(T), R = p(C, Symbol.toStringTag);
                if (!R) {
                  var A = b(C);
                  R = p(A, Symbol.toStringTag);
                }
                f[E] = R.get;
              }
            }
          });
          var w = function(E) {
            var T = !1;
            return a(f, function(C, R) {
              if (!T)
                try {
                  var A = C.call(E);
                  A === R && (T = A);
                } catch {
                }
            }), T;
          }, x = r("is-typed-array");
          o.exports = function(E) {
            return x(E) ? !d || !(Symbol.toStringTag in E) ? y(l(E), 8, -1) : w(E) : !1;
          };
        }).call(this);
      }).call(this, typeof Gt < "u" ? Gt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
  });
})(NR);
const LR = (e) => {
  const { data: { position: t, color: r }, bounds: o } = e, n = 4, { width: i, height: a, data: s } = t, c = r == null ? void 0 : r.data, p = [], { min: l, max: d } = o, u = d.clone().sub(l);
  for (let h = 0; h < a; h++)
    for (let y = 0; y < i; y++) {
      const f = (h * i + y) * n, b = s[f] / 256, w = s[f + 1] / 256, x = s[f + 2] / 256;
      if (s[f + 3] <= 0)
        break;
      const E = c !== void 0 ? { r: c[f], g: c[f + 1], b: c[f + 2], a: c[f + 3] } : void 0;
      p.push({
        position: new Qe(b, w, x).multiply(u).add(l),
        color: E
      });
    }
  return p;
};
var tc = { exports: {} }, Uo = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ud;
function jR() {
  if (Ud)
    return Uo;
  Ud = 1;
  var e = qt, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, c, p) {
    var l, d = {}, u = null, h = null;
    p !== void 0 && (u = "" + p), c.key !== void 0 && (u = "" + c.key), c.ref !== void 0 && (h = c.ref);
    for (l in c)
      o.call(c, l) && !i.hasOwnProperty(l) && (d[l] = c[l]);
    if (s && s.defaultProps)
      for (l in c = s.defaultProps, c)
        d[l] === void 0 && (d[l] = c[l]);
    return { $$typeof: t, type: s, key: u, ref: h, props: d, _owner: n.current };
  }
  return Uo.Fragment = r, Uo.jsx = a, Uo.jsxs = a, Uo;
}
var na = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zd;
function MR() {
  return zd || (zd = 1, process.env.NODE_ENV !== "production" && function() {
    var e = qt, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function b(pe) {
      if (pe === null || typeof pe != "object")
        return null;
      var ie = y && pe[y] || pe[f];
      return typeof ie == "function" ? ie : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function x(pe) {
      {
        for (var ie = arguments.length, Se = new Array(ie > 1 ? ie - 1 : 0), ke = 1; ke < ie; ke++)
          Se[ke - 1] = arguments[ke];
        E("error", pe, Se);
      }
    }
    function E(pe, ie, Se) {
      {
        var ke = w.ReactDebugCurrentFrame, Ve = ke.getStackAddendum();
        Ve !== "" && (ie += "%s", Se = Se.concat([Ve]));
        var Ke = Se.map(function(Be) {
          return String(Be);
        });
        Ke.unshift("Warning: " + ie), Function.prototype.apply.call(console[pe], console, Ke);
      }
    }
    var T = !1, C = !1, R = !1, A = !1, j = !1, N;
    N = Symbol.for("react.module.reference");
    function O(pe) {
      return !!(typeof pe == "string" || typeof pe == "function" || pe === o || pe === i || j || pe === n || pe === p || pe === l || A || pe === h || T || C || R || typeof pe == "object" && pe !== null && (pe.$$typeof === u || pe.$$typeof === d || pe.$$typeof === a || pe.$$typeof === s || pe.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      pe.$$typeof === N || pe.getModuleId !== void 0));
    }
    function D(pe, ie, Se) {
      var ke = pe.displayName;
      if (ke)
        return ke;
      var Ve = ie.displayName || ie.name || "";
      return Ve !== "" ? Se + "(" + Ve + ")" : Se;
    }
    function H(pe) {
      return pe.displayName || "Context";
    }
    function G(pe) {
      if (pe == null)
        return null;
      if (typeof pe.tag == "number" && x("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof pe == "function")
        return pe.displayName || pe.name || null;
      if (typeof pe == "string")
        return pe;
      switch (pe) {
        case o:
          return "Fragment";
        case r:
          return "Portal";
        case i:
          return "Profiler";
        case n:
          return "StrictMode";
        case p:
          return "Suspense";
        case l:
          return "SuspenseList";
      }
      if (typeof pe == "object")
        switch (pe.$$typeof) {
          case s:
            var ie = pe;
            return H(ie) + ".Consumer";
          case a:
            var Se = pe;
            return H(Se._context) + ".Provider";
          case c:
            return D(pe, pe.render, "ForwardRef");
          case d:
            var ke = pe.displayName || null;
            return ke !== null ? ke : G(pe.type) || "Memo";
          case u: {
            var Ve = pe, Ke = Ve._payload, Be = Ve._init;
            try {
              return G(Be(Ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var X = Object.assign, Q = 0, M, k, $, ne, te, de, ae;
    function z() {
    }
    z.__reactDisabledLog = !0;
    function Z() {
      {
        if (Q === 0) {
          M = console.log, k = console.info, $ = console.warn, ne = console.error, te = console.group, de = console.groupCollapsed, ae = console.groupEnd;
          var pe = {
            configurable: !0,
            enumerable: !0,
            value: z,
            writable: !0
          };
          Object.defineProperties(console, {
            info: pe,
            log: pe,
            warn: pe,
            error: pe,
            group: pe,
            groupCollapsed: pe,
            groupEnd: pe
          });
        }
        Q++;
      }
    }
    function oe() {
      {
        if (Q--, Q === 0) {
          var pe = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: X({}, pe, {
              value: M
            }),
            info: X({}, pe, {
              value: k
            }),
            warn: X({}, pe, {
              value: $
            }),
            error: X({}, pe, {
              value: ne
            }),
            group: X({}, pe, {
              value: te
            }),
            groupCollapsed: X({}, pe, {
              value: de
            }),
            groupEnd: X({}, pe, {
              value: ae
            })
          });
        }
        Q < 0 && x("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ye = w.ReactCurrentDispatcher, V;
    function q(pe, ie, Se) {
      {
        if (V === void 0)
          try {
            throw Error();
          } catch (Ve) {
            var ke = Ve.stack.trim().match(/\n( *(at )?)/);
            V = ke && ke[1] || "";
          }
        return `
` + V + pe;
      }
    }
    var ee = !1, ue;
    {
      var ge = typeof WeakMap == "function" ? WeakMap : Map;
      ue = new ge();
    }
    function he(pe, ie) {
      if (!pe || ee)
        return "";
      {
        var Se = ue.get(pe);
        if (Se !== void 0)
          return Se;
      }
      var ke;
      ee = !0;
      var Ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ke;
      Ke = ye.current, ye.current = null, Z();
      try {
        if (ie) {
          var Be = function() {
            throw Error();
          };
          if (Object.defineProperty(Be.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Be, []);
            } catch (Wt) {
              ke = Wt;
            }
            Reflect.construct(pe, [], Be);
          } else {
            try {
              Be.call();
            } catch (Wt) {
              ke = Wt;
            }
            pe.call(Be.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Wt) {
            ke = Wt;
          }
          pe();
        }
      } catch (Wt) {
        if (Wt && ke && typeof Wt.stack == "string") {
          for (var $e = Wt.stack.split(`
`), He = ke.stack.split(`
`), et = $e.length - 1, Xe = He.length - 1; et >= 1 && Xe >= 0 && $e[et] !== He[Xe]; )
            Xe--;
          for (; et >= 1 && Xe >= 0; et--, Xe--)
            if ($e[et] !== He[Xe]) {
              if (et !== 1 || Xe !== 1)
                do
                  if (et--, Xe--, Xe < 0 || $e[et] !== He[Xe]) {
                    var ct = `
` + $e[et].replace(" at new ", " at ");
                    return pe.displayName && ct.includes("<anonymous>") && (ct = ct.replace("<anonymous>", pe.displayName)), typeof pe == "function" && ue.set(pe, ct), ct;
                  }
                while (et >= 1 && Xe >= 0);
              break;
            }
        }
      } finally {
        ee = !1, ye.current = Ke, oe(), Error.prepareStackTrace = Ve;
      }
      var zt = pe ? pe.displayName || pe.name : "", Gr = zt ? q(zt) : "";
      return typeof pe == "function" && ue.set(pe, Gr), Gr;
    }
    function W(pe, ie, Se) {
      return he(pe, !1);
    }
    function Y(pe) {
      var ie = pe.prototype;
      return !!(ie && ie.isReactComponent);
    }
    function se(pe, ie, Se) {
      if (pe == null)
        return "";
      if (typeof pe == "function")
        return he(pe, Y(pe));
      if (typeof pe == "string")
        return q(pe);
      switch (pe) {
        case p:
          return q("Suspense");
        case l:
          return q("SuspenseList");
      }
      if (typeof pe == "object")
        switch (pe.$$typeof) {
          case c:
            return W(pe.render);
          case d:
            return se(pe.type, ie, Se);
          case u: {
            var ke = pe, Ve = ke._payload, Ke = ke._init;
            try {
              return se(Ke(Ve), ie, Se);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, Oe = {}, B = w.ReactDebugCurrentFrame;
    function U(pe) {
      if (pe) {
        var ie = pe._owner, Se = se(pe.type, pe._source, ie ? ie.type : null);
        B.setExtraStackFrame(Se);
      } else
        B.setExtraStackFrame(null);
    }
    function _(pe, ie, Se, ke, Ve) {
      {
        var Ke = Function.call.bind(Te);
        for (var Be in pe)
          if (Ke(pe, Be)) {
            var $e = void 0;
            try {
              if (typeof pe[Be] != "function") {
                var He = Error((ke || "React class") + ": " + Se + " type `" + Be + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof pe[Be] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw He.name = "Invariant Violation", He;
              }
              $e = pe[Be](ie, Be, ke, Se, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (et) {
              $e = et;
            }
            $e && !($e instanceof Error) && (U(Ve), x("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ke || "React class", Se, Be, typeof $e), U(null)), $e instanceof Error && !($e.message in Oe) && (Oe[$e.message] = !0, U(Ve), x("Failed %s type: %s", Se, $e.message), U(null));
          }
      }
    }
    var v = Array.isArray;
    function S(pe) {
      return v(pe);
    }
    function P(pe) {
      {
        var ie = typeof Symbol == "function" && Symbol.toStringTag, Se = ie && pe[Symbol.toStringTag] || pe.constructor.name || "Object";
        return Se;
      }
    }
    function J(pe) {
      try {
        return ve(pe), !1;
      } catch {
        return !0;
      }
    }
    function ve(pe) {
      return "" + pe;
    }
    function Re(pe) {
      if (J(pe))
        return x("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", P(pe)), ve(pe);
    }
    var je = w.ReactCurrentOwner, qe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, We, Fe;
    Fe = {};
    function rt(pe) {
      if (Te.call(pe, "ref")) {
        var ie = Object.getOwnPropertyDescriptor(pe, "ref").get;
        if (ie && ie.isReactWarning)
          return !1;
      }
      return pe.ref !== void 0;
    }
    function Ge(pe) {
      if (Te.call(pe, "key")) {
        var ie = Object.getOwnPropertyDescriptor(pe, "key").get;
        if (ie && ie.isReactWarning)
          return !1;
      }
      return pe.key !== void 0;
    }
    function Je(pe, ie) {
      if (typeof pe.ref == "string" && je.current && ie && je.current.stateNode !== ie) {
        var Se = G(je.current.type);
        Fe[Se] || (x('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(je.current.type), pe.ref), Fe[Se] = !0);
      }
    }
    function Ze(pe, ie) {
      {
        var Se = function() {
          ze || (ze = !0, x("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
        };
        Se.isReactWarning = !0, Object.defineProperty(pe, "key", {
          get: Se,
          configurable: !0
        });
      }
    }
    function F(pe, ie) {
      {
        var Se = function() {
          We || (We = !0, x("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
        };
        Se.isReactWarning = !0, Object.defineProperty(pe, "ref", {
          get: Se,
          configurable: !0
        });
      }
    }
    var we = function(pe, ie, Se, ke, Ve, Ke, Be) {
      var $e = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: pe,
        key: ie,
        ref: Se,
        props: Be,
        // Record the component responsible for creating this element.
        _owner: Ke
      };
      return $e._store = {}, Object.defineProperty($e._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty($e, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ke
      }), Object.defineProperty($e, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ve
      }), Object.freeze && (Object.freeze($e.props), Object.freeze($e)), $e;
    };
    function xe(pe, ie, Se, ke, Ve) {
      {
        var Ke, Be = {}, $e = null, He = null;
        Se !== void 0 && (Re(Se), $e = "" + Se), Ge(ie) && (Re(ie.key), $e = "" + ie.key), rt(ie) && (He = ie.ref, Je(ie, Ve));
        for (Ke in ie)
          Te.call(ie, Ke) && !qe.hasOwnProperty(Ke) && (Be[Ke] = ie[Ke]);
        if (pe && pe.defaultProps) {
          var et = pe.defaultProps;
          for (Ke in et)
            Be[Ke] === void 0 && (Be[Ke] = et[Ke]);
        }
        if ($e || He) {
          var Xe = typeof pe == "function" ? pe.displayName || pe.name || "Unknown" : pe;
          $e && Ze(Be, Xe), He && F(Be, Xe);
        }
        return we(pe, $e, He, Ve, ke, je.current, Be);
      }
    }
    var Ce = w.ReactCurrentOwner, re = w.ReactDebugCurrentFrame;
    function me(pe) {
      if (pe) {
        var ie = pe._owner, Se = se(pe.type, pe._source, ie ? ie.type : null);
        re.setExtraStackFrame(Se);
      } else
        re.setExtraStackFrame(null);
    }
    var I;
    I = !1;
    function Ee(pe) {
      return typeof pe == "object" && pe !== null && pe.$$typeof === t;
    }
    function De() {
      {
        if (Ce.current) {
          var pe = G(Ce.current.type);
          if (pe)
            return `

Check the render method of \`` + pe + "`.";
        }
        return "";
      }
    }
    function g(pe) {
      return "";
    }
    var fe = {};
    function le(pe) {
      {
        var ie = De();
        if (!ie) {
          var Se = typeof pe == "string" ? pe : pe.displayName || pe.name;
          Se && (ie = `

Check the top-level render call using <` + Se + ">.");
        }
        return ie;
      }
    }
    function L(pe, ie) {
      {
        if (!pe._store || pe._store.validated || pe.key != null)
          return;
        pe._store.validated = !0;
        var Se = le(ie);
        if (fe[Se])
          return;
        fe[Se] = !0;
        var ke = "";
        pe && pe._owner && pe._owner !== Ce.current && (ke = " It was passed a child from " + G(pe._owner.type) + "."), me(pe), x('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Se, ke), me(null);
      }
    }
    function K(pe, ie) {
      {
        if (typeof pe != "object")
          return;
        if (S(pe))
          for (var Se = 0; Se < pe.length; Se++) {
            var ke = pe[Se];
            Ee(ke) && L(ke, ie);
          }
        else if (Ee(pe))
          pe._store && (pe._store.validated = !0);
        else if (pe) {
          var Ve = b(pe);
          if (typeof Ve == "function" && Ve !== pe.entries)
            for (var Ke = Ve.call(pe), Be; !(Be = Ke.next()).done; )
              Ee(Be.value) && L(Be.value, ie);
        }
      }
    }
    function ce(pe) {
      {
        var ie = pe.type;
        if (ie == null || typeof ie == "string")
          return;
        var Se;
        if (typeof ie == "function")
          Se = ie.propTypes;
        else if (typeof ie == "object" && (ie.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ie.$$typeof === d))
          Se = ie.propTypes;
        else
          return;
        if (Se) {
          var ke = G(ie);
          _(Se, pe.props, "prop", ke, pe);
        } else if (ie.PropTypes !== void 0 && !I) {
          I = !0;
          var Ve = G(ie);
          x("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ve || "Unknown");
        }
        typeof ie.getDefaultProps == "function" && !ie.getDefaultProps.isReactClassApproved && x("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Le(pe) {
      {
        for (var ie = Object.keys(pe.props), Se = 0; Se < ie.length; Se++) {
          var ke = ie[Se];
          if (ke !== "children" && ke !== "key") {
            me(pe), x("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ke), me(null);
            break;
          }
        }
        pe.ref !== null && (me(pe), x("Invalid attribute `ref` supplied to `React.Fragment`."), me(null));
      }
    }
    function Ae(pe, ie, Se, ke, Ve, Ke) {
      {
        var Be = O(pe);
        if (!Be) {
          var $e = "";
          (pe === void 0 || typeof pe == "object" && pe !== null && Object.keys(pe).length === 0) && ($e += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var He = g();
          He ? $e += He : $e += De();
          var et;
          pe === null ? et = "null" : S(pe) ? et = "array" : pe !== void 0 && pe.$$typeof === t ? (et = "<" + (G(pe.type) || "Unknown") + " />", $e = " Did you accidentally export a JSX literal instead of a component?") : et = typeof pe, x("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", et, $e);
        }
        var Xe = xe(pe, ie, Se, Ve, Ke);
        if (Xe == null)
          return Xe;
        if (Be) {
          var ct = ie.children;
          if (ct !== void 0)
            if (ke)
              if (S(ct)) {
                for (var zt = 0; zt < ct.length; zt++)
                  K(ct[zt], pe);
                Object.freeze && Object.freeze(ct);
              } else
                x("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              K(ct, pe);
        }
        return pe === o ? Le(Xe) : ce(Xe), Xe;
      }
    }
    function Ie(pe, ie, Se) {
      return Ae(pe, ie, Se, !0);
    }
    function Ye(pe, ie, Se) {
      return Ae(pe, ie, Se, !1);
    }
    var It = Ye, nt = Ie;
    na.Fragment = o, na.jsx = It, na.jsxs = nt;
  }()), na;
}
process.env.NODE_ENV === "production" ? tc.exports = jR() : tc.exports = MR();
var jr = tc.exports;
const oa = {
  Default: 0,
  Loading: 1,
  Loaded: 2
};
function am(e) {
  const {
    meta: t,
    loader: r,
    parser: o,
    pointColorHandler: n,
    lod: i,
    coordinate: a,
    bounds: s,
    onUpdateState: c,
    color: p,
    opacity: l,
    pointSize: d,
    minPointSize: u,
    lodPointScale: h,
    circle: y,
    lodHelper: f,
    frustumCulled: b
  } = e, w = xr(null), [x, E] = Rt(!1), [T, C] = Rt(oa.Default), [R, A] = Rt({}), j = kt(() => `${a.x}-${a.y}-${a.z}`, [a]), N = kt(() => {
    const de = t.coordinates[i][j], { min: ae, max: z } = de, Z = new Qe(ae[0], ae[1], ae[2]), oe = new Qe(z[0], z[1], z[2]), ye = oe.clone().sub(Z);
    return {
      min: Z,
      max: oe,
      size: ye
    };
  }, [t, i, j]);
  Xt(() => {
    c == null || c({
      coordinate: a,
      state: T
    });
  }, [a, T, c]);
  const O = kt(() => s.getSize(new Qe()), [s]), D = ft(
    (de, ae, z) => {
      const Z = a.clone().multiplyScalar(2).clone().add(new Qe(de, ae, z)), oe = `${Z.x}-${Z.y}-${Z.z}`;
      return {
        position: Z,
        key: oe
      };
    },
    [a]
  ), H = ft(() => {
    const { min: de } = s, ae = new Qe();
    s.getSize(ae);
    const { x: z, y: Z, z: oe } = ae, ye = z * 0.5, V = Z * 0.5, q = oe * 0.5, ee = new Qe(ye, V, q), ue = {};
    for (let ge = 0; ge <= 1; ge += 1)
      for (let he = 0; he <= 1; he += 1)
        for (let W = 0; W <= 1; W += 1) {
          const Y = de.clone().add(ee.clone().multiply(new Qe(W, he, ge))), se = de.clone().add(ee.clone().multiply(new Qe(W + 1, he + 1, ge + 1))), { key: Te } = D(W, he, ge);
          ue[Te] = new An(Y, se);
        }
    return ue;
  }, [s, i, D]), G = kt(() => {
    const de = H(), ae = i + 1, z = [];
    for (let Z = 0; Z <= 1; Z += 1)
      for (let oe = 0; oe <= 1; oe += 1)
        for (let ye = 0; ye <= 1; ye += 1) {
          const { position: V, key: q } = D(ye, oe, Z), ee = de[q], ue = ae in t.coordinates && q in t.coordinates[ae];
          z.push({
            lod: ae,
            coordinate: V,
            bounds: ee,
            exists: ue
          });
        }
    return z;
  }, [t, s, i, H, D]), [X, Q] = Rt([]), M = ft(
    (de) => {
      const { points: ae, grid: z } = de, Z = z.map((ye) => ({
        points: [],
        bounds: ye.bounds
      }));
      ae.forEach((ye) => {
        var V;
        (V = Z.find((q) => q.bounds.containsPoint(ye.position))) == null || V.points.push(ye);
      });
      const oe = Z.map((ye) => {
        const { points: V } = ye, q = 1 / 256;
        return {
          position: new Float32Array(
            V.map((ee) => ee.position.toArray()).flat()
          ),
          color: n === void 0 ? new Float32Array(
            V.map((ee) => {
              var ue, ge, he;
              return [
                (((ue = ee.color) == null ? void 0 : ue.r) ?? 255) * q,
                (((ge = ee.color) == null ? void 0 : ge.g) ?? 255) * q,
                (((he = ee.color) == null ? void 0 : he.b) ?? 255) * q
              ];
            }).flat()
          ) : new Float32Array(V.map((ee) => n({
            point: ee,
            lod: i,
            bounds: s
          })).flat())
        };
      });
      Q(oe);
    },
    [n, s, i]
  );
  Xt(() => {
    if (G.length > 0) {
      C(oa.Loading);
      const de = {
        lod: i,
        coordinate: a
      };
      r({ address: de, color: !0 }).then((ae) => {
        const z = o({
          data: ae,
          address: de,
          bounds: N
        });
        M({
          points: z,
          grid: G
        }), C(oa.Loaded);
      });
    }
  }, [t, N, r, i, a, o, M, G]), ac(({ camera: de }) => {
    if (i >= t.lod)
      return;
    const { current: ae } = w;
    if (ae === null)
      return;
    const { min: z, max: Z } = s, oe = [
      new Qe(z.x, z.y, z.z),
      new Qe(Z.x, z.y, z.z),
      new Qe(Z.x, z.y, Z.z),
      new Qe(z.x, z.y, Z.z),
      new Qe(z.x, Z.y, z.z),
      new Qe(Z.x, Z.y, z.z),
      new Qe(Z.x, Z.y, Z.z),
      new Qe(z.x, Z.y, Z.z)
    ].map((ee) => ae.localToWorld(ee.clone())), ye = new An().setFromPoints(oe), V = Math.max(...O.toArray()) / 2, q = ye.distanceToPoint(de.position) < V || ye.containsPoint(de.position);
    E(q);
  });
  const k = ft(
    (de) => {
      const { coordinate: ae, state: z } = de;
      A((Z) => ({
        ...Z,
        [`${ae.x}-${ae.y}-${ae.z}`]: z
      }));
    },
    []
  ), $ = kt(() => {
    const de = d ?? 5;
    if (h !== !1) {
      const ae = 2 ** (G.filter((z) => z.exists).length > 0 ? i : i - 1);
      return de / ae;
    }
    return de;
  }, [t, d, h, i, G]), ne = kt(() => p ?? new up("white"), [p]), te = ft((de) => {
    const { vertexShader: ae, fragmentShader: z } = de;
    {
      const Z = ae.split(`
`);
      Z.pop();
      const oe = u ?? 0;
      Z.push(`gl_PointSize = max(gl_PointSize, ${oe.toFixed(2)});`), Z.push("}"), de.vertexShader = Z.join(`
`);
    }
    {
      const Z = z.split(`
`);
      Z.pop(), Z.push("if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) { discard; }"), Z.push("}"), de.fragmentShader = Z.join(`
`);
    }
  }, [u]);
  return /* @__PURE__ */ jr.jsxs("group", { ref: w, children: [
    f === !0 && /* @__PURE__ */ jr.jsx("box3Helper", { args: [s, 16711680] }),
    G.map((de, ae) => {
      const z = de.coordinate.toArray().join("-"), { exists: Z } = de;
      return /* @__PURE__ */ jr.jsxs("group", { frustumCulled: !1, children: [
        x && Z ? /* @__PURE__ */ jr.jsx(
          am,
          {
            meta: t,
            loader: r,
            parser: o,
            pointColorHandler: n,
            onUpdateState: k,
            color: p,
            opacity: l,
            pointSize: d,
            minPointSize: u,
            circle: y,
            lodHelper: f,
            frustumCulled: b,
            ...de
          }
        ) : null,
        X[ae] !== void 0 ? /* @__PURE__ */ jr.jsx(
          Hm,
          {
            visible: !Z || !x || R[z] !== oa.Loaded,
            positions: X[ae].position,
            colors: X[ae].color,
            frustumCulled: b,
            children: /* @__PURE__ */ jr.jsx(
              "pointsMaterial",
              {
                color: ne,
                vertexColors: p === void 0,
                sizeAttenuation: !0,
                size: $,
                opacity: l ?? 1,
                transparent: l !== void 0 && l < 1,
                onBeforeCompile: te
              }
            )
          }
        ) : null
      ] }, `${i}-${z}`);
    })
  ] });
}
function FR(e) {
  const { meta: t, loader: r, parser: o, pointColorHandler: n, ...i } = e, a = kt(() => {
    if (t !== null) {
      const { min: p, max: l } = t.bounds, d = new An(new Qe().fromArray(p), new Qe().fromArray(l)), u = new Qe();
      d.getSize(u);
      const h = Math.max(u.x, u.y, u.z), y = new Qe(h, h, h);
      return new An(d.min.clone(), d.min.clone().add(y));
    }
    return new An();
  }, [t]), s = kt(() => {
    const p = a.getSize(new Qe());
    return [p.x, p.y, p.z, 1, 1, 1];
  }, [a]), c = kt(() => new Qe(), []);
  return /* @__PURE__ */ jr.jsxs("group", { children: [
    /* @__PURE__ */ jr.jsx(zm, { position: a.getCenter(new Qe()), args: s, visible: !1, children: /* @__PURE__ */ jr.jsx("meshStandardMaterial", { color: "tomato", transparent: !0, opacity: 0.2 }) }),
    /* @__PURE__ */ jr.jsx(
      am,
      {
        meta: t,
        loader: r,
        parser: o,
        pointColorHandler: n,
        lod: 0,
        coordinate: c,
        bounds: a,
        ...i
      }
    )
  ] });
}
function ia(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var vl = { exports: {} }, Hd;
function DR() {
  return Hd || (Hd = 1, function(e, t) {
    (function(r) {
      e.exports = r();
    })(function() {
      return (/* @__PURE__ */ function() {
        function r(o, n, i) {
          function a(p, l) {
            if (!n[p]) {
              if (!o[p]) {
                var d = typeof ia == "function" && ia;
                if (!l && d) return d(p, !0);
                if (s) return s(p, !0);
                var u = new Error("Cannot find module '" + p + "'");
                throw u.code = "MODULE_NOT_FOUND", u;
              }
              var h = n[p] = { exports: {} };
              o[p][0].call(h.exports, function(y) {
                var f = o[p][1][y];
                return a(f || y);
              }, h, h.exports, r, o, n, i);
            }
            return n[p].exports;
          }
          for (var s = typeof ia == "function" && ia, c = 0; c < i.length; c++) a(i[c]);
          return a;
        }
        return r;
      }())({ 1: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./interlace"), s = [
              // 0 - dummy entry
              function() {
              },
              // 1 - L
              // 0: 0, 1: 0, 2: 0, 3: 0xff
              function(u, h, y, f) {
                if (f === h.length)
                  throw new Error("Ran out of data");
                let b = h[f];
                u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = 255;
              },
              // 2 - LA
              // 0: 0, 1: 0, 2: 0, 3: 1
              function(u, h, y, f) {
                if (f + 1 >= h.length)
                  throw new Error("Ran out of data");
                let b = h[f];
                u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = h[f + 1];
              },
              // 3 - RGB
              // 0: 0, 1: 1, 2: 2, 3: 0xff
              function(u, h, y, f) {
                if (f + 2 >= h.length)
                  throw new Error("Ran out of data");
                u[y] = h[f], u[y + 1] = h[f + 1], u[y + 2] = h[f + 2], u[y + 3] = 255;
              },
              // 4 - RGBA
              // 0: 0, 1: 1, 2: 2, 3: 3
              function(u, h, y, f) {
                if (f + 3 >= h.length)
                  throw new Error("Ran out of data");
                u[y] = h[f], u[y + 1] = h[f + 1], u[y + 2] = h[f + 2], u[y + 3] = h[f + 3];
              }
            ], c = [
              // 0 - dummy entry
              function() {
              },
              // 1 - L
              // 0: 0, 1: 0, 2: 0, 3: 0xff
              function(u, h, y, f) {
                let b = h[0];
                u[y] = b, u[y + 1] = b, u[y + 2] = b, u[y + 3] = f;
              },
              // 2 - LA
              // 0: 0, 1: 0, 2: 0, 3: 1
              function(u, h, y) {
                let f = h[0];
                u[y] = f, u[y + 1] = f, u[y + 2] = f, u[y + 3] = h[1];
              },
              // 3 - RGB
              // 0: 0, 1: 1, 2: 2, 3: 0xff
              function(u, h, y, f) {
                u[y] = h[0], u[y + 1] = h[1], u[y + 2] = h[2], u[y + 3] = f;
              },
              // 4 - RGBA
              // 0: 0, 1: 1, 2: 2, 3: 3
              function(u, h, y) {
                u[y] = h[0], u[y + 1] = h[1], u[y + 2] = h[2], u[y + 3] = h[3];
              }
            ];
            function p(u, h) {
              let y = [], f = 0;
              function b() {
                if (f === u.length)
                  throw new Error("Ran out of data");
                let w = u[f];
                f++;
                let x, E, T, C, R, A, j, N;
                switch (h) {
                  default:
                    throw new Error("unrecognised depth");
                  case 16:
                    j = u[f], f++, y.push((w << 8) + j);
                    break;
                  case 4:
                    j = w & 15, N = w >> 4, y.push(N, j);
                    break;
                  case 2:
                    R = w & 3, A = w >> 2 & 3, j = w >> 4 & 3, N = w >> 6 & 3, y.push(N, j, A, R);
                    break;
                  case 1:
                    x = w & 1, E = w >> 1 & 1, T = w >> 2 & 1, C = w >> 3 & 1, R = w >> 4 & 1, A = w >> 5 & 1, j = w >> 6 & 1, N = w >> 7 & 1, y.push(N, j, A, R, C, T, E, x);
                    break;
                }
              }
              return {
                get: function(w) {
                  for (; y.length < w; )
                    b();
                  let x = y.slice(0, w);
                  return y = y.slice(w), x;
                },
                resetAfterLine: function() {
                  y.length = 0;
                },
                end: function() {
                  if (f !== u.length)
                    throw new Error("extra data found");
                }
              };
            }
            function l(u, h, y, f, b, w) {
              let x = u.width, E = u.height, T = u.index;
              for (let C = 0; C < E; C++)
                for (let R = 0; R < x; R++) {
                  let A = y(R, C, T);
                  s[f](h, b, A, w), w += f;
                }
              return w;
            }
            function d(u, h, y, f, b, w) {
              let x = u.width, E = u.height, T = u.index;
              for (let C = 0; C < E; C++) {
                for (let R = 0; R < x; R++) {
                  let A = b.get(f), j = y(R, C, T);
                  c[f](h, A, j, w);
                }
                b.resetAfterLine();
              }
            }
            n.dataToBitMap = function(u, h) {
              let y = h.width, f = h.height, b = h.depth, w = h.bpp, x = h.interlace, E;
              b !== 8 && (E = p(u, b));
              let T;
              b <= 8 ? T = i.alloc(y * f * 4) : T = new Uint16Array(y * f * 4);
              let C = Math.pow(2, b) - 1, R = 0, A, j;
              if (x)
                A = a.getImagePasses(y, f), j = a.getInterlaceIterator(y, f);
              else {
                let N = 0;
                j = function() {
                  let O = N;
                  return N += 4, O;
                }, A = [{ width: y, height: f }];
              }
              for (let N = 0; N < A.length; N++)
                b === 8 ? R = l(
                  A[N],
                  T,
                  j,
                  w,
                  u,
                  R
                ) : d(
                  A[N],
                  T,
                  j,
                  w,
                  E,
                  C
                );
              if (b === 8) {
                if (R !== u.length)
                  throw new Error("extra data found");
              } else
                E.end();
              return T;
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./interlace": 11, buffer: 32 }], 2: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./constants");
            o.exports = function(s, c, p, l) {
              let d = [a.COLORTYPE_COLOR_ALPHA, a.COLORTYPE_ALPHA].indexOf(
                l.colorType
              ) !== -1;
              if (l.colorType === l.inputColorType) {
                let C = function() {
                  let R = new ArrayBuffer(2);
                  return new DataView(R).setInt16(
                    0,
                    256,
                    !0
                    /* littleEndian */
                  ), new Int16Array(R)[0] !== 256;
                }();
                if (l.bitDepth === 8 || l.bitDepth === 16 && C)
                  return s;
              }
              let u = l.bitDepth !== 16 ? s : new Uint16Array(s.buffer), h = 255, y = a.COLORTYPE_TO_BPP_MAP[l.inputColorType];
              y === 4 && !l.inputHasAlpha && (y = 3);
              let f = a.COLORTYPE_TO_BPP_MAP[l.colorType];
              l.bitDepth === 16 && (h = 65535, f *= 2);
              let b = i.alloc(c * p * f), w = 0, x = 0, E = l.bgColor || {};
              E.red === void 0 && (E.red = h), E.green === void 0 && (E.green = h), E.blue === void 0 && (E.blue = h);
              function T() {
                let C, R, A, j = h;
                switch (l.inputColorType) {
                  case a.COLORTYPE_COLOR_ALPHA:
                    j = u[w + 3], C = u[w], R = u[w + 1], A = u[w + 2];
                    break;
                  case a.COLORTYPE_COLOR:
                    C = u[w], R = u[w + 1], A = u[w + 2];
                    break;
                  case a.COLORTYPE_ALPHA:
                    j = u[w + 1], C = u[w], R = C, A = C;
                    break;
                  case a.COLORTYPE_GRAYSCALE:
                    C = u[w], R = C, A = C;
                    break;
                  default:
                    throw new Error(
                      "input color type:" + l.inputColorType + " is not supported at present"
                    );
                }
                return l.inputHasAlpha && (d || (j /= h, C = Math.min(
                  Math.max(Math.round((1 - j) * E.red + j * C), 0),
                  h
                ), R = Math.min(
                  Math.max(Math.round((1 - j) * E.green + j * R), 0),
                  h
                ), A = Math.min(
                  Math.max(Math.round((1 - j) * E.blue + j * A), 0),
                  h
                ))), { red: C, green: R, blue: A, alpha: j };
              }
              for (let C = 0; C < p; C++)
                for (let R = 0; R < c; R++) {
                  let A = T();
                  switch (l.colorType) {
                    case a.COLORTYPE_COLOR_ALPHA:
                    case a.COLORTYPE_COLOR:
                      l.bitDepth === 8 ? (b[x] = A.red, b[x + 1] = A.green, b[x + 2] = A.blue, d && (b[x + 3] = A.alpha)) : (b.writeUInt16BE(A.red, x), b.writeUInt16BE(A.green, x + 2), b.writeUInt16BE(A.blue, x + 4), d && b.writeUInt16BE(A.alpha, x + 6));
                      break;
                    case a.COLORTYPE_ALPHA:
                    case a.COLORTYPE_GRAYSCALE: {
                      let j = (A.red + A.green + A.blue) / 3;
                      l.bitDepth === 8 ? (b[x] = j, d && (b[x + 1] = A.alpha)) : (b.writeUInt16BE(j, x), d && b.writeUInt16BE(A.alpha, x + 2));
                      break;
                    }
                    default:
                      throw new Error("unrecognised color Type " + l.colorType);
                  }
                  w += y, x += f;
                }
              return b;
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./constants": 4, buffer: 32 }], 3: [function(r, o, n) {
        (function(i, a) {
          (function() {
            let s = r("util"), c = r("stream"), p = o.exports = function() {
              c.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
            };
            s.inherits(p, c), p.prototype.read = function(l, d) {
              this._reads.push({
                length: Math.abs(l),
                // if length < 0 then at most this length
                allowLess: l < 0,
                func: d
              }), i.nextTick(
                (function() {
                  this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
                }).bind(this)
              );
            }, p.prototype.write = function(l, d) {
              if (!this.writable)
                return this.emit("error", new Error("Stream not writable")), !1;
              let u;
              return a.isBuffer(l) ? u = l : u = a.from(l, d || this._encoding), this._buffers.push(u), this._buffered += u.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
            }, p.prototype.end = function(l, d) {
              l && this.write(l, d), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
            }, p.prototype.destroySoon = p.prototype.end, p.prototype._end = function() {
              this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
            }, p.prototype.destroy = function() {
              this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
            }, p.prototype._processReadAllowingLess = function(l) {
              this._reads.shift();
              let d = this._buffers[0];
              d.length > l.length ? (this._buffered -= l.length, this._buffers[0] = d.slice(l.length), l.func.call(this, d.slice(0, l.length))) : (this._buffered -= d.length, this._buffers.shift(), l.func.call(this, d));
            }, p.prototype._processRead = function(l) {
              this._reads.shift();
              let d = 0, u = 0, h = a.alloc(l.length);
              for (; d < l.length; ) {
                let y = this._buffers[u++], f = Math.min(y.length, l.length - d);
                y.copy(h, d, 0, f), d += f, f !== y.length && (this._buffers[--u] = y.slice(f));
              }
              u > 0 && this._buffers.splice(0, u), this._buffered -= l.length, l.func.call(this, h);
            }, p.prototype._process = function() {
              try {
                for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                  let l = this._reads[0];
                  if (l.allowLess)
                    this._processReadAllowingLess(l);
                  else if (this._buffered >= l.length)
                    this._processRead(l);
                  else
                    break;
                }
                this._buffers && !this.writable && this._end();
              } catch (l) {
                this.emit("error", l);
              }
            };
          }).call(this);
        }).call(this, r("_process"), r("buffer").Buffer);
      }, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(r, o, n) {
        o.exports = {
          PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
          TYPE_IHDR: 1229472850,
          TYPE_IEND: 1229278788,
          TYPE_IDAT: 1229209940,
          TYPE_PLTE: 1347179589,
          TYPE_tRNS: 1951551059,
          // eslint-disable-line camelcase
          TYPE_gAMA: 1732332865,
          // eslint-disable-line camelcase
          // color-type bits
          COLORTYPE_GRAYSCALE: 0,
          COLORTYPE_PALETTE: 1,
          COLORTYPE_COLOR: 2,
          COLORTYPE_ALPHA: 4,
          // e.g. grayscale and alpha
          // color-type combinations
          COLORTYPE_PALETTE_COLOR: 3,
          COLORTYPE_COLOR_ALPHA: 6,
          COLORTYPE_TO_BPP_MAP: {
            0: 1,
            2: 3,
            3: 1,
            4: 2,
            6: 4
          },
          GAMMA_DIVISION: 1e5
        };
      }, {}], 5: [function(r, o, n) {
        let i = [];
        (function() {
          for (let s = 0; s < 256; s++) {
            let c = s;
            for (let p = 0; p < 8; p++)
              c & 1 ? c = 3988292384 ^ c >>> 1 : c = c >>> 1;
            i[s] = c;
          }
        })();
        let a = o.exports = function() {
          this._crc = -1;
        };
        a.prototype.write = function(s) {
          for (let c = 0; c < s.length; c++)
            this._crc = i[(this._crc ^ s[c]) & 255] ^ this._crc >>> 8;
          return !0;
        }, a.prototype.crc32 = function() {
          return this._crc ^ -1;
        }, a.crc32 = function(s) {
          let c = -1;
          for (let p = 0; p < s.length; p++)
            c = i[(c ^ s[p]) & 255] ^ c >>> 8;
          return c ^ -1;
        };
      }, {}], 6: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./paeth-predictor");
            function s(E, T, C, R, A) {
              for (let j = 0; j < C; j++)
                R[A + j] = E[T + j];
            }
            function c(E, T, C) {
              let R = 0, A = T + C;
              for (let j = T; j < A; j++)
                R += Math.abs(E[j]);
              return R;
            }
            function p(E, T, C, R, A, j) {
              for (let N = 0; N < C; N++) {
                let O = N >= j ? E[T + N - j] : 0, D = E[T + N] - O;
                R[A + N] = D;
              }
            }
            function l(E, T, C, R) {
              let A = 0;
              for (let j = 0; j < C; j++) {
                let N = j >= R ? E[T + j - R] : 0, O = E[T + j] - N;
                A += Math.abs(O);
              }
              return A;
            }
            function d(E, T, C, R, A) {
              for (let j = 0; j < C; j++) {
                let N = T > 0 ? E[T + j - C] : 0, O = E[T + j] - N;
                R[A + j] = O;
              }
            }
            function u(E, T, C) {
              let R = 0, A = T + C;
              for (let j = T; j < A; j++) {
                let N = T > 0 ? E[j - C] : 0, O = E[j] - N;
                R += Math.abs(O);
              }
              return R;
            }
            function h(E, T, C, R, A, j) {
              for (let N = 0; N < C; N++) {
                let O = N >= j ? E[T + N - j] : 0, D = T > 0 ? E[T + N - C] : 0, H = E[T + N] - (O + D >> 1);
                R[A + N] = H;
              }
            }
            function y(E, T, C, R) {
              let A = 0;
              for (let j = 0; j < C; j++) {
                let N = j >= R ? E[T + j - R] : 0, O = T > 0 ? E[T + j - C] : 0, D = E[T + j] - (N + O >> 1);
                A += Math.abs(D);
              }
              return A;
            }
            function f(E, T, C, R, A, j) {
              for (let N = 0; N < C; N++) {
                let O = N >= j ? E[T + N - j] : 0, D = T > 0 ? E[T + N - C] : 0, H = T > 0 && N >= j ? E[T + N - (C + j)] : 0, G = E[T + N] - a(O, D, H);
                R[A + N] = G;
              }
            }
            function b(E, T, C, R) {
              let A = 0;
              for (let j = 0; j < C; j++) {
                let N = j >= R ? E[T + j - R] : 0, O = T > 0 ? E[T + j - C] : 0, D = T > 0 && j >= R ? E[T + j - (C + R)] : 0, H = E[T + j] - a(N, O, D);
                A += Math.abs(H);
              }
              return A;
            }
            let w = {
              0: s,
              1: p,
              2: d,
              3: h,
              4: f
            }, x = {
              0: c,
              1: l,
              2: u,
              3: y,
              4: b
            };
            o.exports = function(E, T, C, R, A) {
              let j;
              if (!("filterType" in R) || R.filterType === -1)
                j = [0, 1, 2, 3, 4];
              else if (typeof R.filterType == "number")
                j = [R.filterType];
              else
                throw new Error("unrecognised filter types");
              R.bitDepth === 16 && (A *= 2);
              let N = T * A, O = 0, D = 0, H = i.alloc((N + 1) * C), G = j[0];
              for (let X = 0; X < C; X++) {
                if (j.length > 1) {
                  let Q = 1 / 0;
                  for (let M = 0; M < j.length; M++) {
                    let k = x[j[M]](E, D, N, A);
                    k < Q && (G = j[M], Q = k);
                  }
                }
                H[O] = G, O++, w[G](E, D, N, H, O, A), O += N, D += N;
              }
              return H;
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("util"), s = r("./chunkstream"), c = r("./filter-parse"), p = o.exports = function(l) {
              s.call(this);
              let d = [], u = this;
              this._filter = new c(l, {
                read: this.read.bind(this),
                write: function(h) {
                  d.push(h);
                },
                complete: function() {
                  u.emit("complete", i.concat(d));
                }
              }), this._filter.start();
            };
            a.inherits(p, s);
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./sync-reader"), s = r("./filter-parse");
            n.process = function(c, p) {
              let l = [], d = new a(c);
              return new s(p, {
                read: d.read.bind(d),
                write: function(h) {
                  l.push(h);
                },
                complete: function() {
                }
              }).start(), d.process(), i.concat(l);
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./interlace"), s = r("./paeth-predictor");
            function c(l, d, u) {
              let h = l * d;
              return u !== 8 && (h = Math.ceil(h / (8 / u))), h;
            }
            let p = o.exports = function(l, d) {
              let u = l.width, h = l.height, y = l.interlace, f = l.bpp, b = l.depth;
              if (this.read = d.read, this.write = d.write, this.complete = d.complete, this._imageIndex = 0, this._images = [], y) {
                let w = a.getImagePasses(u, h);
                for (let x = 0; x < w.length; x++)
                  this._images.push({
                    byteWidth: c(w[x].width, f, b),
                    height: w[x].height,
                    lineIndex: 0
                  });
              } else
                this._images.push({
                  byteWidth: c(u, f, b),
                  height: h,
                  lineIndex: 0
                });
              b === 8 ? this._xComparison = f : b === 16 ? this._xComparison = f * 2 : this._xComparison = 1;
            };
            p.prototype.start = function() {
              this.read(
                this._images[this._imageIndex].byteWidth + 1,
                this._reverseFilterLine.bind(this)
              );
            }, p.prototype._unFilterType1 = function(l, d, u) {
              let h = this._xComparison, y = h - 1;
              for (let f = 0; f < u; f++) {
                let b = l[1 + f], w = f > y ? d[f - h] : 0;
                d[f] = b + w;
              }
            }, p.prototype._unFilterType2 = function(l, d, u) {
              let h = this._lastLine;
              for (let y = 0; y < u; y++) {
                let f = l[1 + y], b = h ? h[y] : 0;
                d[y] = f + b;
              }
            }, p.prototype._unFilterType3 = function(l, d, u) {
              let h = this._xComparison, y = h - 1, f = this._lastLine;
              for (let b = 0; b < u; b++) {
                let w = l[1 + b], x = f ? f[b] : 0, E = b > y ? d[b - h] : 0, T = Math.floor((E + x) / 2);
                d[b] = w + T;
              }
            }, p.prototype._unFilterType4 = function(l, d, u) {
              let h = this._xComparison, y = h - 1, f = this._lastLine;
              for (let b = 0; b < u; b++) {
                let w = l[1 + b], x = f ? f[b] : 0, E = b > y ? d[b - h] : 0, T = b > y && f ? f[b - h] : 0, C = s(E, x, T);
                d[b] = w + C;
              }
            }, p.prototype._reverseFilterLine = function(l) {
              let d = l[0], u, h = this._images[this._imageIndex], y = h.byteWidth;
              if (d === 0)
                u = l.slice(1, y + 1);
              else
                switch (u = i.alloc(y), d) {
                  case 1:
                    this._unFilterType1(l, u, y);
                    break;
                  case 2:
                    this._unFilterType2(l, u, y);
                    break;
                  case 3:
                    this._unFilterType3(l, u, y);
                    break;
                  case 4:
                    this._unFilterType4(l, u, y);
                    break;
                  default:
                    throw new Error("Unrecognised filter type - " + d);
                }
              this.write(u), h.lineIndex++, h.lineIndex >= h.height ? (this._lastLine = null, this._imageIndex++, h = this._images[this._imageIndex]) : this._lastLine = u, h ? this.read(h.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(r, o, n) {
        (function(i) {
          (function() {
            function a(p, l, d, u, h) {
              let y = 0;
              for (let f = 0; f < u; f++)
                for (let b = 0; b < d; b++) {
                  let w = h[p[y]];
                  if (!w)
                    throw new Error("index " + p[y] + " not in palette");
                  for (let x = 0; x < 4; x++)
                    l[y + x] = w[x];
                  y += 4;
                }
            }
            function s(p, l, d, u, h) {
              let y = 0;
              for (let f = 0; f < u; f++)
                for (let b = 0; b < d; b++) {
                  let w = !1;
                  if (h.length === 1 ? h[0] === p[y] && (w = !0) : h[0] === p[y] && h[1] === p[y + 1] && h[2] === p[y + 2] && (w = !0), w)
                    for (let x = 0; x < 4; x++)
                      l[y + x] = 0;
                  y += 4;
                }
            }
            function c(p, l, d, u, h) {
              let y = 255, f = Math.pow(2, h) - 1, b = 0;
              for (let w = 0; w < u; w++)
                for (let x = 0; x < d; x++) {
                  for (let E = 0; E < 4; E++)
                    l[b + E] = Math.floor(
                      p[b + E] * y / f + 0.5
                    );
                  b += 4;
                }
            }
            o.exports = function(p, l, d = !1) {
              let u = l.depth, h = l.width, y = l.height, f = l.colorType, b = l.transColor, w = l.palette, x = p;
              return f === 3 ? a(p, x, h, y, w) : (b && s(p, x, h, y, b), u !== 8 && !d && (u === 16 && (x = i.alloc(h * y * 4)), c(p, x, h, y, u))), x;
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { buffer: 32 }], 11: [function(r, o, n) {
        let i = [
          {
            // pass 1 - 1px
            x: [0],
            y: [0]
          },
          {
            // pass 2 - 1px
            x: [4],
            y: [0]
          },
          {
            // pass 3 - 2px
            x: [0, 4],
            y: [4]
          },
          {
            // pass 4 - 4px
            x: [2, 6],
            y: [0, 4]
          },
          {
            // pass 5 - 8px
            x: [0, 2, 4, 6],
            y: [2, 6]
          },
          {
            // pass 6 - 16px
            x: [1, 3, 5, 7],
            y: [0, 2, 4, 6]
          },
          {
            // pass 7 - 32px
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [1, 3, 5, 7]
          }
        ];
        n.getImagePasses = function(a, s) {
          let c = [], p = a % 8, l = s % 8, d = (a - p) / 8, u = (s - l) / 8;
          for (let h = 0; h < i.length; h++) {
            let y = i[h], f = d * y.x.length, b = u * y.y.length;
            for (let w = 0; w < y.x.length && y.x[w] < p; w++)
              f++;
            for (let w = 0; w < y.y.length && y.y[w] < l; w++)
              b++;
            f > 0 && b > 0 && c.push({ width: f, height: b, index: h });
          }
          return c;
        }, n.getInterlaceIterator = function(a) {
          return function(s, c, p) {
            let l = s % i[p].x.length, d = (s - l) / i[p].x.length * 8 + i[p].x[l], u = c % i[p].y.length, h = (c - u) / i[p].y.length * 8 + i[p].y[u];
            return d * 4 + h * a * 4;
          };
        };
      }, {}], 12: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("util"), s = r("stream"), c = r("./constants"), p = r("./packer"), l = o.exports = function(d) {
              s.call(this);
              let u = d || {};
              this._packer = new p(u), this._deflate = this._packer.createDeflate(), this.readable = !0;
            };
            a.inherits(l, s), l.prototype.pack = function(d, u, h, y) {
              this.emit("data", i.from(c.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(u, h)), y && this.emit("data", this._packer.packGAMA(y));
              let f = this._packer.filterData(d, u, h);
              this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on(
                "data",
                (function(b) {
                  this.emit("data", this._packer.packIDAT(b));
                }).bind(this)
              ), this._deflate.on(
                "end",
                (function() {
                  this.emit("data", this._packer.packIEND()), this.emit("end");
                }).bind(this)
              ), this._deflate.end(f);
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = !0, s = r("zlib");
            s.deflateSync || (a = !1);
            let c = r("./constants"), p = r("./packer");
            o.exports = function(l, d) {
              if (!a)
                throw new Error(
                  "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
                );
              let u = d || {}, h = new p(u), y = [];
              y.push(i.from(c.PNG_SIGNATURE)), y.push(h.packIHDR(l.width, l.height)), l.gamma && y.push(h.packGAMA(l.gamma));
              let f = h.filterData(
                l.data,
                l.width,
                l.height
              ), b = s.deflateSync(
                f,
                h.getDeflateOptions()
              );
              if (f = null, !b || !b.length)
                throw new Error("bad png - invalid compressed data response");
              return y.push(h.packIDAT(b)), y.push(h.packIEND()), i.concat(y);
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./constants"), s = r("./crc"), c = r("./bitpacker"), p = r("./filter-pack"), l = r("zlib"), d = o.exports = function(u) {
              if (this._options = u, u.deflateChunkSize = u.deflateChunkSize || 32 * 1024, u.deflateLevel = u.deflateLevel != null ? u.deflateLevel : 9, u.deflateStrategy = u.deflateStrategy != null ? u.deflateStrategy : 3, u.inputHasAlpha = u.inputHasAlpha != null ? u.inputHasAlpha : !0, u.deflateFactory = u.deflateFactory || l.createDeflate, u.bitDepth = u.bitDepth || 8, u.colorType = typeof u.colorType == "number" ? u.colorType : a.COLORTYPE_COLOR_ALPHA, u.inputColorType = typeof u.inputColorType == "number" ? u.inputColorType : a.COLORTYPE_COLOR_ALPHA, [
                a.COLORTYPE_GRAYSCALE,
                a.COLORTYPE_COLOR,
                a.COLORTYPE_COLOR_ALPHA,
                a.COLORTYPE_ALPHA
              ].indexOf(u.colorType) === -1)
                throw new Error(
                  "option color type:" + u.colorType + " is not supported at present"
                );
              if ([
                a.COLORTYPE_GRAYSCALE,
                a.COLORTYPE_COLOR,
                a.COLORTYPE_COLOR_ALPHA,
                a.COLORTYPE_ALPHA
              ].indexOf(u.inputColorType) === -1)
                throw new Error(
                  "option input color type:" + u.inputColorType + " is not supported at present"
                );
              if (u.bitDepth !== 8 && u.bitDepth !== 16)
                throw new Error(
                  "option bit depth:" + u.bitDepth + " is not supported at present"
                );
            };
            d.prototype.getDeflateOptions = function() {
              return {
                chunkSize: this._options.deflateChunkSize,
                level: this._options.deflateLevel,
                strategy: this._options.deflateStrategy
              };
            }, d.prototype.createDeflate = function() {
              return this._options.deflateFactory(this.getDeflateOptions());
            }, d.prototype.filterData = function(u, h, y) {
              let f = c(u, h, y, this._options), b = a.COLORTYPE_TO_BPP_MAP[this._options.colorType];
              return p(f, h, y, this._options, b);
            }, d.prototype._packChunk = function(u, h) {
              let y = h ? h.length : 0, f = i.alloc(y + 12);
              return f.writeUInt32BE(y, 0), f.writeUInt32BE(u, 4), h && h.copy(f, 8), f.writeInt32BE(
                s.crc32(f.slice(4, f.length - 4)),
                f.length - 4
              ), f;
            }, d.prototype.packGAMA = function(u) {
              let h = i.alloc(4);
              return h.writeUInt32BE(Math.floor(u * a.GAMMA_DIVISION), 0), this._packChunk(a.TYPE_gAMA, h);
            }, d.prototype.packIHDR = function(u, h) {
              let y = i.alloc(13);
              return y.writeUInt32BE(u, 0), y.writeUInt32BE(h, 4), y[8] = this._options.bitDepth, y[9] = this._options.colorType, y[10] = 0, y[11] = 0, y[12] = 0, this._packChunk(a.TYPE_IHDR, y);
            }, d.prototype.packIDAT = function(u) {
              return this._packChunk(a.TYPE_IDAT, u);
            }, d.prototype.packIEND = function() {
              return this._packChunk(a.TYPE_IEND, null);
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(r, o, n) {
        o.exports = function(a, s, c) {
          let p = a + s - c, l = Math.abs(p - a), d = Math.abs(p - s), u = Math.abs(p - c);
          return l <= d && l <= u ? a : d <= u ? s : c;
        };
      }, {}], 16: [function(r, o, n) {
        let i = r("util"), a = r("zlib"), s = r("./chunkstream"), c = r("./filter-parse-async"), p = r("./parser"), l = r("./bitmapper"), d = r("./format-normaliser"), u = o.exports = function(h) {
          s.call(this), this._parser = new p(h, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this),
            simpleTransparency: this._simpleTransparency.bind(this),
            headersFinished: this._headersFinished.bind(this)
          }), this._options = h, this.writable = !0, this._parser.start();
        };
        i.inherits(u, s), u.prototype._handleError = function(h) {
          this.emit("error", h), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
          })), this.errord = !0;
        }, u.prototype._inflateData = function(h) {
          if (!this._inflate)
            if (this._bitmapInfo.interlace)
              this._inflate = a.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
            else {
              let f = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1) * this._bitmapInfo.height, b = Math.max(f, a.Z_MIN_CHUNK);
              this._inflate = a.createInflate({ chunkSize: b });
              let w = f, x = this.emit.bind(this, "error");
              this._inflate.on("error", function(T) {
                w && x(T);
              }), this._filter.on("complete", this._complete.bind(this));
              let E = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(T) {
                w && (T.length > w && (T = T.slice(0, w)), w -= T.length, E(T));
              }), this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          this._inflate.write(h);
        }, u.prototype._handleMetaData = function(h) {
          this._metaData = h, this._bitmapInfo = Object.create(h), this._filter = new c(this._bitmapInfo);
        }, u.prototype._handleTransColor = function(h) {
          this._bitmapInfo.transColor = h;
        }, u.prototype._handlePalette = function(h) {
          this._bitmapInfo.palette = h;
        }, u.prototype._simpleTransparency = function() {
          this._metaData.alpha = !0;
        }, u.prototype._headersFinished = function() {
          this.emit("metadata", this._metaData);
        }, u.prototype._finished = function() {
          this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
        }, u.prototype._complete = function(h) {
          if (this.errord)
            return;
          let y;
          try {
            let f = l.dataToBitMap(h, this._bitmapInfo);
            y = d(
              f,
              this._bitmapInfo,
              this._options.skipRescale
            ), f = null;
          } catch (f) {
            this._handleError(f);
            return;
          }
          this.emit("parsed", y);
        };
      }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = !0, s = r("zlib"), c = r("./sync-inflate");
            s.deflateSync || (a = !1);
            let p = r("./sync-reader"), l = r("./filter-parse-sync"), d = r("./parser"), u = r("./bitmapper"), h = r("./format-normaliser");
            o.exports = function(y, f) {
              if (!a)
                throw new Error(
                  "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
                );
              let b;
              function w($) {
                b = $;
              }
              let x;
              function E($) {
                x = $;
              }
              function T($) {
                x.transColor = $;
              }
              function C($) {
                x.palette = $;
              }
              function R() {
                x.alpha = !0;
              }
              let A;
              function j($) {
                A = $;
              }
              let N = [];
              function O($) {
                N.push($);
              }
              let D = new p(y);
              if (new d(f, {
                read: D.read.bind(D),
                error: w,
                metadata: E,
                gamma: j,
                palette: C,
                transColor: T,
                inflateData: O,
                simpleTransparency: R
              }).start(), D.process(), b)
                throw b;
              let G = i.concat(N);
              N.length = 0;
              let X;
              if (x.interlace)
                X = s.inflateSync(G);
              else {
                let ne = ((x.width * x.bpp * x.depth + 7 >> 3) + 1) * x.height;
                X = c(G, {
                  chunkSize: ne,
                  maxLength: ne
                });
              }
              if (G = null, !X || !X.length)
                throw new Error("bad png - invalid inflate data response");
              let Q = l.process(X, x);
              G = null;
              let M = u.dataToBitMap(Q, x);
              Q = null;
              let k = h(
                M,
                x,
                f.skipRescale
              );
              return x.data = k, x.gamma = A || 0, x;
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(r, o, n) {
        (function(i) {
          (function() {
            let a = r("./constants"), s = r("./crc"), c = o.exports = function(p, l) {
              this._options = p, p.checkCRC = p.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[a.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[a.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[a.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[a.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[a.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[a.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = l.read, this.error = l.error, this.metadata = l.metadata, this.gamma = l.gamma, this.transColor = l.transColor, this.palette = l.palette, this.parsed = l.parsed, this.inflateData = l.inflateData, this.finished = l.finished, this.simpleTransparency = l.simpleTransparency, this.headersFinished = l.headersFinished || function() {
              };
            };
            c.prototype.start = function() {
              this.read(a.PNG_SIGNATURE.length, this._parseSignature.bind(this));
            }, c.prototype._parseSignature = function(p) {
              let l = a.PNG_SIGNATURE;
              for (let d = 0; d < l.length; d++)
                if (p[d] !== l[d]) {
                  this.error(new Error("Invalid file signature"));
                  return;
                }
              this.read(8, this._parseChunkBegin.bind(this));
            }, c.prototype._parseChunkBegin = function(p) {
              let l = p.readUInt32BE(0), d = p.readUInt32BE(4), u = "";
              for (let y = 4; y < 8; y++)
                u += String.fromCharCode(p[y]);
              let h = !!(p[4] & 32);
              if (!this._hasIHDR && d !== a.TYPE_IHDR) {
                this.error(new Error("Expected IHDR on beggining"));
                return;
              }
              if (this._crc = new s(), this._crc.write(i.from(u)), this._chunks[d])
                return this._chunks[d](l);
              if (!h) {
                this.error(new Error("Unsupported critical chunk type " + u));
                return;
              }
              this.read(l + 4, this._skipChunk.bind(this));
            }, c.prototype._skipChunk = function() {
              this.read(8, this._parseChunkBegin.bind(this));
            }, c.prototype._handleChunkEnd = function() {
              this.read(4, this._parseChunkEnd.bind(this));
            }, c.prototype._parseChunkEnd = function(p) {
              let l = p.readInt32BE(0), d = this._crc.crc32();
              if (this._options.checkCRC && d !== l) {
                this.error(new Error("Crc error - " + l + " - " + d));
                return;
              }
              this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
            }, c.prototype._handleIHDR = function(p) {
              this.read(p, this._parseIHDR.bind(this));
            }, c.prototype._parseIHDR = function(p) {
              this._crc.write(p);
              let l = p.readUInt32BE(0), d = p.readUInt32BE(4), u = p[8], h = p[9], y = p[10], f = p[11], b = p[12];
              if (u !== 8 && u !== 4 && u !== 2 && u !== 1 && u !== 16) {
                this.error(new Error("Unsupported bit depth " + u));
                return;
              }
              if (!(h in a.COLORTYPE_TO_BPP_MAP)) {
                this.error(new Error("Unsupported color type"));
                return;
              }
              if (y !== 0) {
                this.error(new Error("Unsupported compression method"));
                return;
              }
              if (f !== 0) {
                this.error(new Error("Unsupported filter method"));
                return;
              }
              if (b !== 0 && b !== 1) {
                this.error(new Error("Unsupported interlace method"));
                return;
              }
              this._colorType = h;
              let w = a.COLORTYPE_TO_BPP_MAP[this._colorType];
              this._hasIHDR = !0, this.metadata({
                width: l,
                height: d,
                depth: u,
                interlace: !!b,
                palette: !!(h & a.COLORTYPE_PALETTE),
                color: !!(h & a.COLORTYPE_COLOR),
                alpha: !!(h & a.COLORTYPE_ALPHA),
                bpp: w,
                colorType: h
              }), this._handleChunkEnd();
            }, c.prototype._handlePLTE = function(p) {
              this.read(p, this._parsePLTE.bind(this));
            }, c.prototype._parsePLTE = function(p) {
              this._crc.write(p);
              let l = Math.floor(p.length / 3);
              for (let d = 0; d < l; d++)
                this._palette.push([p[d * 3], p[d * 3 + 1], p[d * 3 + 2], 255]);
              this.palette(this._palette), this._handleChunkEnd();
            }, c.prototype._handleTRNS = function(p) {
              this.simpleTransparency(), this.read(p, this._parseTRNS.bind(this));
            }, c.prototype._parseTRNS = function(p) {
              if (this._crc.write(p), this._colorType === a.COLORTYPE_PALETTE_COLOR) {
                if (this._palette.length === 0) {
                  this.error(new Error("Transparency chunk must be after palette"));
                  return;
                }
                if (p.length > this._palette.length) {
                  this.error(new Error("More transparent colors than palette size"));
                  return;
                }
                for (let l = 0; l < p.length; l++)
                  this._palette[l][3] = p[l];
                this.palette(this._palette);
              }
              this._colorType === a.COLORTYPE_GRAYSCALE && this.transColor([p.readUInt16BE(0)]), this._colorType === a.COLORTYPE_COLOR && this.transColor([
                p.readUInt16BE(0),
                p.readUInt16BE(2),
                p.readUInt16BE(4)
              ]), this._handleChunkEnd();
            }, c.prototype._handleGAMA = function(p) {
              this.read(p, this._parseGAMA.bind(this));
            }, c.prototype._parseGAMA = function(p) {
              this._crc.write(p), this.gamma(p.readUInt32BE(0) / a.GAMMA_DIVISION), this._handleChunkEnd();
            }, c.prototype._handleIDAT = function(p) {
              this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), this.read(-p, this._parseIDAT.bind(this, p));
            }, c.prototype._parseIDAT = function(p, l) {
              if (this._crc.write(l), this._colorType === a.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
                throw new Error("Expected palette not found");
              this.inflateData(l);
              let d = p - l.length;
              d > 0 ? this._handleIDAT(d) : this._handleChunkEnd();
            }, c.prototype._handleIEND = function(p) {
              this.read(p, this._parseIEND.bind(this));
            }, c.prototype._parseIEND = function(p) {
              this._crc.write(p), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
            };
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(r, o, n) {
        let i = r("./parser-sync"), a = r("./packer-sync");
        n.read = function(s, c) {
          return i(s, c || {});
        }, n.write = function(s, c) {
          return a(s, c);
        };
      }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(r, o, n) {
        (function(i, a) {
          (function() {
            let s = r("util"), c = r("stream"), p = r("./parser-async"), l = r("./packer-async"), d = r("./png-sync"), u = n.PNG = function(h) {
              c.call(this), h = h || {}, this.width = h.width | 0, this.height = h.height | 0, this.data = this.width > 0 && this.height > 0 ? a.alloc(4 * this.width * this.height) : null, h.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new p(h), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on(
                "parsed",
                (function(y) {
                  this.data = y, this.emit("parsed", y);
                }).bind(this)
              ), this._packer = new l(h), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
            };
            s.inherits(u, c), u.sync = d, u.prototype.pack = function() {
              return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (i.nextTick(
                (function() {
                  this._packer.pack(this.data, this.width, this.height, this.gamma);
                }).bind(this)
              ), this);
            }, u.prototype.parse = function(h, y) {
              if (y) {
                let f, b;
                f = (function(w) {
                  this.removeListener("error", b), this.data = w, y(null, this);
                }).bind(this), b = (function(w) {
                  this.removeListener("parsed", f), y(w, null);
                }).bind(this), this.once("parsed", f), this.once("error", b);
              }
              return this.end(h), this;
            }, u.prototype.write = function(h) {
              return this._parser.write(h), !0;
            }, u.prototype.end = function(h) {
              this._parser.end(h);
            }, u.prototype._metadata = function(h) {
              this.width = h.width, this.height = h.height, this.emit("metadata", h);
            }, u.prototype._gamma = function(h) {
              this.gamma = h;
            }, u.prototype._handleClose = function() {
              !this._parser.writable && !this._packer.readable && this.emit("close");
            }, u.bitblt = function(h, y, f, b, w, x, E, T) {
              if (f |= 0, b |= 0, w |= 0, x |= 0, E |= 0, T |= 0, f > h.width || b > h.height || f + w > h.width || b + x > h.height)
                throw new Error("bitblt reading outside image");
              if (E > y.width || T > y.height || E + w > y.width || T + x > y.height)
                throw new Error("bitblt writing outside image");
              for (let C = 0; C < x; C++)
                h.data.copy(
                  y.data,
                  (T + C) * y.width + E << 2,
                  (b + C) * h.width + f << 2,
                  (b + C) * h.width + f + w << 2
                );
            }, u.prototype.bitblt = function(h, y, f, b, w, x, E) {
              return u.bitblt(this, h, y, f, b, w, x, E), this;
            }, u.adjustGamma = function(h) {
              if (h.gamma) {
                for (let y = 0; y < h.height; y++)
                  for (let f = 0; f < h.width; f++) {
                    let b = h.width * y + f << 2;
                    for (let w = 0; w < 3; w++) {
                      let x = h.data[b + w] / 255;
                      x = Math.pow(x, 1 / 2.2 / h.gamma), h.data[b + w] = Math.round(x * 255);
                    }
                  }
                h.gamma = 0;
              }
            }, u.prototype.adjustGamma = function() {
              u.adjustGamma(this);
            };
          }).call(this);
        }).call(this, r("_process"), r("buffer").Buffer);
      }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(r, o, n) {
        (function(i, a) {
          (function() {
            let s = r("assert").ok, c = r("zlib"), p = r("util"), l = r("buffer").kMaxLength;
            function d(b) {
              if (!(this instanceof d))
                return new d(b);
              b && b.chunkSize < c.Z_MIN_CHUNK && (b.chunkSize = c.Z_MIN_CHUNK), c.Inflate.call(this, b), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, b && b.maxLength != null && (this._maxLength = b.maxLength);
            }
            function u(b) {
              return new d(b);
            }
            function h(b, w) {
              b._handle && (b._handle.close(), b._handle = null);
            }
            d.prototype._processChunk = function(b, w, x) {
              if (typeof x == "function")
                return c.Inflate._processChunk.call(this, b, w, x);
              let E = this, T = b && b.length, C = this._chunkSize - this._offset, R = this._maxLength, A = 0, j = [], N = 0, O;
              this.on("error", function(X) {
                O = X;
              });
              function D(X, Q) {
                if (E._hadError)
                  return;
                let M = C - Q;
                if (s(M >= 0, "have should not go down"), M > 0) {
                  let k = E._buffer.slice(E._offset, E._offset + M);
                  if (E._offset += M, k.length > R && (k = k.slice(0, R)), j.push(k), N += k.length, R -= k.length, R === 0)
                    return !1;
                }
                return (Q === 0 || E._offset >= E._chunkSize) && (C = E._chunkSize, E._offset = 0, E._buffer = a.allocUnsafe(E._chunkSize)), Q === 0 ? (A += T - X, T = X, !0) : !1;
              }
              s(this._handle, "zlib binding closed");
              let H;
              do
                H = this._handle.writeSync(
                  w,
                  b,
                  // in
                  A,
                  // in_off
                  T,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  C
                ), H = H || this._writeState;
              while (!this._hadError && D(H[0], H[1]));
              if (this._hadError)
                throw O;
              if (N >= l)
                throw h(this), new RangeError(
                  "Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes"
                );
              let G = a.concat(j, N);
              return h(this), G;
            }, p.inherits(d, c.Inflate);
            function y(b, w) {
              if (typeof w == "string" && (w = a.from(w)), !(w instanceof a))
                throw new TypeError("Not a string or buffer");
              let x = b._finishFlushFlag;
              return x == null && (x = c.Z_FINISH), b._processChunk(w, x);
            }
            function f(b, w) {
              return y(new d(w), b);
            }
            o.exports = n = f, n.Inflate = d, n.createInflate = u, n.inflateSync = f;
          }).call(this);
        }).call(this, r("_process"), r("buffer").Buffer);
      }, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(r, o, n) {
        let i = o.exports = function(a) {
          this._buffer = a, this._reads = [];
        };
        i.prototype.read = function(a, s) {
          this._reads.push({
            length: Math.abs(a),
            // if length < 0 then at most this length
            allowLess: a < 0,
            func: s
          });
        }, i.prototype.process = function() {
          for (; this._reads.length > 0 && this._buffer.length; ) {
            let a = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= a.length || a.allowLess)) {
              this._reads.shift();
              let s = this._buffer;
              this._buffer = s.slice(a.length), a.func.call(this, s.slice(0, a.length));
            } else
              break;
          }
          if (this._reads.length > 0)
            throw new Error("There are some read requests waitng on finished stream");
          if (this._buffer.length > 0)
            throw new Error("unrecognised content at end of stream");
        };
      }, {}], 23: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = r("object-assign");
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
             * @license  MIT
             */
            function s(M, k) {
              if (M === k)
                return 0;
              for (var $ = M.length, ne = k.length, te = 0, de = Math.min($, ne); te < de; ++te)
                if (M[te] !== k[te]) {
                  $ = M[te], ne = k[te];
                  break;
                }
              return $ < ne ? -1 : ne < $ ? 1 : 0;
            }
            function c(M) {
              return i.Buffer && typeof i.Buffer.isBuffer == "function" ? i.Buffer.isBuffer(M) : !!(M != null && M._isBuffer);
            }
            var p = r("util/"), l = Object.prototype.hasOwnProperty, d = Array.prototype.slice, u = function() {
              return (function() {
              }).name === "foo";
            }();
            function h(M) {
              return Object.prototype.toString.call(M);
            }
            function y(M) {
              return c(M) || typeof i.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(M) : M ? !!(M instanceof DataView || M.buffer && M.buffer instanceof ArrayBuffer) : !1;
            }
            var f = o.exports = R, b = /\s*function\s+([^\(\s]*)\s*/;
            function w(M) {
              if (p.isFunction(M)) {
                if (u)
                  return M.name;
                var k = M.toString(), $ = k.match(b);
                return $ && $[1];
              }
            }
            f.AssertionError = function(k) {
              this.name = "AssertionError", this.actual = k.actual, this.expected = k.expected, this.operator = k.operator, k.message ? (this.message = k.message, this.generatedMessage = !1) : (this.message = T(this), this.generatedMessage = !0);
              var $ = k.stackStartFunction || C;
              if (Error.captureStackTrace)
                Error.captureStackTrace(this, $);
              else {
                var ne = new Error();
                if (ne.stack) {
                  var te = ne.stack, de = w($), ae = te.indexOf(`
` + de);
                  if (ae >= 0) {
                    var z = te.indexOf(`
`, ae + 1);
                    te = te.substring(z + 1);
                  }
                  this.stack = te;
                }
              }
            }, p.inherits(f.AssertionError, Error);
            function x(M, k) {
              return typeof M == "string" ? M.length < k ? M : M.slice(0, k) : M;
            }
            function E(M) {
              if (u || !p.isFunction(M))
                return p.inspect(M);
              var k = w(M), $ = k ? ": " + k : "";
              return "[Function" + $ + "]";
            }
            function T(M) {
              return x(E(M.actual), 128) + " " + M.operator + " " + x(E(M.expected), 128);
            }
            function C(M, k, $, ne, te) {
              throw new f.AssertionError({
                message: $,
                actual: M,
                expected: k,
                operator: ne,
                stackStartFunction: te
              });
            }
            f.fail = C;
            function R(M, k) {
              M || C(M, !0, k, "==", f.ok);
            }
            f.ok = R, f.equal = function(k, $, ne) {
              k != $ && C(k, $, ne, "==", f.equal);
            }, f.notEqual = function(k, $, ne) {
              k == $ && C(k, $, ne, "!=", f.notEqual);
            }, f.deepEqual = function(k, $, ne) {
              A(k, $, !1) || C(k, $, ne, "deepEqual", f.deepEqual);
            }, f.deepStrictEqual = function(k, $, ne) {
              A(k, $, !0) || C(k, $, ne, "deepStrictEqual", f.deepStrictEqual);
            };
            function A(M, k, $, ne) {
              if (M === k)
                return !0;
              if (c(M) && c(k))
                return s(M, k) === 0;
              if (p.isDate(M) && p.isDate(k))
                return M.getTime() === k.getTime();
              if (p.isRegExp(M) && p.isRegExp(k))
                return M.source === k.source && M.global === k.global && M.multiline === k.multiline && M.lastIndex === k.lastIndex && M.ignoreCase === k.ignoreCase;
              if ((M === null || typeof M != "object") && (k === null || typeof k != "object"))
                return $ ? M === k : M == k;
              if (y(M) && y(k) && h(M) === h(k) && !(M instanceof Float32Array || M instanceof Float64Array))
                return s(
                  new Uint8Array(M.buffer),
                  new Uint8Array(k.buffer)
                ) === 0;
              if (c(M) !== c(k))
                return !1;
              ne = ne || { actual: [], expected: [] };
              var te = ne.actual.indexOf(M);
              return te !== -1 && te === ne.expected.indexOf(k) ? !0 : (ne.actual.push(M), ne.expected.push(k), N(M, k, $, ne));
            }
            function j(M) {
              return Object.prototype.toString.call(M) == "[object Arguments]";
            }
            function N(M, k, $, ne) {
              if (M == null || k === null || k === void 0)
                return !1;
              if (p.isPrimitive(M) || p.isPrimitive(k))
                return M === k;
              if ($ && Object.getPrototypeOf(M) !== Object.getPrototypeOf(k))
                return !1;
              var te = j(M), de = j(k);
              if (te && !de || !te && de)
                return !1;
              if (te)
                return M = d.call(M), k = d.call(k), A(M, k, $);
              var ae = Q(M), z = Q(k), Z, oe;
              if (ae.length !== z.length)
                return !1;
              for (ae.sort(), z.sort(), oe = ae.length - 1; oe >= 0; oe--)
                if (ae[oe] !== z[oe])
                  return !1;
              for (oe = ae.length - 1; oe >= 0; oe--)
                if (Z = ae[oe], !A(M[Z], k[Z], $, ne))
                  return !1;
              return !0;
            }
            f.notDeepEqual = function(k, $, ne) {
              A(k, $, !1) && C(k, $, ne, "notDeepEqual", f.notDeepEqual);
            }, f.notDeepStrictEqual = O;
            function O(M, k, $) {
              A(M, k, !0) && C(M, k, $, "notDeepStrictEqual", O);
            }
            f.strictEqual = function(k, $, ne) {
              k !== $ && C(k, $, ne, "===", f.strictEqual);
            }, f.notStrictEqual = function(k, $, ne) {
              k === $ && C(k, $, ne, "!==", f.notStrictEqual);
            };
            function D(M, k) {
              if (!M || !k)
                return !1;
              if (Object.prototype.toString.call(k) == "[object RegExp]")
                return k.test(M);
              try {
                if (M instanceof k)
                  return !0;
              } catch {
              }
              return Error.isPrototypeOf(k) ? !1 : k.call({}, M) === !0;
            }
            function H(M) {
              var k;
              try {
                M();
              } catch ($) {
                k = $;
              }
              return k;
            }
            function G(M, k, $, ne) {
              var te;
              if (typeof k != "function")
                throw new TypeError('"block" argument must be a function');
              typeof $ == "string" && (ne = $, $ = null), te = H(k), ne = ($ && $.name ? " (" + $.name + ")." : ".") + (ne ? " " + ne : "."), M && !te && C(te, $, "Missing expected exception" + ne);
              var de = typeof ne == "string", ae = !M && p.isError(te), z = !M && te && !$;
              if ((ae && de && D(te, $) || z) && C(te, $, "Got unwanted exception" + ne), M && te && $ && !D(te, $) || !M && te)
                throw te;
            }
            f.throws = function(M, k, $) {
              G(!0, M, k, $);
            }, f.doesNotThrow = function(M, k, $) {
              G(!1, M, k, $);
            }, f.ifError = function(M) {
              if (M) throw M;
            };
            function X(M, k) {
              M || C(M, !0, k, "==", X);
            }
            f.strict = a(X, f, {
              equal: f.strictEqual,
              deepEqual: f.deepStrictEqual,
              notEqual: f.notStrictEqual,
              notDeepEqual: f.notDeepStrictEqual
            }), f.strict.strict = f.strict;
            var Q = Object.keys || function(M) {
              var k = [];
              for (var $ in M)
                l.call(M, $) && k.push($);
              return k;
            };
          }).call(this);
        }).call(this, typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "object-assign": 51, "util/": 26 }], 24: [function(r, o, n) {
        typeof Object.create == "function" ? o.exports = function(a, s) {
          a.super_ = s, a.prototype = Object.create(s.prototype, {
            constructor: {
              value: a,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : o.exports = function(a, s) {
          a.super_ = s;
          var c = function() {
          };
          c.prototype = s.prototype, a.prototype = new c(), a.prototype.constructor = a;
        };
      }, {}], 25: [function(r, o, n) {
        o.exports = function(a) {
          return a && typeof a == "object" && typeof a.copy == "function" && typeof a.fill == "function" && typeof a.readUInt8 == "function";
        };
      }, {}], 26: [function(r, o, n) {
        (function(i, a) {
          (function() {
            var s = /%[sdj%]/g;
            n.format = function(z) {
              if (!N(z)) {
                for (var Z = [], oe = 0; oe < arguments.length; oe++)
                  Z.push(l(arguments[oe]));
                return Z.join(" ");
              }
              for (var oe = 1, ye = arguments, V = ye.length, q = String(z).replace(s, function(ue) {
                if (ue === "%%") return "%";
                if (oe >= V) return ue;
                switch (ue) {
                  case "%s":
                    return String(ye[oe++]);
                  case "%d":
                    return Number(ye[oe++]);
                  case "%j":
                    try {
                      return JSON.stringify(ye[oe++]);
                    } catch {
                      return "[Circular]";
                    }
                  default:
                    return ue;
                }
              }), ee = ye[oe]; oe < V; ee = ye[++oe])
                R(ee) || !G(ee) ? q += " " + ee : q += " " + l(ee);
              return q;
            }, n.deprecate = function(z, Z) {
              if (D(a.process))
                return function() {
                  return n.deprecate(z, Z).apply(this, arguments);
                };
              if (i.noDeprecation === !0)
                return z;
              var oe = !1;
              function ye() {
                if (!oe) {
                  if (i.throwDeprecation)
                    throw new Error(Z);
                  i.traceDeprecation ? console.trace(Z) : console.error(Z), oe = !0;
                }
                return z.apply(this, arguments);
              }
              return ye;
            };
            var c = {}, p;
            n.debuglog = function(z) {
              if (D(p) && (p = i.env.NODE_DEBUG || ""), z = z.toUpperCase(), !c[z])
                if (new RegExp("\\b" + z + "\\b", "i").test(p)) {
                  var Z = i.pid;
                  c[z] = function() {
                    var oe = n.format.apply(n, arguments);
                    console.error("%s %d: %s", z, Z, oe);
                  };
                } else
                  c[z] = function() {
                  };
              return c[z];
            };
            function l(z, Z) {
              var oe = {
                seen: [],
                stylize: u
              };
              return arguments.length >= 3 && (oe.depth = arguments[2]), arguments.length >= 4 && (oe.colors = arguments[3]), C(Z) ? oe.showHidden = Z : Z && n._extend(oe, Z), D(oe.showHidden) && (oe.showHidden = !1), D(oe.depth) && (oe.depth = 2), D(oe.colors) && (oe.colors = !1), D(oe.customInspect) && (oe.customInspect = !0), oe.colors && (oe.stylize = d), y(oe, z, oe.depth);
            }
            n.inspect = l, l.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39]
            }, l.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              // "name": intentionally not styling
              regexp: "red"
            };
            function d(z, Z) {
              var oe = l.styles[Z];
              return oe ? "\x1B[" + l.colors[oe][0] + "m" + z + "\x1B[" + l.colors[oe][1] + "m" : z;
            }
            function u(z, Z) {
              return z;
            }
            function h(z) {
              var Z = {};
              return z.forEach(function(oe, ye) {
                Z[oe] = !0;
              }), Z;
            }
            function y(z, Z, oe) {
              if (z.customInspect && Z && M(Z.inspect) && // Filter out the util module, it's inspect function is special
              Z.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
              !(Z.constructor && Z.constructor.prototype === Z)) {
                var ye = Z.inspect(oe, z);
                return N(ye) || (ye = y(z, ye, oe)), ye;
              }
              var V = f(z, Z);
              if (V)
                return V;
              var q = Object.keys(Z), ee = h(q);
              if (z.showHidden && (q = Object.getOwnPropertyNames(Z)), Q(Z) && (q.indexOf("message") >= 0 || q.indexOf("description") >= 0))
                return b(Z);
              if (q.length === 0) {
                if (M(Z)) {
                  var ue = Z.name ? ": " + Z.name : "";
                  return z.stylize("[Function" + ue + "]", "special");
                }
                if (H(Z))
                  return z.stylize(RegExp.prototype.toString.call(Z), "regexp");
                if (X(Z))
                  return z.stylize(Date.prototype.toString.call(Z), "date");
                if (Q(Z))
                  return b(Z);
              }
              var ge = "", he = !1, W = ["{", "}"];
              if (T(Z) && (he = !0, W = ["[", "]"]), M(Z)) {
                var Y = Z.name ? ": " + Z.name : "";
                ge = " [Function" + Y + "]";
              }
              if (H(Z) && (ge = " " + RegExp.prototype.toString.call(Z)), X(Z) && (ge = " " + Date.prototype.toUTCString.call(Z)), Q(Z) && (ge = " " + b(Z)), q.length === 0 && (!he || Z.length == 0))
                return W[0] + ge + W[1];
              if (oe < 0)
                return H(Z) ? z.stylize(RegExp.prototype.toString.call(Z), "regexp") : z.stylize("[Object]", "special");
              z.seen.push(Z);
              var se;
              return he ? se = w(z, Z, oe, ee, q) : se = q.map(function(Te) {
                return x(z, Z, oe, ee, Te, he);
              }), z.seen.pop(), E(se, ge, W);
            }
            function f(z, Z) {
              if (D(Z))
                return z.stylize("undefined", "undefined");
              if (N(Z)) {
                var oe = "'" + JSON.stringify(Z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return z.stylize(oe, "string");
              }
              if (j(Z))
                return z.stylize("" + Z, "number");
              if (C(Z))
                return z.stylize("" + Z, "boolean");
              if (R(Z))
                return z.stylize("null", "null");
            }
            function b(z) {
              return "[" + Error.prototype.toString.call(z) + "]";
            }
            function w(z, Z, oe, ye, V) {
              for (var q = [], ee = 0, ue = Z.length; ee < ue; ++ee)
                ae(Z, String(ee)) ? q.push(x(
                  z,
                  Z,
                  oe,
                  ye,
                  String(ee),
                  !0
                )) : q.push("");
              return V.forEach(function(ge) {
                ge.match(/^\d+$/) || q.push(x(
                  z,
                  Z,
                  oe,
                  ye,
                  ge,
                  !0
                ));
              }), q;
            }
            function x(z, Z, oe, ye, V, q) {
              var ee, ue, ge;
              if (ge = Object.getOwnPropertyDescriptor(Z, V) || { value: Z[V] }, ge.get ? ge.set ? ue = z.stylize("[Getter/Setter]", "special") : ue = z.stylize("[Getter]", "special") : ge.set && (ue = z.stylize("[Setter]", "special")), ae(ye, V) || (ee = "[" + V + "]"), ue || (z.seen.indexOf(ge.value) < 0 ? (R(oe) ? ue = y(z, ge.value, null) : ue = y(z, ge.value, oe - 1), ue.indexOf(`
`) > -1 && (q ? ue = ue.split(`
`).map(function(he) {
                return "  " + he;
              }).join(`
`).substr(2) : ue = `
` + ue.split(`
`).map(function(he) {
                return "   " + he;
              }).join(`
`))) : ue = z.stylize("[Circular]", "special")), D(ee)) {
                if (q && V.match(/^\d+$/))
                  return ue;
                ee = JSON.stringify("" + V), ee.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ee = ee.substr(1, ee.length - 2), ee = z.stylize(ee, "name")) : (ee = ee.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ee = z.stylize(ee, "string"));
              }
              return ee + ": " + ue;
            }
            function E(z, Z, oe) {
              var ye = z.reduce(function(V, q) {
                return q.indexOf(`
`) >= 0, V + q.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              return ye > 60 ? oe[0] + (Z === "" ? "" : Z + `
 `) + " " + z.join(`,
  `) + " " + oe[1] : oe[0] + Z + " " + z.join(", ") + " " + oe[1];
            }
            function T(z) {
              return Array.isArray(z);
            }
            n.isArray = T;
            function C(z) {
              return typeof z == "boolean";
            }
            n.isBoolean = C;
            function R(z) {
              return z === null;
            }
            n.isNull = R;
            function A(z) {
              return z == null;
            }
            n.isNullOrUndefined = A;
            function j(z) {
              return typeof z == "number";
            }
            n.isNumber = j;
            function N(z) {
              return typeof z == "string";
            }
            n.isString = N;
            function O(z) {
              return typeof z == "symbol";
            }
            n.isSymbol = O;
            function D(z) {
              return z === void 0;
            }
            n.isUndefined = D;
            function H(z) {
              return G(z) && $(z) === "[object RegExp]";
            }
            n.isRegExp = H;
            function G(z) {
              return typeof z == "object" && z !== null;
            }
            n.isObject = G;
            function X(z) {
              return G(z) && $(z) === "[object Date]";
            }
            n.isDate = X;
            function Q(z) {
              return G(z) && ($(z) === "[object Error]" || z instanceof Error);
            }
            n.isError = Q;
            function M(z) {
              return typeof z == "function";
            }
            n.isFunction = M;
            function k(z) {
              return z === null || typeof z == "boolean" || typeof z == "number" || typeof z == "string" || typeof z == "symbol" || // ES6 symbol
              typeof z > "u";
            }
            n.isPrimitive = k, n.isBuffer = r("./support/isBuffer");
            function $(z) {
              return Object.prototype.toString.call(z);
            }
            function ne(z) {
              return z < 10 ? "0" + z.toString(10) : z.toString(10);
            }
            var te = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function de() {
              var z = /* @__PURE__ */ new Date(), Z = [
                ne(z.getHours()),
                ne(z.getMinutes()),
                ne(z.getSeconds())
              ].join(":");
              return [z.getDate(), te[z.getMonth()], Z].join(" ");
            }
            n.log = function() {
              console.log("%s - %s", de(), n.format.apply(n, arguments));
            }, n.inherits = r("inherits"), n._extend = function(z, Z) {
              if (!Z || !G(Z)) return z;
              for (var oe = Object.keys(Z), ye = oe.length; ye--; )
                z[oe[ye]] = Z[oe[ye]];
              return z;
            };
            function ae(z, Z) {
              return Object.prototype.hasOwnProperty.call(z, Z);
            }
          }).call(this);
        }).call(this, r("_process"), typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = [
              "BigInt64Array",
              "BigUint64Array",
              "Float32Array",
              "Float64Array",
              "Int16Array",
              "Int32Array",
              "Int8Array",
              "Uint16Array",
              "Uint32Array",
              "Uint8Array",
              "Uint8ClampedArray"
            ], s = typeof globalThis > "u" ? i : globalThis;
            o.exports = function() {
              for (var p = [], l = 0; l < a.length; l++)
                typeof s[a[l]] == "function" && (p[p.length] = a[l]);
              return p;
            };
          }).call(this);
        }).call(this, typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 28: [function(r, o, n) {
        n.byteLength = u, n.toByteArray = y, n.fromByteArray = w;
        for (var i = [], a = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = 0, l = c.length; p < l; ++p)
          i[p] = c[p], a[c.charCodeAt(p)] = p;
        a[45] = 62, a[95] = 63;
        function d(x) {
          var E = x.length;
          if (E % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var T = x.indexOf("=");
          T === -1 && (T = E);
          var C = T === E ? 0 : 4 - T % 4;
          return [T, C];
        }
        function u(x) {
          var E = d(x), T = E[0], C = E[1];
          return (T + C) * 3 / 4 - C;
        }
        function h(x, E, T) {
          return (E + T) * 3 / 4 - T;
        }
        function y(x) {
          var E, T = d(x), C = T[0], R = T[1], A = new s(h(x, C, R)), j = 0, N = R > 0 ? C - 4 : C, O;
          for (O = 0; O < N; O += 4)
            E = a[x.charCodeAt(O)] << 18 | a[x.charCodeAt(O + 1)] << 12 | a[x.charCodeAt(O + 2)] << 6 | a[x.charCodeAt(O + 3)], A[j++] = E >> 16 & 255, A[j++] = E >> 8 & 255, A[j++] = E & 255;
          return R === 2 && (E = a[x.charCodeAt(O)] << 2 | a[x.charCodeAt(O + 1)] >> 4, A[j++] = E & 255), R === 1 && (E = a[x.charCodeAt(O)] << 10 | a[x.charCodeAt(O + 1)] << 4 | a[x.charCodeAt(O + 2)] >> 2, A[j++] = E >> 8 & 255, A[j++] = E & 255), A;
        }
        function f(x) {
          return i[x >> 18 & 63] + i[x >> 12 & 63] + i[x >> 6 & 63] + i[x & 63];
        }
        function b(x, E, T) {
          for (var C, R = [], A = E; A < T; A += 3)
            C = (x[A] << 16 & 16711680) + (x[A + 1] << 8 & 65280) + (x[A + 2] & 255), R.push(f(C));
          return R.join("");
        }
        function w(x) {
          for (var E, T = x.length, C = T % 3, R = [], A = 16383, j = 0, N = T - C; j < N; j += A)
            R.push(b(x, j, j + A > N ? N : j + A));
          return C === 1 ? (E = x[T - 1], R.push(
            i[E >> 2] + i[E << 4 & 63] + "=="
          )) : C === 2 && (E = (x[T - 2] << 8) + x[T - 1], R.push(
            i[E >> 10] + i[E >> 4 & 63] + i[E << 2 & 63] + "="
          )), R.join("");
        }
      }, {}], 29: [function(r, o, n) {
      }, {}], 30: [function(r, o, n) {
        (function(i, a) {
          (function() {
            var s = r("assert"), c = r("pako/lib/zlib/zstream"), p = r("pako/lib/zlib/deflate.js"), l = r("pako/lib/zlib/inflate.js"), d = r("pako/lib/zlib/constants");
            for (var u in d)
              n[u] = d[u];
            n.NONE = 0, n.DEFLATE = 1, n.INFLATE = 2, n.GZIP = 3, n.GUNZIP = 4, n.DEFLATERAW = 5, n.INFLATERAW = 6, n.UNZIP = 7;
            var h = 31, y = 139;
            function f(b) {
              if (typeof b != "number" || b < n.DEFLATE || b > n.UNZIP)
                throw new TypeError("Bad argument");
              this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = b, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
            }
            f.prototype.close = function() {
              if (this.write_in_progress) {
                this.pending_close = !0;
                return;
              }
              this.pending_close = !1, s(this.init_done, "close before init"), s(this.mode <= n.UNZIP), this.mode === n.DEFLATE || this.mode === n.GZIP || this.mode === n.DEFLATERAW ? p.deflateEnd(this.strm) : (this.mode === n.INFLATE || this.mode === n.GUNZIP || this.mode === n.INFLATERAW || this.mode === n.UNZIP) && l.inflateEnd(this.strm), this.mode = n.NONE, this.dictionary = null;
            }, f.prototype.write = function(b, w, x, E, T, C, R) {
              return this._write(!0, b, w, x, E, T, C, R);
            }, f.prototype.writeSync = function(b, w, x, E, T, C, R) {
              return this._write(!1, b, w, x, E, T, C, R);
            }, f.prototype._write = function(b, w, x, E, T, C, R, A) {
              if (s.equal(arguments.length, 8), s(this.init_done, "write before init"), s(this.mode !== n.NONE, "already finalized"), s.equal(!1, this.write_in_progress, "write already in progress"), s.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, s.equal(!1, w === void 0, "must provide flush value"), this.write_in_progress = !0, w !== n.Z_NO_FLUSH && w !== n.Z_PARTIAL_FLUSH && w !== n.Z_SYNC_FLUSH && w !== n.Z_FULL_FLUSH && w !== n.Z_FINISH && w !== n.Z_BLOCK)
                throw new Error("Invalid flush value");
              if (x == null && (x = a.alloc(0), T = 0, E = 0), this.strm.avail_in = T, this.strm.input = x, this.strm.next_in = E, this.strm.avail_out = A, this.strm.output = C, this.strm.next_out = R, this.flush = w, !b)
                return this._process(), this._checkError() ? this._afterSync() : void 0;
              var j = this;
              return i.nextTick(function() {
                j._process(), j._after();
              }), this;
            }, f.prototype._afterSync = function() {
              var b = this.strm.avail_out, w = this.strm.avail_in;
              return this.write_in_progress = !1, [w, b];
            }, f.prototype._process = function() {
              var b = null;
              switch (this.mode) {
                case n.DEFLATE:
                case n.GZIP:
                case n.DEFLATERAW:
                  this.err = p.deflate(this.strm, this.flush);
                  break;
                case n.UNZIP:
                  switch (this.strm.avail_in > 0 && (b = this.strm.next_in), this.gzip_id_bytes_read) {
                    case 0:
                      if (b === null)
                        break;
                      if (this.strm.input[b] === h) {
                        if (this.gzip_id_bytes_read = 1, b++, this.strm.avail_in === 1)
                          break;
                      } else {
                        this.mode = n.INFLATE;
                        break;
                      }
                    // fallthrough
                    case 1:
                      if (b === null)
                        break;
                      this.strm.input[b] === y ? (this.gzip_id_bytes_read = 2, this.mode = n.GUNZIP) : this.mode = n.INFLATE;
                      break;
                    default:
                      throw new Error("invalid number of gzip magic number bytes read");
                  }
                // fallthrough
                case n.INFLATE:
                case n.GUNZIP:
                case n.INFLATERAW:
                  for (this.err = l.inflate(
                    this.strm,
                    this.flush
                    // If data was encoded with dictionary
                  ), this.err === n.Z_NEED_DICT && this.dictionary && (this.err = l.inflateSetDictionary(this.strm, this.dictionary), this.err === n.Z_OK ? this.err = l.inflate(this.strm, this.flush) : this.err === n.Z_DATA_ERROR && (this.err = n.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === n.GUNZIP && this.err === n.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                    this.reset(), this.err = l.inflate(this.strm, this.flush);
                  break;
                default:
                  throw new Error("Unknown mode " + this.mode);
              }
            }, f.prototype._checkError = function() {
              switch (this.err) {
                case n.Z_OK:
                case n.Z_BUF_ERROR:
                  if (this.strm.avail_out !== 0 && this.flush === n.Z_FINISH)
                    return this._error("unexpected end of file"), !1;
                  break;
                case n.Z_STREAM_END:
                  break;
                case n.Z_NEED_DICT:
                  return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
                default:
                  return this._error("Zlib error"), !1;
              }
              return !0;
            }, f.prototype._after = function() {
              if (this._checkError()) {
                var b = this.strm.avail_out, w = this.strm.avail_in;
                this.write_in_progress = !1, this.callback(w, b), this.pending_close && this.close();
              }
            }, f.prototype._error = function(b) {
              this.strm.msg && (b = this.strm.msg), this.onerror(
                b,
                this.err
                // no hope of rescue.
              ), this.write_in_progress = !1, this.pending_close && this.close();
            }, f.prototype.init = function(b, w, x, E, T) {
              s(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), s(b >= 8 && b <= 15, "invalid windowBits"), s(w >= -1 && w <= 9, "invalid compression level"), s(x >= 1 && x <= 9, "invalid memlevel"), s(E === n.Z_FILTERED || E === n.Z_HUFFMAN_ONLY || E === n.Z_RLE || E === n.Z_FIXED || E === n.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(w, b, x, E, T), this._setDictionary();
            }, f.prototype.params = function() {
              throw new Error("deflateParams Not supported");
            }, f.prototype.reset = function() {
              this._reset(), this._setDictionary();
            }, f.prototype._init = function(b, w, x, E, T) {
              switch (this.level = b, this.windowBits = w, this.memLevel = x, this.strategy = E, this.flush = n.Z_NO_FLUSH, this.err = n.Z_OK, (this.mode === n.GZIP || this.mode === n.GUNZIP) && (this.windowBits += 16), this.mode === n.UNZIP && (this.windowBits += 32), (this.mode === n.DEFLATERAW || this.mode === n.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new c(), this.mode) {
                case n.DEFLATE:
                case n.GZIP:
                case n.DEFLATERAW:
                  this.err = p.deflateInit2(this.strm, this.level, n.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                  break;
                case n.INFLATE:
                case n.GUNZIP:
                case n.INFLATERAW:
                case n.UNZIP:
                  this.err = l.inflateInit2(this.strm, this.windowBits);
                  break;
                default:
                  throw new Error("Unknown mode " + this.mode);
              }
              this.err !== n.Z_OK && this._error("Init error"), this.dictionary = T, this.write_in_progress = !1, this.init_done = !0;
            }, f.prototype._setDictionary = function() {
              if (this.dictionary != null) {
                switch (this.err = n.Z_OK, this.mode) {
                  case n.DEFLATE:
                  case n.DEFLATERAW:
                    this.err = p.deflateSetDictionary(this.strm, this.dictionary);
                    break;
                }
                this.err !== n.Z_OK && this._error("Failed to set dictionary");
              }
            }, f.prototype._reset = function() {
              switch (this.err = n.Z_OK, this.mode) {
                case n.DEFLATE:
                case n.DEFLATERAW:
                case n.GZIP:
                  this.err = p.deflateReset(this.strm);
                  break;
                case n.INFLATE:
                case n.INFLATERAW:
                case n.GUNZIP:
                  this.err = l.inflateReset(this.strm);
                  break;
              }
              this.err !== n.Z_OK && this._error("Failed to reset stream");
            }, n.Zlib = f;
          }).call(this);
        }).call(this, r("_process"), r("buffer").Buffer);
      }, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = r("buffer").Buffer, s = r("stream").Transform, c = r("./binding"), p = r("util"), l = r("assert").ok, d = r("buffer").kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + d.toString(16) + " bytes";
            c.Z_MIN_WINDOWBITS = 8, c.Z_MAX_WINDOWBITS = 15, c.Z_DEFAULT_WINDOWBITS = 15, c.Z_MIN_CHUNK = 64, c.Z_MAX_CHUNK = 1 / 0, c.Z_DEFAULT_CHUNK = 16 * 1024, c.Z_MIN_MEMLEVEL = 1, c.Z_MAX_MEMLEVEL = 9, c.Z_DEFAULT_MEMLEVEL = 8, c.Z_MIN_LEVEL = -1, c.Z_MAX_LEVEL = 9, c.Z_DEFAULT_LEVEL = c.Z_DEFAULT_COMPRESSION;
            for (var h = Object.keys(c), y = 0; y < h.length; y++) {
              var f = h[y];
              f.match(/^Z/) && Object.defineProperty(n, f, {
                enumerable: !0,
                value: c[f],
                writable: !1
              });
            }
            for (var b = {
              Z_OK: c.Z_OK,
              Z_STREAM_END: c.Z_STREAM_END,
              Z_NEED_DICT: c.Z_NEED_DICT,
              Z_ERRNO: c.Z_ERRNO,
              Z_STREAM_ERROR: c.Z_STREAM_ERROR,
              Z_DATA_ERROR: c.Z_DATA_ERROR,
              Z_MEM_ERROR: c.Z_MEM_ERROR,
              Z_BUF_ERROR: c.Z_BUF_ERROR,
              Z_VERSION_ERROR: c.Z_VERSION_ERROR
            }, w = Object.keys(b), x = 0; x < w.length; x++) {
              var E = w[x];
              b[b[E]] = E;
            }
            Object.defineProperty(n, "codes", {
              enumerable: !0,
              value: Object.freeze(b),
              writable: !1
            }), n.Deflate = R, n.Inflate = A, n.Gzip = j, n.Gunzip = N, n.DeflateRaw = O, n.InflateRaw = D, n.Unzip = H, n.createDeflate = function(k) {
              return new R(k);
            }, n.createInflate = function(k) {
              return new A(k);
            }, n.createDeflateRaw = function(k) {
              return new O(k);
            }, n.createInflateRaw = function(k) {
              return new D(k);
            }, n.createGzip = function(k) {
              return new j(k);
            }, n.createGunzip = function(k) {
              return new N(k);
            }, n.createUnzip = function(k) {
              return new H(k);
            }, n.deflate = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new R($), k, ne);
            }, n.deflateSync = function(k, $) {
              return C(new R($), k);
            }, n.gzip = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new j($), k, ne);
            }, n.gzipSync = function(k, $) {
              return C(new j($), k);
            }, n.deflateRaw = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new O($), k, ne);
            }, n.deflateRawSync = function(k, $) {
              return C(new O($), k);
            }, n.unzip = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new H($), k, ne);
            }, n.unzipSync = function(k, $) {
              return C(new H($), k);
            }, n.inflate = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new A($), k, ne);
            }, n.inflateSync = function(k, $) {
              return C(new A($), k);
            }, n.gunzip = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new N($), k, ne);
            }, n.gunzipSync = function(k, $) {
              return C(new N($), k);
            }, n.inflateRaw = function(k, $, ne) {
              return typeof $ == "function" && (ne = $, $ = {}), T(new D($), k, ne);
            }, n.inflateRawSync = function(k, $) {
              return C(new D($), k);
            };
            function T(k, $, ne) {
              var te = [], de = 0;
              k.on("error", z), k.on("end", Z), k.end($), ae();
              function ae() {
                for (var oe; (oe = k.read()) !== null; )
                  te.push(oe), de += oe.length;
                k.once("readable", ae);
              }
              function z(oe) {
                k.removeListener("end", Z), k.removeListener("readable", ae), ne(oe);
              }
              function Z() {
                var oe, ye = null;
                de >= d ? ye = new RangeError(u) : oe = a.concat(te, de), te = [], k.close(), ne(ye, oe);
              }
            }
            function C(k, $) {
              if (typeof $ == "string" && ($ = a.from($)), !a.isBuffer($)) throw new TypeError("Not a string or buffer");
              var ne = k._finishFlushFlag;
              return k._processChunk($, ne);
            }
            function R(k) {
              if (!(this instanceof R)) return new R(k);
              X.call(this, k, c.DEFLATE);
            }
            function A(k) {
              if (!(this instanceof A)) return new A(k);
              X.call(this, k, c.INFLATE);
            }
            function j(k) {
              if (!(this instanceof j)) return new j(k);
              X.call(this, k, c.GZIP);
            }
            function N(k) {
              if (!(this instanceof N)) return new N(k);
              X.call(this, k, c.GUNZIP);
            }
            function O(k) {
              if (!(this instanceof O)) return new O(k);
              X.call(this, k, c.DEFLATERAW);
            }
            function D(k) {
              if (!(this instanceof D)) return new D(k);
              X.call(this, k, c.INFLATERAW);
            }
            function H(k) {
              if (!(this instanceof H)) return new H(k);
              X.call(this, k, c.UNZIP);
            }
            function G(k) {
              return k === c.Z_NO_FLUSH || k === c.Z_PARTIAL_FLUSH || k === c.Z_SYNC_FLUSH || k === c.Z_FULL_FLUSH || k === c.Z_FINISH || k === c.Z_BLOCK;
            }
            function X(k, $) {
              var ne = this;
              if (this._opts = k = k || {}, this._chunkSize = k.chunkSize || n.Z_DEFAULT_CHUNK, s.call(this, k), k.flush && !G(k.flush))
                throw new Error("Invalid flush flag: " + k.flush);
              if (k.finishFlush && !G(k.finishFlush))
                throw new Error("Invalid flush flag: " + k.finishFlush);
              if (this._flushFlag = k.flush || c.Z_NO_FLUSH, this._finishFlushFlag = typeof k.finishFlush < "u" ? k.finishFlush : c.Z_FINISH, k.chunkSize && (k.chunkSize < n.Z_MIN_CHUNK || k.chunkSize > n.Z_MAX_CHUNK))
                throw new Error("Invalid chunk size: " + k.chunkSize);
              if (k.windowBits && (k.windowBits < n.Z_MIN_WINDOWBITS || k.windowBits > n.Z_MAX_WINDOWBITS))
                throw new Error("Invalid windowBits: " + k.windowBits);
              if (k.level && (k.level < n.Z_MIN_LEVEL || k.level > n.Z_MAX_LEVEL))
                throw new Error("Invalid compression level: " + k.level);
              if (k.memLevel && (k.memLevel < n.Z_MIN_MEMLEVEL || k.memLevel > n.Z_MAX_MEMLEVEL))
                throw new Error("Invalid memLevel: " + k.memLevel);
              if (k.strategy && k.strategy != n.Z_FILTERED && k.strategy != n.Z_HUFFMAN_ONLY && k.strategy != n.Z_RLE && k.strategy != n.Z_FIXED && k.strategy != n.Z_DEFAULT_STRATEGY)
                throw new Error("Invalid strategy: " + k.strategy);
              if (k.dictionary && !a.isBuffer(k.dictionary))
                throw new Error("Invalid dictionary: it should be a Buffer instance");
              this._handle = new c.Zlib($);
              var te = this;
              this._hadError = !1, this._handle.onerror = function(z, Z) {
                Q(te), te._hadError = !0;
                var oe = new Error(z);
                oe.errno = Z, oe.code = n.codes[Z], te.emit("error", oe);
              };
              var de = n.Z_DEFAULT_COMPRESSION;
              typeof k.level == "number" && (de = k.level);
              var ae = n.Z_DEFAULT_STRATEGY;
              typeof k.strategy == "number" && (ae = k.strategy), this._handle.init(k.windowBits || n.Z_DEFAULT_WINDOWBITS, de, k.memLevel || n.Z_DEFAULT_MEMLEVEL, ae, k.dictionary), this._buffer = a.allocUnsafe(this._chunkSize), this._offset = 0, this._level = de, this._strategy = ae, this.once("end", this.close), Object.defineProperty(this, "_closed", {
                get: function() {
                  return !ne._handle;
                },
                configurable: !0,
                enumerable: !0
              });
            }
            p.inherits(X, s), X.prototype.params = function(k, $, ne) {
              if (k < n.Z_MIN_LEVEL || k > n.Z_MAX_LEVEL)
                throw new RangeError("Invalid compression level: " + k);
              if ($ != n.Z_FILTERED && $ != n.Z_HUFFMAN_ONLY && $ != n.Z_RLE && $ != n.Z_FIXED && $ != n.Z_DEFAULT_STRATEGY)
                throw new TypeError("Invalid strategy: " + $);
              if (this._level !== k || this._strategy !== $) {
                var te = this;
                this.flush(c.Z_SYNC_FLUSH, function() {
                  l(te._handle, "zlib binding closed"), te._handle.params(k, $), te._hadError || (te._level = k, te._strategy = $, ne && ne());
                });
              } else
                i.nextTick(ne);
            }, X.prototype.reset = function() {
              return l(this._handle, "zlib binding closed"), this._handle.reset();
            }, X.prototype._flush = function(k) {
              this._transform(a.alloc(0), "", k);
            }, X.prototype.flush = function(k, $) {
              var ne = this, te = this._writableState;
              (typeof k == "function" || k === void 0 && !$) && ($ = k, k = c.Z_FULL_FLUSH), te.ended ? $ && i.nextTick($) : te.ending ? $ && this.once("end", $) : te.needDrain ? $ && this.once("drain", function() {
                return ne.flush(k, $);
              }) : (this._flushFlag = k, this.write(a.alloc(0), "", $));
            }, X.prototype.close = function(k) {
              Q(this, k), i.nextTick(M, this);
            };
            function Q(k, $) {
              $ && i.nextTick($), k._handle && (k._handle.close(), k._handle = null);
            }
            function M(k) {
              k.emit("close");
            }
            X.prototype._transform = function(k, $, ne) {
              var te, de = this._writableState, ae = de.ending || de.ended, z = ae && (!k || de.length === k.length);
              if (k !== null && !a.isBuffer(k)) return ne(new Error("invalid input"));
              if (!this._handle) return ne(new Error("zlib binding closed"));
              z ? te = this._finishFlushFlag : (te = this._flushFlag, k.length >= de.length && (this._flushFlag = this._opts.flush || c.Z_NO_FLUSH)), this._processChunk(k, te, ne);
            }, X.prototype._processChunk = function(k, $, ne) {
              var te = k && k.length, de = this._chunkSize - this._offset, ae = 0, z = this, Z = typeof ne == "function";
              if (!Z) {
                var oe = [], ye = 0, V;
                this.on("error", function(he) {
                  V = he;
                }), l(this._handle, "zlib binding closed");
                do
                  var q = this._handle.writeSync(
                    $,
                    k,
                    // in
                    ae,
                    // in_off
                    te,
                    // in_len
                    this._buffer,
                    // out
                    this._offset,
                    //out_off
                    de
                  );
                while (!this._hadError && ge(q[0], q[1]));
                if (this._hadError)
                  throw V;
                if (ye >= d)
                  throw Q(this), new RangeError(u);
                var ee = a.concat(oe, ye);
                return Q(this), ee;
              }
              l(this._handle, "zlib binding closed");
              var ue = this._handle.write(
                $,
                k,
                // in
                ae,
                // in_off
                te,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                de
              );
              ue.buffer = k, ue.callback = ge;
              function ge(he, W) {
                if (this && (this.buffer = null, this.callback = null), !z._hadError) {
                  var Y = de - W;
                  if (l(Y >= 0, "have should not go down"), Y > 0) {
                    var se = z._buffer.slice(z._offset, z._offset + Y);
                    z._offset += Y, Z ? z.push(se) : (oe.push(se), ye += se.length);
                  }
                  if ((W === 0 || z._offset >= z._chunkSize) && (de = z._chunkSize, z._offset = 0, z._buffer = a.allocUnsafe(z._chunkSize)), W === 0) {
                    if (ae += te - he, te = he, !Z) return !0;
                    var Te = z._handle.write($, k, ae, te, z._buffer, z._offset, z._chunkSize);
                    Te.callback = ge, Te.buffer = k;
                    return;
                  }
                  if (!Z) return !1;
                  ne();
                }
              }
            }, p.inherits(R, X), p.inherits(A, X), p.inherits(j, X), p.inherits(N, X), p.inherits(O, X), p.inherits(D, X), p.inherits(H, X);
          }).call(this);
        }).call(this, r("_process"));
      }, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = r("base64-js"), s = r("ieee754");
            n.Buffer = d, n.SlowBuffer = C, n.INSPECT_MAX_BYTES = 50;
            var c = 2147483647;
            n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = p(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
              "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
            );
            function p() {
              try {
                var _ = new Uint8Array(1);
                return _.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, _.foo() === 42;
              } catch {
                return !1;
              }
            }
            Object.defineProperty(d.prototype, "parent", {
              enumerable: !0,
              get: function() {
                if (d.isBuffer(this))
                  return this.buffer;
              }
            }), Object.defineProperty(d.prototype, "offset", {
              enumerable: !0,
              get: function() {
                if (d.isBuffer(this))
                  return this.byteOffset;
              }
            });
            function l(_) {
              if (_ > c)
                throw new RangeError('The value "' + _ + '" is invalid for option "size"');
              var v = new Uint8Array(_);
              return v.__proto__ = d.prototype, v;
            }
            function d(_, v, S) {
              if (typeof _ == "number") {
                if (typeof v == "string")
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return f(_);
              }
              return u(_, v, S);
            }
            typeof Symbol < "u" && Symbol.species != null && d[Symbol.species] === d && Object.defineProperty(d, Symbol.species, {
              value: null,
              configurable: !0,
              enumerable: !1,
              writable: !1
            }), d.poolSize = 8192;
            function u(_, v, S) {
              if (typeof _ == "string")
                return b(_, v);
              if (ArrayBuffer.isView(_))
                return w(_);
              if (_ == null)
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
                );
              if (B(_, ArrayBuffer) || _ && B(_.buffer, ArrayBuffer))
                return x(_, v, S);
              if (typeof _ == "number")
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              var P = _.valueOf && _.valueOf();
              if (P != null && P !== _)
                return d.from(P, v, S);
              var J = E(_);
              if (J) return J;
              if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof _[Symbol.toPrimitive] == "function")
                return d.from(
                  _[Symbol.toPrimitive]("string"),
                  v,
                  S
                );
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
              );
            }
            d.from = function(_, v, S) {
              return u(_, v, S);
            }, d.prototype.__proto__ = Uint8Array.prototype, d.__proto__ = Uint8Array;
            function h(_) {
              if (typeof _ != "number")
                throw new TypeError('"size" argument must be of type number');
              if (_ < 0)
                throw new RangeError('The value "' + _ + '" is invalid for option "size"');
            }
            function y(_, v, S) {
              return h(_), _ <= 0 ? l(_) : v !== void 0 ? typeof S == "string" ? l(_).fill(v, S) : l(_).fill(v) : l(_);
            }
            d.alloc = function(_, v, S) {
              return y(_, v, S);
            };
            function f(_) {
              return h(_), l(_ < 0 ? 0 : T(_) | 0);
            }
            d.allocUnsafe = function(_) {
              return f(_);
            }, d.allocUnsafeSlow = function(_) {
              return f(_);
            };
            function b(_, v) {
              if ((typeof v != "string" || v === "") && (v = "utf8"), !d.isEncoding(v))
                throw new TypeError("Unknown encoding: " + v);
              var S = R(_, v) | 0, P = l(S), J = P.write(_, v);
              return J !== S && (P = P.slice(0, J)), P;
            }
            function w(_) {
              for (var v = _.length < 0 ? 0 : T(_.length) | 0, S = l(v), P = 0; P < v; P += 1)
                S[P] = _[P] & 255;
              return S;
            }
            function x(_, v, S) {
              if (v < 0 || _.byteLength < v)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (_.byteLength < v + (S || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var P;
              return v === void 0 && S === void 0 ? P = new Uint8Array(_) : S === void 0 ? P = new Uint8Array(_, v) : P = new Uint8Array(_, v, S), P.__proto__ = d.prototype, P;
            }
            function E(_) {
              if (d.isBuffer(_)) {
                var v = T(_.length) | 0, S = l(v);
                return S.length === 0 || _.copy(S, 0, 0, v), S;
              }
              if (_.length !== void 0)
                return typeof _.length != "number" || U(_.length) ? l(0) : w(_);
              if (_.type === "Buffer" && Array.isArray(_.data))
                return w(_.data);
            }
            function T(_) {
              if (_ >= c)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
              return _ | 0;
            }
            function C(_) {
              return +_ != _ && (_ = 0), d.alloc(+_);
            }
            d.isBuffer = function(v) {
              return v != null && v._isBuffer === !0 && v !== d.prototype;
            }, d.compare = function(v, S) {
              if (B(v, Uint8Array) && (v = d.from(v, v.offset, v.byteLength)), B(S, Uint8Array) && (S = d.from(S, S.offset, S.byteLength)), !d.isBuffer(v) || !d.isBuffer(S))
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              if (v === S) return 0;
              for (var P = v.length, J = S.length, ve = 0, Re = Math.min(P, J); ve < Re; ++ve)
                if (v[ve] !== S[ve]) {
                  P = v[ve], J = S[ve];
                  break;
                }
              return P < J ? -1 : J < P ? 1 : 0;
            }, d.isEncoding = function(v) {
              switch (String(v).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }, d.concat = function(v, S) {
              if (!Array.isArray(v))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (v.length === 0)
                return d.alloc(0);
              var P;
              if (S === void 0)
                for (S = 0, P = 0; P < v.length; ++P)
                  S += v[P].length;
              var J = d.allocUnsafe(S), ve = 0;
              for (P = 0; P < v.length; ++P) {
                var Re = v[P];
                if (B(Re, Uint8Array) && (Re = d.from(Re)), !d.isBuffer(Re))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                Re.copy(J, ve), ve += Re.length;
              }
              return J;
            };
            function R(_, v) {
              if (d.isBuffer(_))
                return _.length;
              if (ArrayBuffer.isView(_) || B(_, ArrayBuffer))
                return _.byteLength;
              if (typeof _ != "string")
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof _
                );
              var S = _.length, P = arguments.length > 2 && arguments[2] === !0;
              if (!P && S === 0) return 0;
              for (var J = !1; ; )
                switch (v) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return S;
                  case "utf8":
                  case "utf-8":
                    return W(_).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return S * 2;
                  case "hex":
                    return S >>> 1;
                  case "base64":
                    return Te(_).length;
                  default:
                    if (J)
                      return P ? -1 : W(_).length;
                    v = ("" + v).toLowerCase(), J = !0;
                }
            }
            d.byteLength = R;
            function A(_, v, S) {
              var P = !1;
              if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, v >>>= 0, S <= v))
                return "";
              for (_ || (_ = "utf8"); ; )
                switch (_) {
                  case "hex":
                    return z(this, v, S);
                  case "utf8":
                  case "utf-8":
                    return $(this, v, S);
                  case "ascii":
                    return de(this, v, S);
                  case "latin1":
                  case "binary":
                    return ae(this, v, S);
                  case "base64":
                    return k(this, v, S);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return Z(this, v, S);
                  default:
                    if (P) throw new TypeError("Unknown encoding: " + _);
                    _ = (_ + "").toLowerCase(), P = !0;
                }
            }
            d.prototype._isBuffer = !0;
            function j(_, v, S) {
              var P = _[v];
              _[v] = _[S], _[S] = P;
            }
            d.prototype.swap16 = function() {
              var v = this.length;
              if (v % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var S = 0; S < v; S += 2)
                j(this, S, S + 1);
              return this;
            }, d.prototype.swap32 = function() {
              var v = this.length;
              if (v % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var S = 0; S < v; S += 4)
                j(this, S, S + 3), j(this, S + 1, S + 2);
              return this;
            }, d.prototype.swap64 = function() {
              var v = this.length;
              if (v % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var S = 0; S < v; S += 8)
                j(this, S, S + 7), j(this, S + 1, S + 6), j(this, S + 2, S + 5), j(this, S + 3, S + 4);
              return this;
            }, d.prototype.toString = function() {
              var v = this.length;
              return v === 0 ? "" : arguments.length === 0 ? $(this, 0, v) : A.apply(this, arguments);
            }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(v) {
              if (!d.isBuffer(v)) throw new TypeError("Argument must be a Buffer");
              return this === v ? !0 : d.compare(this, v) === 0;
            }, d.prototype.inspect = function() {
              var v = "", S = n.INSPECT_MAX_BYTES;
              return v = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (v += " ... "), "<Buffer " + v + ">";
            }, d.prototype.compare = function(v, S, P, J, ve) {
              if (B(v, Uint8Array) && (v = d.from(v, v.offset, v.byteLength)), !d.isBuffer(v))
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof v
                );
              if (S === void 0 && (S = 0), P === void 0 && (P = v ? v.length : 0), J === void 0 && (J = 0), ve === void 0 && (ve = this.length), S < 0 || P > v.length || J < 0 || ve > this.length)
                throw new RangeError("out of range index");
              if (J >= ve && S >= P)
                return 0;
              if (J >= ve)
                return -1;
              if (S >= P)
                return 1;
              if (S >>>= 0, P >>>= 0, J >>>= 0, ve >>>= 0, this === v) return 0;
              for (var Re = ve - J, je = P - S, qe = Math.min(Re, je), ze = this.slice(J, ve), We = v.slice(S, P), Fe = 0; Fe < qe; ++Fe)
                if (ze[Fe] !== We[Fe]) {
                  Re = ze[Fe], je = We[Fe];
                  break;
                }
              return Re < je ? -1 : je < Re ? 1 : 0;
            };
            function N(_, v, S, P, J) {
              if (_.length === 0) return -1;
              if (typeof S == "string" ? (P = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, U(S) && (S = J ? 0 : _.length - 1), S < 0 && (S = _.length + S), S >= _.length) {
                if (J) return -1;
                S = _.length - 1;
              } else if (S < 0)
                if (J) S = 0;
                else return -1;
              if (typeof v == "string" && (v = d.from(v, P)), d.isBuffer(v))
                return v.length === 0 ? -1 : O(_, v, S, P, J);
              if (typeof v == "number")
                return v = v & 255, typeof Uint8Array.prototype.indexOf == "function" ? J ? Uint8Array.prototype.indexOf.call(_, v, S) : Uint8Array.prototype.lastIndexOf.call(_, v, S) : O(_, [v], S, P, J);
              throw new TypeError("val must be string, number or Buffer");
            }
            function O(_, v, S, P, J) {
              var ve = 1, Re = _.length, je = v.length;
              if (P !== void 0 && (P = String(P).toLowerCase(), P === "ucs2" || P === "ucs-2" || P === "utf16le" || P === "utf-16le")) {
                if (_.length < 2 || v.length < 2)
                  return -1;
                ve = 2, Re /= 2, je /= 2, S /= 2;
              }
              function qe(Ge, Je) {
                return ve === 1 ? Ge[Je] : Ge.readUInt16BE(Je * ve);
              }
              var ze;
              if (J) {
                var We = -1;
                for (ze = S; ze < Re; ze++)
                  if (qe(_, ze) === qe(v, We === -1 ? 0 : ze - We)) {
                    if (We === -1 && (We = ze), ze - We + 1 === je) return We * ve;
                  } else
                    We !== -1 && (ze -= ze - We), We = -1;
              } else
                for (S + je > Re && (S = Re - je), ze = S; ze >= 0; ze--) {
                  for (var Fe = !0, rt = 0; rt < je; rt++)
                    if (qe(_, ze + rt) !== qe(v, rt)) {
                      Fe = !1;
                      break;
                    }
                  if (Fe) return ze;
                }
              return -1;
            }
            d.prototype.includes = function(v, S, P) {
              return this.indexOf(v, S, P) !== -1;
            }, d.prototype.indexOf = function(v, S, P) {
              return N(this, v, S, P, !0);
            }, d.prototype.lastIndexOf = function(v, S, P) {
              return N(this, v, S, P, !1);
            };
            function D(_, v, S, P) {
              S = Number(S) || 0;
              var J = _.length - S;
              P ? (P = Number(P), P > J && (P = J)) : P = J;
              var ve = v.length;
              P > ve / 2 && (P = ve / 2);
              for (var Re = 0; Re < P; ++Re) {
                var je = parseInt(v.substr(Re * 2, 2), 16);
                if (U(je)) return Re;
                _[S + Re] = je;
              }
              return Re;
            }
            function H(_, v, S, P) {
              return Oe(W(v, _.length - S), _, S, P);
            }
            function G(_, v, S, P) {
              return Oe(Y(v), _, S, P);
            }
            function X(_, v, S, P) {
              return G(_, v, S, P);
            }
            function Q(_, v, S, P) {
              return Oe(Te(v), _, S, P);
            }
            function M(_, v, S, P) {
              return Oe(se(v, _.length - S), _, S, P);
            }
            d.prototype.write = function(v, S, P, J) {
              if (S === void 0)
                J = "utf8", P = this.length, S = 0;
              else if (P === void 0 && typeof S == "string")
                J = S, P = this.length, S = 0;
              else if (isFinite(S))
                S = S >>> 0, isFinite(P) ? (P = P >>> 0, J === void 0 && (J = "utf8")) : (J = P, P = void 0);
              else
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              var ve = this.length - S;
              if ((P === void 0 || P > ve) && (P = ve), v.length > 0 && (P < 0 || S < 0) || S > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              J || (J = "utf8");
              for (var Re = !1; ; )
                switch (J) {
                  case "hex":
                    return D(this, v, S, P);
                  case "utf8":
                  case "utf-8":
                    return H(this, v, S, P);
                  case "ascii":
                    return G(this, v, S, P);
                  case "latin1":
                  case "binary":
                    return X(this, v, S, P);
                  case "base64":
                    return Q(this, v, S, P);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, v, S, P);
                  default:
                    if (Re) throw new TypeError("Unknown encoding: " + J);
                    J = ("" + J).toLowerCase(), Re = !0;
                }
            }, d.prototype.toJSON = function() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function k(_, v, S) {
              return v === 0 && S === _.length ? a.fromByteArray(_) : a.fromByteArray(_.slice(v, S));
            }
            function $(_, v, S) {
              S = Math.min(_.length, S);
              for (var P = [], J = v; J < S; ) {
                var ve = _[J], Re = null, je = ve > 239 ? 4 : ve > 223 ? 3 : ve > 191 ? 2 : 1;
                if (J + je <= S) {
                  var qe, ze, We, Fe;
                  switch (je) {
                    case 1:
                      ve < 128 && (Re = ve);
                      break;
                    case 2:
                      qe = _[J + 1], (qe & 192) === 128 && (Fe = (ve & 31) << 6 | qe & 63, Fe > 127 && (Re = Fe));
                      break;
                    case 3:
                      qe = _[J + 1], ze = _[J + 2], (qe & 192) === 128 && (ze & 192) === 128 && (Fe = (ve & 15) << 12 | (qe & 63) << 6 | ze & 63, Fe > 2047 && (Fe < 55296 || Fe > 57343) && (Re = Fe));
                      break;
                    case 4:
                      qe = _[J + 1], ze = _[J + 2], We = _[J + 3], (qe & 192) === 128 && (ze & 192) === 128 && (We & 192) === 128 && (Fe = (ve & 15) << 18 | (qe & 63) << 12 | (ze & 63) << 6 | We & 63, Fe > 65535 && Fe < 1114112 && (Re = Fe));
                  }
                }
                Re === null ? (Re = 65533, je = 1) : Re > 65535 && (Re -= 65536, P.push(Re >>> 10 & 1023 | 55296), Re = 56320 | Re & 1023), P.push(Re), J += je;
              }
              return te(P);
            }
            var ne = 4096;
            function te(_) {
              var v = _.length;
              if (v <= ne)
                return String.fromCharCode.apply(String, _);
              for (var S = "", P = 0; P < v; )
                S += String.fromCharCode.apply(
                  String,
                  _.slice(P, P += ne)
                );
              return S;
            }
            function de(_, v, S) {
              var P = "";
              S = Math.min(_.length, S);
              for (var J = v; J < S; ++J)
                P += String.fromCharCode(_[J] & 127);
              return P;
            }
            function ae(_, v, S) {
              var P = "";
              S = Math.min(_.length, S);
              for (var J = v; J < S; ++J)
                P += String.fromCharCode(_[J]);
              return P;
            }
            function z(_, v, S) {
              var P = _.length;
              (!v || v < 0) && (v = 0), (!S || S < 0 || S > P) && (S = P);
              for (var J = "", ve = v; ve < S; ++ve)
                J += he(_[ve]);
              return J;
            }
            function Z(_, v, S) {
              for (var P = _.slice(v, S), J = "", ve = 0; ve < P.length; ve += 2)
                J += String.fromCharCode(P[ve] + P[ve + 1] * 256);
              return J;
            }
            d.prototype.slice = function(v, S) {
              var P = this.length;
              v = ~~v, S = S === void 0 ? P : ~~S, v < 0 ? (v += P, v < 0 && (v = 0)) : v > P && (v = P), S < 0 ? (S += P, S < 0 && (S = 0)) : S > P && (S = P), S < v && (S = v);
              var J = this.subarray(v, S);
              return J.__proto__ = d.prototype, J;
            };
            function oe(_, v, S) {
              if (_ % 1 !== 0 || _ < 0) throw new RangeError("offset is not uint");
              if (_ + v > S) throw new RangeError("Trying to access beyond buffer length");
            }
            d.prototype.readUIntLE = function(v, S, P) {
              v = v >>> 0, S = S >>> 0, P || oe(v, S, this.length);
              for (var J = this[v], ve = 1, Re = 0; ++Re < S && (ve *= 256); )
                J += this[v + Re] * ve;
              return J;
            }, d.prototype.readUIntBE = function(v, S, P) {
              v = v >>> 0, S = S >>> 0, P || oe(v, S, this.length);
              for (var J = this[v + --S], ve = 1; S > 0 && (ve *= 256); )
                J += this[v + --S] * ve;
              return J;
            }, d.prototype.readUInt8 = function(v, S) {
              return v = v >>> 0, S || oe(v, 1, this.length), this[v];
            }, d.prototype.readUInt16LE = function(v, S) {
              return v = v >>> 0, S || oe(v, 2, this.length), this[v] | this[v + 1] << 8;
            }, d.prototype.readUInt16BE = function(v, S) {
              return v = v >>> 0, S || oe(v, 2, this.length), this[v] << 8 | this[v + 1];
            }, d.prototype.readUInt32LE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216;
            }, d.prototype.readUInt32BE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]);
            }, d.prototype.readIntLE = function(v, S, P) {
              v = v >>> 0, S = S >>> 0, P || oe(v, S, this.length);
              for (var J = this[v], ve = 1, Re = 0; ++Re < S && (ve *= 256); )
                J += this[v + Re] * ve;
              return ve *= 128, J >= ve && (J -= Math.pow(2, 8 * S)), J;
            }, d.prototype.readIntBE = function(v, S, P) {
              v = v >>> 0, S = S >>> 0, P || oe(v, S, this.length);
              for (var J = S, ve = 1, Re = this[v + --J]; J > 0 && (ve *= 256); )
                Re += this[v + --J] * ve;
              return ve *= 128, Re >= ve && (Re -= Math.pow(2, 8 * S)), Re;
            }, d.prototype.readInt8 = function(v, S) {
              return v = v >>> 0, S || oe(v, 1, this.length), this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v];
            }, d.prototype.readInt16LE = function(v, S) {
              v = v >>> 0, S || oe(v, 2, this.length);
              var P = this[v] | this[v + 1] << 8;
              return P & 32768 ? P | 4294901760 : P;
            }, d.prototype.readInt16BE = function(v, S) {
              v = v >>> 0, S || oe(v, 2, this.length);
              var P = this[v + 1] | this[v] << 8;
              return P & 32768 ? P | 4294901760 : P;
            }, d.prototype.readInt32LE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24;
            }, d.prototype.readInt32BE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3];
            }, d.prototype.readFloatLE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), s.read(this, v, !0, 23, 4);
            }, d.prototype.readFloatBE = function(v, S) {
              return v = v >>> 0, S || oe(v, 4, this.length), s.read(this, v, !1, 23, 4);
            }, d.prototype.readDoubleLE = function(v, S) {
              return v = v >>> 0, S || oe(v, 8, this.length), s.read(this, v, !0, 52, 8);
            }, d.prototype.readDoubleBE = function(v, S) {
              return v = v >>> 0, S || oe(v, 8, this.length), s.read(this, v, !1, 52, 8);
            };
            function ye(_, v, S, P, J, ve) {
              if (!d.isBuffer(_)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (v > J || v < ve) throw new RangeError('"value" argument is out of bounds');
              if (S + P > _.length) throw new RangeError("Index out of range");
            }
            d.prototype.writeUIntLE = function(v, S, P, J) {
              if (v = +v, S = S >>> 0, P = P >>> 0, !J) {
                var ve = Math.pow(2, 8 * P) - 1;
                ye(this, v, S, P, ve, 0);
              }
              var Re = 1, je = 0;
              for (this[S] = v & 255; ++je < P && (Re *= 256); )
                this[S + je] = v / Re & 255;
              return S + P;
            }, d.prototype.writeUIntBE = function(v, S, P, J) {
              if (v = +v, S = S >>> 0, P = P >>> 0, !J) {
                var ve = Math.pow(2, 8 * P) - 1;
                ye(this, v, S, P, ve, 0);
              }
              var Re = P - 1, je = 1;
              for (this[S + Re] = v & 255; --Re >= 0 && (je *= 256); )
                this[S + Re] = v / je & 255;
              return S + P;
            }, d.prototype.writeUInt8 = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 1, 255, 0), this[S] = v & 255, S + 1;
            }, d.prototype.writeUInt16LE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 2, 65535, 0), this[S] = v & 255, this[S + 1] = v >>> 8, S + 2;
            }, d.prototype.writeUInt16BE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 2, 65535, 0), this[S] = v >>> 8, this[S + 1] = v & 255, S + 2;
            }, d.prototype.writeUInt32LE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 4, 4294967295, 0), this[S + 3] = v >>> 24, this[S + 2] = v >>> 16, this[S + 1] = v >>> 8, this[S] = v & 255, S + 4;
            }, d.prototype.writeUInt32BE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 4, 4294967295, 0), this[S] = v >>> 24, this[S + 1] = v >>> 16, this[S + 2] = v >>> 8, this[S + 3] = v & 255, S + 4;
            }, d.prototype.writeIntLE = function(v, S, P, J) {
              if (v = +v, S = S >>> 0, !J) {
                var ve = Math.pow(2, 8 * P - 1);
                ye(this, v, S, P, ve - 1, -ve);
              }
              var Re = 0, je = 1, qe = 0;
              for (this[S] = v & 255; ++Re < P && (je *= 256); )
                v < 0 && qe === 0 && this[S + Re - 1] !== 0 && (qe = 1), this[S + Re] = (v / je >> 0) - qe & 255;
              return S + P;
            }, d.prototype.writeIntBE = function(v, S, P, J) {
              if (v = +v, S = S >>> 0, !J) {
                var ve = Math.pow(2, 8 * P - 1);
                ye(this, v, S, P, ve - 1, -ve);
              }
              var Re = P - 1, je = 1, qe = 0;
              for (this[S + Re] = v & 255; --Re >= 0 && (je *= 256); )
                v < 0 && qe === 0 && this[S + Re + 1] !== 0 && (qe = 1), this[S + Re] = (v / je >> 0) - qe & 255;
              return S + P;
            }, d.prototype.writeInt8 = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 1, 127, -128), v < 0 && (v = 255 + v + 1), this[S] = v & 255, S + 1;
            }, d.prototype.writeInt16LE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 2, 32767, -32768), this[S] = v & 255, this[S + 1] = v >>> 8, S + 2;
            }, d.prototype.writeInt16BE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 2, 32767, -32768), this[S] = v >>> 8, this[S + 1] = v & 255, S + 2;
            }, d.prototype.writeInt32LE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 4, 2147483647, -2147483648), this[S] = v & 255, this[S + 1] = v >>> 8, this[S + 2] = v >>> 16, this[S + 3] = v >>> 24, S + 4;
            }, d.prototype.writeInt32BE = function(v, S, P) {
              return v = +v, S = S >>> 0, P || ye(this, v, S, 4, 2147483647, -2147483648), v < 0 && (v = 4294967295 + v + 1), this[S] = v >>> 24, this[S + 1] = v >>> 16, this[S + 2] = v >>> 8, this[S + 3] = v & 255, S + 4;
            };
            function V(_, v, S, P, J, ve) {
              if (S + P > _.length) throw new RangeError("Index out of range");
              if (S < 0) throw new RangeError("Index out of range");
            }
            function q(_, v, S, P, J) {
              return v = +v, S = S >>> 0, J || V(_, v, S, 4), s.write(_, v, S, P, 23, 4), S + 4;
            }
            d.prototype.writeFloatLE = function(v, S, P) {
              return q(this, v, S, !0, P);
            }, d.prototype.writeFloatBE = function(v, S, P) {
              return q(this, v, S, !1, P);
            };
            function ee(_, v, S, P, J) {
              return v = +v, S = S >>> 0, J || V(_, v, S, 8), s.write(_, v, S, P, 52, 8), S + 8;
            }
            d.prototype.writeDoubleLE = function(v, S, P) {
              return ee(this, v, S, !0, P);
            }, d.prototype.writeDoubleBE = function(v, S, P) {
              return ee(this, v, S, !1, P);
            }, d.prototype.copy = function(v, S, P, J) {
              if (!d.isBuffer(v)) throw new TypeError("argument should be a Buffer");
              if (P || (P = 0), !J && J !== 0 && (J = this.length), S >= v.length && (S = v.length), S || (S = 0), J > 0 && J < P && (J = P), J === P || v.length === 0 || this.length === 0) return 0;
              if (S < 0)
                throw new RangeError("targetStart out of bounds");
              if (P < 0 || P >= this.length) throw new RangeError("Index out of range");
              if (J < 0) throw new RangeError("sourceEnd out of bounds");
              J > this.length && (J = this.length), v.length - S < J - P && (J = v.length - S + P);
              var ve = J - P;
              if (this === v && typeof Uint8Array.prototype.copyWithin == "function")
                this.copyWithin(S, P, J);
              else if (this === v && P < S && S < J)
                for (var Re = ve - 1; Re >= 0; --Re)
                  v[Re + S] = this[Re + P];
              else
                Uint8Array.prototype.set.call(
                  v,
                  this.subarray(P, J),
                  S
                );
              return ve;
            }, d.prototype.fill = function(v, S, P, J) {
              if (typeof v == "string") {
                if (typeof S == "string" ? (J = S, S = 0, P = this.length) : typeof P == "string" && (J = P, P = this.length), J !== void 0 && typeof J != "string")
                  throw new TypeError("encoding must be a string");
                if (typeof J == "string" && !d.isEncoding(J))
                  throw new TypeError("Unknown encoding: " + J);
                if (v.length === 1) {
                  var ve = v.charCodeAt(0);
                  (J === "utf8" && ve < 128 || J === "latin1") && (v = ve);
                }
              } else typeof v == "number" && (v = v & 255);
              if (S < 0 || this.length < S || this.length < P)
                throw new RangeError("Out of range index");
              if (P <= S)
                return this;
              S = S >>> 0, P = P === void 0 ? this.length : P >>> 0, v || (v = 0);
              var Re;
              if (typeof v == "number")
                for (Re = S; Re < P; ++Re)
                  this[Re] = v;
              else {
                var je = d.isBuffer(v) ? v : d.from(v, J), qe = je.length;
                if (qe === 0)
                  throw new TypeError('The value "' + v + '" is invalid for argument "value"');
                for (Re = 0; Re < P - S; ++Re)
                  this[Re + S] = je[Re % qe];
              }
              return this;
            };
            var ue = /[^+/0-9A-Za-z-_]/g;
            function ge(_) {
              if (_ = _.split("=")[0], _ = _.trim().replace(ue, ""), _.length < 2) return "";
              for (; _.length % 4 !== 0; )
                _ = _ + "=";
              return _;
            }
            function he(_) {
              return _ < 16 ? "0" + _.toString(16) : _.toString(16);
            }
            function W(_, v) {
              v = v || 1 / 0;
              for (var S, P = _.length, J = null, ve = [], Re = 0; Re < P; ++Re) {
                if (S = _.charCodeAt(Re), S > 55295 && S < 57344) {
                  if (!J) {
                    if (S > 56319) {
                      (v -= 3) > -1 && ve.push(239, 191, 189);
                      continue;
                    } else if (Re + 1 === P) {
                      (v -= 3) > -1 && ve.push(239, 191, 189);
                      continue;
                    }
                    J = S;
                    continue;
                  }
                  if (S < 56320) {
                    (v -= 3) > -1 && ve.push(239, 191, 189), J = S;
                    continue;
                  }
                  S = (J - 55296 << 10 | S - 56320) + 65536;
                } else J && (v -= 3) > -1 && ve.push(239, 191, 189);
                if (J = null, S < 128) {
                  if ((v -= 1) < 0) break;
                  ve.push(S);
                } else if (S < 2048) {
                  if ((v -= 2) < 0) break;
                  ve.push(
                    S >> 6 | 192,
                    S & 63 | 128
                  );
                } else if (S < 65536) {
                  if ((v -= 3) < 0) break;
                  ve.push(
                    S >> 12 | 224,
                    S >> 6 & 63 | 128,
                    S & 63 | 128
                  );
                } else if (S < 1114112) {
                  if ((v -= 4) < 0) break;
                  ve.push(
                    S >> 18 | 240,
                    S >> 12 & 63 | 128,
                    S >> 6 & 63 | 128,
                    S & 63 | 128
                  );
                } else
                  throw new Error("Invalid code point");
              }
              return ve;
            }
            function Y(_) {
              for (var v = [], S = 0; S < _.length; ++S)
                v.push(_.charCodeAt(S) & 255);
              return v;
            }
            function se(_, v) {
              for (var S, P, J, ve = [], Re = 0; Re < _.length && !((v -= 2) < 0); ++Re)
                S = _.charCodeAt(Re), P = S >> 8, J = S % 256, ve.push(J), ve.push(P);
              return ve;
            }
            function Te(_) {
              return a.toByteArray(ge(_));
            }
            function Oe(_, v, S, P) {
              for (var J = 0; J < P && !(J + S >= v.length || J >= _.length); ++J)
                v[J + S] = _[J];
              return J;
            }
            function B(_, v) {
              return _ instanceof v || _ != null && _.constructor != null && _.constructor.name != null && _.constructor.name === v.name;
            }
            function U(_) {
              return _ !== _;
            }
          }).call(this);
        }).call(this, r("buffer").Buffer);
      }, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(r, o, n) {
        var i = r("get-intrinsic"), a = r("./"), s = a(i("String.prototype.indexOf"));
        o.exports = function(p, l) {
          var d = i(p, !!l);
          return typeof d == "function" && s(p, ".prototype.") > -1 ? a(d) : d;
        };
      }, { "./": 34, "get-intrinsic": 39 }], 34: [function(r, o, n) {
        var i = r("function-bind"), a = r("get-intrinsic"), s = a("%Function.prototype.apply%"), c = a("%Function.prototype.call%"), p = a("%Reflect.apply%", !0) || i.call(c, s), l = a("%Object.getOwnPropertyDescriptor%", !0), d = a("%Object.defineProperty%", !0), u = a("%Math.max%");
        if (d)
          try {
            d({}, "a", { value: 1 });
          } catch {
            d = null;
          }
        o.exports = function(f) {
          var b = p(i, c, arguments);
          if (l && d) {
            var w = l(b, "length");
            w.configurable && d(
              b,
              "length",
              { value: 1 + u(0, f.length - (arguments.length - 1)) }
            );
          }
          return b;
        };
        var h = function() {
          return p(i, s, arguments);
        };
        d ? d(o.exports, "apply", { value: h }) : o.exports.apply = h;
      }, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(r, o, n) {
        var i = typeof Reflect == "object" ? Reflect : null, a = i && typeof i.apply == "function" ? i.apply : function(O, D, H) {
          return Function.prototype.apply.call(O, D, H);
        }, s;
        i && typeof i.ownKeys == "function" ? s = i.ownKeys : Object.getOwnPropertySymbols ? s = function(O) {
          return Object.getOwnPropertyNames(O).concat(Object.getOwnPropertySymbols(O));
        } : s = function(O) {
          return Object.getOwnPropertyNames(O);
        };
        function c(N) {
          console && console.warn && console.warn(N);
        }
        var p = Number.isNaN || function(O) {
          return O !== O;
        };
        function l() {
          l.init.call(this);
        }
        o.exports = l, o.exports.once = R, l.EventEmitter = l, l.prototype._events = void 0, l.prototype._eventsCount = 0, l.prototype._maxListeners = void 0;
        var d = 10;
        function u(N) {
          if (typeof N != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof N);
        }
        Object.defineProperty(l, "defaultMaxListeners", {
          enumerable: !0,
          get: function() {
            return d;
          },
          set: function(N) {
            if (typeof N != "number" || N < 0 || p(N))
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + N + ".");
            d = N;
          }
        }), l.init = function() {
          (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, l.prototype.setMaxListeners = function(O) {
          if (typeof O != "number" || O < 0 || p(O))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + O + ".");
          return this._maxListeners = O, this;
        };
        function h(N) {
          return N._maxListeners === void 0 ? l.defaultMaxListeners : N._maxListeners;
        }
        l.prototype.getMaxListeners = function() {
          return h(this);
        }, l.prototype.emit = function(O) {
          for (var D = [], H = 1; H < arguments.length; H++) D.push(arguments[H]);
          var G = O === "error", X = this._events;
          if (X !== void 0)
            G = G && X.error === void 0;
          else if (!G)
            return !1;
          if (G) {
            var Q;
            if (D.length > 0 && (Q = D[0]), Q instanceof Error)
              throw Q;
            var M = new Error("Unhandled error." + (Q ? " (" + Q.message + ")" : ""));
            throw M.context = Q, M;
          }
          var k = X[O];
          if (k === void 0)
            return !1;
          if (typeof k == "function")
            a(k, this, D);
          else
            for (var $ = k.length, ne = E(k, $), H = 0; H < $; ++H)
              a(ne[H], this, D);
          return !0;
        };
        function y(N, O, D, H) {
          var G, X, Q;
          if (u(D), X = N._events, X === void 0 ? (X = N._events = /* @__PURE__ */ Object.create(null), N._eventsCount = 0) : (X.newListener !== void 0 && (N.emit(
            "newListener",
            O,
            D.listener ? D.listener : D
          ), X = N._events), Q = X[O]), Q === void 0)
            Q = X[O] = D, ++N._eventsCount;
          else if (typeof Q == "function" ? Q = X[O] = H ? [D, Q] : [Q, D] : H ? Q.unshift(D) : Q.push(D), G = h(N), G > 0 && Q.length > G && !Q.warned) {
            Q.warned = !0;
            var M = new Error("Possible EventEmitter memory leak detected. " + Q.length + " " + String(O) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            M.name = "MaxListenersExceededWarning", M.emitter = N, M.type = O, M.count = Q.length, c(M);
          }
          return N;
        }
        l.prototype.addListener = function(O, D) {
          return y(this, O, D, !1);
        }, l.prototype.on = l.prototype.addListener, l.prototype.prependListener = function(O, D) {
          return y(this, O, D, !0);
        };
        function f() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function b(N, O, D) {
          var H = { fired: !1, wrapFn: void 0, target: N, type: O, listener: D }, G = f.bind(H);
          return G.listener = D, H.wrapFn = G, G;
        }
        l.prototype.once = function(O, D) {
          return u(D), this.on(O, b(this, O, D)), this;
        }, l.prototype.prependOnceListener = function(O, D) {
          return u(D), this.prependListener(O, b(this, O, D)), this;
        }, l.prototype.removeListener = function(O, D) {
          var H, G, X, Q, M;
          if (u(D), G = this._events, G === void 0)
            return this;
          if (H = G[O], H === void 0)
            return this;
          if (H === D || H.listener === D)
            --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete G[O], G.removeListener && this.emit("removeListener", O, H.listener || D));
          else if (typeof H != "function") {
            for (X = -1, Q = H.length - 1; Q >= 0; Q--)
              if (H[Q] === D || H[Q].listener === D) {
                M = H[Q].listener, X = Q;
                break;
              }
            if (X < 0)
              return this;
            X === 0 ? H.shift() : T(H, X), H.length === 1 && (G[O] = H[0]), G.removeListener !== void 0 && this.emit("removeListener", O, M || D);
          }
          return this;
        }, l.prototype.off = l.prototype.removeListener, l.prototype.removeAllListeners = function(O) {
          var D, H, G;
          if (H = this._events, H === void 0)
            return this;
          if (H.removeListener === void 0)
            return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : H[O] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete H[O]), this;
          if (arguments.length === 0) {
            var X = Object.keys(H), Q;
            for (G = 0; G < X.length; ++G)
              Q = X[G], Q !== "removeListener" && this.removeAllListeners(Q);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (D = H[O], typeof D == "function")
            this.removeListener(O, D);
          else if (D !== void 0)
            for (G = D.length - 1; G >= 0; G--)
              this.removeListener(O, D[G]);
          return this;
        };
        function w(N, O, D) {
          var H = N._events;
          if (H === void 0)
            return [];
          var G = H[O];
          return G === void 0 ? [] : typeof G == "function" ? D ? [G.listener || G] : [G] : D ? C(G) : E(G, G.length);
        }
        l.prototype.listeners = function(O) {
          return w(this, O, !0);
        }, l.prototype.rawListeners = function(O) {
          return w(this, O, !1);
        }, l.listenerCount = function(N, O) {
          return typeof N.listenerCount == "function" ? N.listenerCount(O) : x.call(N, O);
        }, l.prototype.listenerCount = x;
        function x(N) {
          var O = this._events;
          if (O !== void 0) {
            var D = O[N];
            if (typeof D == "function")
              return 1;
            if (D !== void 0)
              return D.length;
          }
          return 0;
        }
        l.prototype.eventNames = function() {
          return this._eventsCount > 0 ? s(this._events) : [];
        };
        function E(N, O) {
          for (var D = new Array(O), H = 0; H < O; ++H)
            D[H] = N[H];
          return D;
        }
        function T(N, O) {
          for (; O + 1 < N.length; O++)
            N[O] = N[O + 1];
          N.pop();
        }
        function C(N) {
          for (var O = new Array(N.length), D = 0; D < O.length; ++D)
            O[D] = N[D].listener || N[D];
          return O;
        }
        function R(N, O) {
          return new Promise(function(D, H) {
            function G(Q) {
              N.removeListener(O, X), H(Q);
            }
            function X() {
              typeof N.removeListener == "function" && N.removeListener("error", G), D([].slice.call(arguments));
            }
            j(N, O, X, { once: !0 }), O !== "error" && A(N, G, { once: !0 });
          });
        }
        function A(N, O, D) {
          typeof N.on == "function" && j(N, "error", O, D);
        }
        function j(N, O, D, H) {
          if (typeof N.on == "function")
            H.once ? N.once(O, D) : N.on(O, D);
          else if (typeof N.addEventListener == "function")
            N.addEventListener(O, function G(X) {
              H.once && N.removeEventListener(O, G), D(X);
            });
          else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof N);
        }
      }, {}], 36: [function(r, o, n) {
        var i = r("is-callable"), a = Object.prototype.toString, s = Object.prototype.hasOwnProperty, c = function(h, y, f) {
          for (var b = 0, w = h.length; b < w; b++)
            s.call(h, b) && (f == null ? y(h[b], b, h) : y.call(f, h[b], b, h));
        }, p = function(h, y, f) {
          for (var b = 0, w = h.length; b < w; b++)
            f == null ? y(h.charAt(b), b, h) : y.call(f, h.charAt(b), b, h);
        }, l = function(h, y, f) {
          for (var b in h)
            s.call(h, b) && (f == null ? y(h[b], b, h) : y.call(f, h[b], b, h));
        }, d = function(h, y, f) {
          if (!i(y))
            throw new TypeError("iterator must be a function");
          var b;
          arguments.length >= 3 && (b = f), a.call(h) === "[object Array]" ? c(h, y, b) : typeof h == "string" ? p(h, y, b) : l(h, y, b);
        };
        o.exports = d;
      }, { "is-callable": 48 }], 37: [function(r, o, n) {
        var i = "Function.prototype.bind called on incompatible ", a = Array.prototype.slice, s = Object.prototype.toString, c = "[object Function]";
        o.exports = function(l) {
          var d = this;
          if (typeof d != "function" || s.call(d) !== c)
            throw new TypeError(i + d);
          for (var u = a.call(arguments, 1), h, y = function() {
            if (this instanceof h) {
              var E = d.apply(
                this,
                u.concat(a.call(arguments))
              );
              return Object(E) === E ? E : this;
            } else
              return d.apply(
                l,
                u.concat(a.call(arguments))
              );
          }, f = Math.max(0, d.length - u.length), b = [], w = 0; w < f; w++)
            b.push("$" + w);
          if (h = Function("binder", "return function (" + b.join(",") + "){ return binder.apply(this,arguments); }")(y), d.prototype) {
            var x = function() {
            };
            x.prototype = d.prototype, h.prototype = new x(), x.prototype = null;
          }
          return h;
        };
      }, {}], 38: [function(r, o, n) {
        var i = r("./implementation");
        o.exports = Function.prototype.bind || i;
      }, { "./implementation": 37 }], 39: [function(r, o, n) {
        var i, a = SyntaxError, s = Function, c = TypeError, p = function(M) {
          try {
            return s('"use strict"; return (' + M + ").constructor;")();
          } catch {
          }
        }, l = Object.getOwnPropertyDescriptor;
        if (l)
          try {
            l({}, "");
          } catch {
            l = null;
          }
        var d = function() {
          throw new c();
        }, u = l ? function() {
          try {
            return arguments.callee, d;
          } catch {
            try {
              return l(arguments, "callee").get;
            } catch {
              return d;
            }
          }
        }() : d, h = r("has-symbols")(), y = Object.getPrototypeOf || function(M) {
          return M.__proto__;
        }, f = {}, b = typeof Uint8Array > "u" ? i : y(Uint8Array), w = {
          "%AggregateError%": typeof AggregateError > "u" ? i : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%": typeof ArrayBuffer > "u" ? i : ArrayBuffer,
          "%ArrayIteratorPrototype%": h ? y([][Symbol.iterator]()) : i,
          "%AsyncFromSyncIteratorPrototype%": i,
          "%AsyncFunction%": f,
          "%AsyncGenerator%": f,
          "%AsyncGeneratorFunction%": f,
          "%AsyncIteratorPrototype%": f,
          "%Atomics%": typeof Atomics > "u" ? i : Atomics,
          "%BigInt%": typeof BigInt > "u" ? i : BigInt,
          "%BigInt64Array%": typeof BigInt64Array > "u" ? i : BigInt64Array,
          "%BigUint64Array%": typeof BigUint64Array > "u" ? i : BigUint64Array,
          "%Boolean%": Boolean,
          "%DataView%": typeof DataView > "u" ? i : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval,
          // eslint-disable-line no-eval
          "%EvalError%": EvalError,
          "%Float32Array%": typeof Float32Array > "u" ? i : Float32Array,
          "%Float64Array%": typeof Float64Array > "u" ? i : Float64Array,
          "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? i : FinalizationRegistry,
          "%Function%": s,
          "%GeneratorFunction%": f,
          "%Int8Array%": typeof Int8Array > "u" ? i : Int8Array,
          "%Int16Array%": typeof Int16Array > "u" ? i : Int16Array,
          "%Int32Array%": typeof Int32Array > "u" ? i : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": h ? y(y([][Symbol.iterator]())) : i,
          "%JSON%": typeof JSON == "object" ? JSON : i,
          "%Map%": typeof Map > "u" ? i : Map,
          "%MapIteratorPrototype%": typeof Map > "u" || !h ? i : y((/* @__PURE__ */ new Map())[Symbol.iterator]()),
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": typeof Promise > "u" ? i : Promise,
          "%Proxy%": typeof Proxy > "u" ? i : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": typeof Reflect > "u" ? i : Reflect,
          "%RegExp%": RegExp,
          "%Set%": typeof Set > "u" ? i : Set,
          "%SetIteratorPrototype%": typeof Set > "u" || !h ? i : y((/* @__PURE__ */ new Set())[Symbol.iterator]()),
          "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? i : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": h ? y(""[Symbol.iterator]()) : i,
          "%Symbol%": h ? Symbol : i,
          "%SyntaxError%": a,
          "%ThrowTypeError%": u,
          "%TypedArray%": b,
          "%TypeError%": c,
          "%Uint8Array%": typeof Uint8Array > "u" ? i : Uint8Array,
          "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? i : Uint8ClampedArray,
          "%Uint16Array%": typeof Uint16Array > "u" ? i : Uint16Array,
          "%Uint32Array%": typeof Uint32Array > "u" ? i : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": typeof WeakMap > "u" ? i : WeakMap,
          "%WeakRef%": typeof WeakRef > "u" ? i : WeakRef,
          "%WeakSet%": typeof WeakSet > "u" ? i : WeakSet
        };
        try {
          null.error;
        } catch (M) {
          var x = y(y(M));
          w["%Error.prototype%"] = x;
        }
        var E = function M(k) {
          var $;
          if (k === "%AsyncFunction%")
            $ = p("async function () {}");
          else if (k === "%GeneratorFunction%")
            $ = p("function* () {}");
          else if (k === "%AsyncGeneratorFunction%")
            $ = p("async function* () {}");
          else if (k === "%AsyncGenerator%") {
            var ne = M("%AsyncGeneratorFunction%");
            ne && ($ = ne.prototype);
          } else if (k === "%AsyncIteratorPrototype%") {
            var te = M("%AsyncGenerator%");
            te && ($ = y(te.prototype));
          }
          return w[k] = $, $;
        }, T = {
          "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
          "%ArrayPrototype%": ["Array", "prototype"],
          "%ArrayProto_entries%": ["Array", "prototype", "entries"],
          "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
          "%ArrayProto_keys%": ["Array", "prototype", "keys"],
          "%ArrayProto_values%": ["Array", "prototype", "values"],
          "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
          "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
          "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
          "%BooleanPrototype%": ["Boolean", "prototype"],
          "%DataViewPrototype%": ["DataView", "prototype"],
          "%DatePrototype%": ["Date", "prototype"],
          "%ErrorPrototype%": ["Error", "prototype"],
          "%EvalErrorPrototype%": ["EvalError", "prototype"],
          "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
          "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
          "%FunctionPrototype%": ["Function", "prototype"],
          "%Generator%": ["GeneratorFunction", "prototype"],
          "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
          "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
          "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
          "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
          "%JSONParse%": ["JSON", "parse"],
          "%JSONStringify%": ["JSON", "stringify"],
          "%MapPrototype%": ["Map", "prototype"],
          "%NumberPrototype%": ["Number", "prototype"],
          "%ObjectPrototype%": ["Object", "prototype"],
          "%ObjProto_toString%": ["Object", "prototype", "toString"],
          "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
          "%PromisePrototype%": ["Promise", "prototype"],
          "%PromiseProto_then%": ["Promise", "prototype", "then"],
          "%Promise_all%": ["Promise", "all"],
          "%Promise_reject%": ["Promise", "reject"],
          "%Promise_resolve%": ["Promise", "resolve"],
          "%RangeErrorPrototype%": ["RangeError", "prototype"],
          "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
          "%RegExpPrototype%": ["RegExp", "prototype"],
          "%SetPrototype%": ["Set", "prototype"],
          "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
          "%StringPrototype%": ["String", "prototype"],
          "%SymbolPrototype%": ["Symbol", "prototype"],
          "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
          "%TypedArrayPrototype%": ["TypedArray", "prototype"],
          "%TypeErrorPrototype%": ["TypeError", "prototype"],
          "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
          "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
          "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
          "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
          "%URIErrorPrototype%": ["URIError", "prototype"],
          "%WeakMapPrototype%": ["WeakMap", "prototype"],
          "%WeakSetPrototype%": ["WeakSet", "prototype"]
        }, C = r("function-bind"), R = r("has"), A = C.call(Function.call, Array.prototype.concat), j = C.call(Function.apply, Array.prototype.splice), N = C.call(Function.call, String.prototype.replace), O = C.call(Function.call, String.prototype.slice), D = C.call(Function.call, RegExp.prototype.exec), H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, G = /\\(\\)?/g, X = function(k) {
          var $ = O(k, 0, 1), ne = O(k, -1);
          if ($ === "%" && ne !== "%")
            throw new a("invalid intrinsic syntax, expected closing `%`");
          if (ne === "%" && $ !== "%")
            throw new a("invalid intrinsic syntax, expected opening `%`");
          var te = [];
          return N(k, H, function(de, ae, z, Z) {
            te[te.length] = z ? N(Z, G, "$1") : ae || de;
          }), te;
        }, Q = function(k, $) {
          var ne = k, te;
          if (R(T, ne) && (te = T[ne], ne = "%" + te[0] + "%"), R(w, ne)) {
            var de = w[ne];
            if (de === f && (de = E(ne)), typeof de > "u" && !$)
              throw new c("intrinsic " + k + " exists, but is not available. Please file an issue!");
            return {
              alias: te,
              name: ne,
              value: de
            };
          }
          throw new a("intrinsic " + k + " does not exist!");
        };
        o.exports = function(k, $) {
          if (typeof k != "string" || k.length === 0)
            throw new c("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && typeof $ != "boolean")
            throw new c('"allowMissing" argument must be a boolean');
          if (D(/^%?[^%]*%?$/, k) === null)
            throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          var ne = X(k), te = ne.length > 0 ? ne[0] : "", de = Q("%" + te + "%", $), ae = de.name, z = de.value, Z = !1, oe = de.alias;
          oe && (te = oe[0], j(ne, A([0, 1], oe)));
          for (var ye = 1, V = !0; ye < ne.length; ye += 1) {
            var q = ne[ye], ee = O(q, 0, 1), ue = O(q, -1);
            if ((ee === '"' || ee === "'" || ee === "`" || ue === '"' || ue === "'" || ue === "`") && ee !== ue)
              throw new a("property names with quotes must have matching quotes");
            if ((q === "constructor" || !V) && (Z = !0), te += "." + q, ae = "%" + te + "%", R(w, ae))
              z = w[ae];
            else if (z != null) {
              if (!(q in z)) {
                if (!$)
                  throw new c("base intrinsic for " + k + " exists, but the property is not available.");
                return;
              }
              if (l && ye + 1 >= ne.length) {
                var ge = l(z, q);
                V = !!ge, V && "get" in ge && !("originalValue" in ge.get) ? z = ge.get : z = z[q];
              } else
                V = R(z, q), z = z[q];
              V && !Z && (w[ae] = z);
            }
          }
          return z;
        };
      }, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(r, o, n) {
        var i = r("get-intrinsic"), a = i("%Object.getOwnPropertyDescriptor%", !0);
        if (a)
          try {
            a([], "length");
          } catch {
            a = null;
          }
        o.exports = a;
      }, { "get-intrinsic": 39 }], 41: [function(r, o, n) {
        var i = typeof Symbol < "u" && Symbol, a = r("./shams");
        o.exports = function() {
          return typeof i != "function" || typeof Symbol != "function" || typeof i("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : a();
        };
      }, { "./shams": 42 }], 42: [function(r, o, n) {
        o.exports = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return !1;
          if (typeof Symbol.iterator == "symbol")
            return !0;
          var a = {}, s = Symbol("test"), c = Object(s);
          if (typeof s == "string" || Object.prototype.toString.call(s) !== "[object Symbol]" || Object.prototype.toString.call(c) !== "[object Symbol]")
            return !1;
          var p = 42;
          a[s] = p;
          for (s in a)
            return !1;
          if (typeof Object.keys == "function" && Object.keys(a).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(a).length !== 0)
            return !1;
          var l = Object.getOwnPropertySymbols(a);
          if (l.length !== 1 || l[0] !== s || !Object.prototype.propertyIsEnumerable.call(a, s))
            return !1;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var d = Object.getOwnPropertyDescriptor(a, s);
            if (d.value !== p || d.enumerable !== !0)
              return !1;
          }
          return !0;
        };
      }, {}], 43: [function(r, o, n) {
        var i = r("has-symbols/shams");
        o.exports = function() {
          return i() && !!Symbol.toStringTag;
        };
      }, { "has-symbols/shams": 42 }], 44: [function(r, o, n) {
        var i = r("function-bind");
        o.exports = i.call(Function.call, Object.prototype.hasOwnProperty);
      }, { "function-bind": 38 }], 45: [function(r, o, n) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        n.read = function(i, a, s, c, p) {
          var l, d, u = p * 8 - c - 1, h = (1 << u) - 1, y = h >> 1, f = -7, b = s ? p - 1 : 0, w = s ? -1 : 1, x = i[a + b];
          for (b += w, l = x & (1 << -f) - 1, x >>= -f, f += u; f > 0; l = l * 256 + i[a + b], b += w, f -= 8)
            ;
          for (d = l & (1 << -f) - 1, l >>= -f, f += c; f > 0; d = d * 256 + i[a + b], b += w, f -= 8)
            ;
          if (l === 0)
            l = 1 - y;
          else {
            if (l === h)
              return d ? NaN : (x ? -1 : 1) * (1 / 0);
            d = d + Math.pow(2, c), l = l - y;
          }
          return (x ? -1 : 1) * d * Math.pow(2, l - c);
        }, n.write = function(i, a, s, c, p, l) {
          var d, u, h, y = l * 8 - p - 1, f = (1 << y) - 1, b = f >> 1, w = p === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = c ? 0 : l - 1, E = c ? 1 : -1, T = a < 0 || a === 0 && 1 / a < 0 ? 1 : 0;
          for (a = Math.abs(a), isNaN(a) || a === 1 / 0 ? (u = isNaN(a) ? 1 : 0, d = f) : (d = Math.floor(Math.log(a) / Math.LN2), a * (h = Math.pow(2, -d)) < 1 && (d--, h *= 2), d + b >= 1 ? a += w / h : a += w * Math.pow(2, 1 - b), a * h >= 2 && (d++, h /= 2), d + b >= f ? (u = 0, d = f) : d + b >= 1 ? (u = (a * h - 1) * Math.pow(2, p), d = d + b) : (u = a * Math.pow(2, b - 1) * Math.pow(2, p), d = 0)); p >= 8; i[s + x] = u & 255, x += E, u /= 256, p -= 8)
            ;
          for (d = d << p | u, y += p; y > 0; i[s + x] = d & 255, x += E, d /= 256, y -= 8)
            ;
          i[s + x - E] |= T * 128;
        };
      }, {}], 46: [function(r, o, n) {
        typeof Object.create == "function" ? o.exports = function(a, s) {
          s && (a.super_ = s, a.prototype = Object.create(s.prototype, {
            constructor: {
              value: a,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }));
        } : o.exports = function(a, s) {
          if (s) {
            a.super_ = s;
            var c = function() {
            };
            c.prototype = s.prototype, a.prototype = new c(), a.prototype.constructor = a;
          }
        };
      }, {}], 47: [function(r, o, n) {
        var i = r("has-tostringtag/shams")(), a = r("call-bind/callBound"), s = a("Object.prototype.toString"), c = function(u) {
          return i && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : s(u) === "[object Arguments]";
        }, p = function(u) {
          return c(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && s(u) !== "[object Array]" && s(u.callee) === "[object Function]";
        }, l = function() {
          return c(arguments);
        }();
        c.isLegacyArguments = p, o.exports = l ? c : p;
      }, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(r, o, n) {
        var i = Function.prototype.toString, a = typeof Reflect == "object" && Reflect !== null && Reflect.apply, s, c;
        if (typeof a == "function" && typeof Object.defineProperty == "function")
          try {
            s = Object.defineProperty({}, "length", {
              get: function() {
                throw c;
              }
            }), c = {}, a(function() {
              throw 42;
            }, null, s);
          } catch (A) {
            A !== c && (a = null);
          }
        else
          a = null;
        var p = /^\s*class\b/, l = function(j) {
          try {
            var N = i.call(j);
            return p.test(N);
          } catch {
            return !1;
          }
        }, d = function(j) {
          try {
            return l(j) ? !1 : (i.call(j), !0);
          } catch {
            return !1;
          }
        }, u = Object.prototype.toString, h = "[object Object]", y = "[object Function]", f = "[object GeneratorFunction]", b = "[object HTMLAllCollection]", w = "[object HTML document.all class]", x = "[object HTMLCollection]", E = typeof Symbol == "function" && !!Symbol.toStringTag, T = !(0 in [,]), C = function() {
          return !1;
        };
        if (typeof document == "object") {
          var R = document.all;
          u.call(R) === u.call(document.all) && (C = function(j) {
            if ((T || !j) && (typeof j > "u" || typeof j == "object"))
              try {
                var N = u.call(j);
                return (N === b || N === w || N === x || N === h) && j("") == null;
              } catch {
              }
            return !1;
          });
        }
        o.exports = a ? function(j) {
          if (C(j))
            return !0;
          if (!j || typeof j != "function" && typeof j != "object")
            return !1;
          try {
            a(j, null, s);
          } catch (N) {
            if (N !== c)
              return !1;
          }
          return !l(j) && d(j);
        } : function(j) {
          if (C(j))
            return !0;
          if (!j || typeof j != "function" && typeof j != "object")
            return !1;
          if (E)
            return d(j);
          if (l(j))
            return !1;
          var N = u.call(j);
          return N !== y && N !== f && !/^\[object HTML/.test(N) ? !1 : d(j);
        };
      }, {}], 49: [function(r, o, n) {
        var i = Object.prototype.toString, a = Function.prototype.toString, s = /^\s*(?:function)?\*/, c = r("has-tostringtag/shams")(), p = Object.getPrototypeOf, l = function() {
          if (!c)
            return !1;
          try {
            return Function("return function*() {}")();
          } catch {
          }
        }, d;
        o.exports = function(h) {
          if (typeof h != "function")
            return !1;
          if (s.test(a.call(h)))
            return !0;
          if (!c) {
            var y = i.call(h);
            return y === "[object GeneratorFunction]";
          }
          if (!p)
            return !1;
          if (typeof d > "u") {
            var f = l();
            d = f ? p(f) : !1;
          }
          return p(h) === d;
        };
      }, { "has-tostringtag/shams": 43 }], 50: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = r("for-each"), s = r("available-typed-arrays"), c = r("call-bind/callBound"), p = c("Object.prototype.toString"), l = r("has-tostringtag/shams")(), d = r("gopd"), u = typeof globalThis > "u" ? i : globalThis, h = s(), y = c("Array.prototype.indexOf", !0) || function(T, C) {
              for (var R = 0; R < T.length; R += 1)
                if (T[R] === C)
                  return R;
              return -1;
            }, f = c("String.prototype.slice"), b = {}, w = Object.getPrototypeOf;
            l && d && w && a(h, function(E) {
              var T = new u[E]();
              if (Symbol.toStringTag in T) {
                var C = w(T), R = d(C, Symbol.toStringTag);
                if (!R) {
                  var A = w(C);
                  R = d(A, Symbol.toStringTag);
                }
                b[E] = R.get;
              }
            });
            var x = function(T) {
              var C = !1;
              return a(b, function(R, A) {
                if (!C)
                  try {
                    C = R.call(T) === A;
                  } catch {
                  }
              }), C;
            };
            o.exports = function(T) {
              if (!T || typeof T != "object")
                return !1;
              if (!l || !(Symbol.toStringTag in T)) {
                var C = f(p(T), 8, -1);
                return y(h, C) > -1;
              }
              return d ? x(T) : !1;
            };
          }).call(this);
        }).call(this, typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(r, o, n) {
        var i = Object.getOwnPropertySymbols, a = Object.prototype.hasOwnProperty, s = Object.prototype.propertyIsEnumerable;
        function c(l) {
          if (l == null)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(l);
        }
        function p() {
          try {
            if (!Object.assign)
              return !1;
            var l = new String("abc");
            if (l[5] = "de", Object.getOwnPropertyNames(l)[0] === "5")
              return !1;
            for (var d = {}, u = 0; u < 10; u++)
              d["_" + String.fromCharCode(u)] = u;
            var h = Object.getOwnPropertyNames(d).map(function(f) {
              return d[f];
            });
            if (h.join("") !== "0123456789")
              return !1;
            var y = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(f) {
              y[f] = f;
            }), Object.keys(Object.assign({}, y)).join("") === "abcdefghijklmnopqrst";
          } catch {
            return !1;
          }
        }
        o.exports = p() ? Object.assign : function(l, d) {
          for (var u, h = c(l), y, f = 1; f < arguments.length; f++) {
            u = Object(arguments[f]);
            for (var b in u)
              a.call(u, b) && (h[b] = u[b]);
            if (i) {
              y = i(u);
              for (var w = 0; w < y.length; w++)
                s.call(u, y[w]) && (h[y[w]] = u[y[w]]);
            }
          }
          return h;
        };
      }, {}], 52: [function(r, o, n) {
        var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function a(p, l) {
          return Object.prototype.hasOwnProperty.call(p, l);
        }
        n.assign = function(p) {
          for (var l = Array.prototype.slice.call(arguments, 1); l.length; ) {
            var d = l.shift();
            if (d) {
              if (typeof d != "object")
                throw new TypeError(d + "must be non-object");
              for (var u in d)
                a(d, u) && (p[u] = d[u]);
            }
          }
          return p;
        }, n.shrinkBuf = function(p, l) {
          return p.length === l ? p : p.subarray ? p.subarray(0, l) : (p.length = l, p);
        };
        var s = {
          arraySet: function(p, l, d, u, h) {
            if (l.subarray && p.subarray) {
              p.set(l.subarray(d, d + u), h);
              return;
            }
            for (var y = 0; y < u; y++)
              p[h + y] = l[d + y];
          },
          // Join array of chunks to single array.
          flattenChunks: function(p) {
            var l, d, u, h, y, f;
            for (u = 0, l = 0, d = p.length; l < d; l++)
              u += p[l].length;
            for (f = new Uint8Array(u), h = 0, l = 0, d = p.length; l < d; l++)
              y = p[l], f.set(y, h), h += y.length;
            return f;
          }
        }, c = {
          arraySet: function(p, l, d, u, h) {
            for (var y = 0; y < u; y++)
              p[h + y] = l[d + y];
          },
          // Join array of chunks to single array.
          flattenChunks: function(p) {
            return [].concat.apply([], p);
          }
        };
        n.setTyped = function(p) {
          p ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, s)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, c));
        }, n.setTyped(i);
      }, {}], 53: [function(r, o, n) {
        function i(a, s, c, p) {
          for (var l = a & 65535 | 0, d = a >>> 16 & 65535 | 0, u = 0; c !== 0; ) {
            u = c > 2e3 ? 2e3 : c, c -= u;
            do
              l = l + s[p++] | 0, d = d + l | 0;
            while (--u);
            l %= 65521, d %= 65521;
          }
          return l | d << 16 | 0;
        }
        o.exports = i;
      }, {}], 54: [function(r, o, n) {
        o.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 55: [function(r, o, n) {
        function i() {
          for (var c, p = [], l = 0; l < 256; l++) {
            c = l;
            for (var d = 0; d < 8; d++)
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            p[l] = c;
          }
          return p;
        }
        var a = i();
        function s(c, p, l, d) {
          var u = a, h = d + l;
          c ^= -1;
          for (var y = d; y < h; y++)
            c = c >>> 8 ^ u[(c ^ p[y]) & 255];
          return c ^ -1;
        }
        o.exports = s;
      }, {}], 56: [function(r, o, n) {
        var i = r("../utils/common"), a = r("./trees"), s = r("./adler32"), c = r("./crc32"), p = r("./messages"), l = 0, d = 1, u = 3, h = 4, y = 5, f = 0, b = 1, w = -2, x = -3, E = -5, T = -1, C = 1, R = 2, A = 3, j = 4, N = 0, O = 2, D = 8, H = 9, G = 15, X = 8, Q = 29, M = 256, k = M + 1 + Q, $ = 30, ne = 19, te = 2 * k + 1, de = 15, ae = 3, z = 258, Z = z + ae + 1, oe = 32, ye = 42, V = 69, q = 73, ee = 91, ue = 103, ge = 113, he = 666, W = 1, Y = 2, se = 3, Te = 4, Oe = 3;
        function B(g, fe) {
          return g.msg = p[fe], fe;
        }
        function U(g) {
          return (g << 1) - (g > 4 ? 9 : 0);
        }
        function _(g) {
          for (var fe = g.length; --fe >= 0; )
            g[fe] = 0;
        }
        function v(g) {
          var fe = g.state, le = fe.pending;
          le > g.avail_out && (le = g.avail_out), le !== 0 && (i.arraySet(g.output, fe.pending_buf, fe.pending_out, le, g.next_out), g.next_out += le, fe.pending_out += le, g.total_out += le, g.avail_out -= le, fe.pending -= le, fe.pending === 0 && (fe.pending_out = 0));
        }
        function S(g, fe) {
          a._tr_flush_block(g, g.block_start >= 0 ? g.block_start : -1, g.strstart - g.block_start, fe), g.block_start = g.strstart, v(g.strm);
        }
        function P(g, fe) {
          g.pending_buf[g.pending++] = fe;
        }
        function J(g, fe) {
          g.pending_buf[g.pending++] = fe >>> 8 & 255, g.pending_buf[g.pending++] = fe & 255;
        }
        function ve(g, fe, le, L) {
          var K = g.avail_in;
          return K > L && (K = L), K === 0 ? 0 : (g.avail_in -= K, i.arraySet(fe, g.input, g.next_in, K, le), g.state.wrap === 1 ? g.adler = s(g.adler, fe, K, le) : g.state.wrap === 2 && (g.adler = c(g.adler, fe, K, le)), g.next_in += K, g.total_in += K, K);
        }
        function Re(g, fe) {
          var le = g.max_chain_length, L = g.strstart, K, ce, Le = g.prev_length, Ae = g.nice_match, Ie = g.strstart > g.w_size - Z ? g.strstart - (g.w_size - Z) : 0, Ye = g.window, It = g.w_mask, nt = g.prev, pe = g.strstart + z, ie = Ye[L + Le - 1], Se = Ye[L + Le];
          g.prev_length >= g.good_match && (le >>= 2), Ae > g.lookahead && (Ae = g.lookahead);
          do
            if (K = fe, !(Ye[K + Le] !== Se || Ye[K + Le - 1] !== ie || Ye[K] !== Ye[L] || Ye[++K] !== Ye[L + 1])) {
              L += 2, K++;
              do
                ;
              while (Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && Ye[++L] === Ye[++K] && L < pe);
              if (ce = z - (pe - L), L = pe - z, ce > Le) {
                if (g.match_start = fe, Le = ce, ce >= Ae)
                  break;
                ie = Ye[L + Le - 1], Se = Ye[L + Le];
              }
            }
          while ((fe = nt[fe & It]) > Ie && --le !== 0);
          return Le <= g.lookahead ? Le : g.lookahead;
        }
        function je(g) {
          var fe = g.w_size, le, L, K, ce, Le;
          do {
            if (ce = g.window_size - g.lookahead - g.strstart, g.strstart >= fe + (fe - Z)) {
              i.arraySet(g.window, g.window, fe, fe, 0), g.match_start -= fe, g.strstart -= fe, g.block_start -= fe, L = g.hash_size, le = L;
              do
                K = g.head[--le], g.head[le] = K >= fe ? K - fe : 0;
              while (--L);
              L = fe, le = L;
              do
                K = g.prev[--le], g.prev[le] = K >= fe ? K - fe : 0;
              while (--L);
              ce += fe;
            }
            if (g.strm.avail_in === 0)
              break;
            if (L = ve(g.strm, g.window, g.strstart + g.lookahead, ce), g.lookahead += L, g.lookahead + g.insert >= ae)
              for (Le = g.strstart - g.insert, g.ins_h = g.window[Le], g.ins_h = (g.ins_h << g.hash_shift ^ g.window[Le + 1]) & g.hash_mask; g.insert && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[Le + ae - 1]) & g.hash_mask, g.prev[Le & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = Le, Le++, g.insert--, !(g.lookahead + g.insert < ae)); )
                ;
          } while (g.lookahead < Z && g.strm.avail_in !== 0);
        }
        function qe(g, fe) {
          var le = 65535;
          for (le > g.pending_buf_size - 5 && (le = g.pending_buf_size - 5); ; ) {
            if (g.lookahead <= 1) {
              if (je(g), g.lookahead === 0 && fe === l)
                return W;
              if (g.lookahead === 0)
                break;
            }
            g.strstart += g.lookahead, g.lookahead = 0;
            var L = g.block_start + le;
            if ((g.strstart === 0 || g.strstart >= L) && (g.lookahead = g.strstart - L, g.strstart = L, S(g, !1), g.strm.avail_out === 0) || g.strstart - g.block_start >= g.w_size - Z && (S(g, !1), g.strm.avail_out === 0))
              return W;
          }
          return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : (g.strstart > g.block_start && (S(g, !1), g.strm.avail_out === 0), W);
        }
        function ze(g, fe) {
          for (var le, L; ; ) {
            if (g.lookahead < Z) {
              if (je(g), g.lookahead < Z && fe === l)
                return W;
              if (g.lookahead === 0)
                break;
            }
            if (le = 0, g.lookahead >= ae && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart), le !== 0 && g.strstart - le <= g.w_size - Z && (g.match_length = Re(g, le)), g.match_length >= ae)
              if (L = a._tr_tally(g, g.strstart - g.match_start, g.match_length - ae), g.lookahead -= g.match_length, g.match_length <= g.max_lazy_match && g.lookahead >= ae) {
                g.match_length--;
                do
                  g.strstart++, g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart;
                while (--g.match_length !== 0);
                g.strstart++;
              } else
                g.strstart += g.match_length, g.match_length = 0, g.ins_h = g.window[g.strstart], g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + 1]) & g.hash_mask;
            else
              L = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++;
            if (L && (S(g, !1), g.strm.avail_out === 0))
              return W;
          }
          return g.insert = g.strstart < ae - 1 ? g.strstart : ae - 1, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
        }
        function We(g, fe) {
          for (var le, L, K; ; ) {
            if (g.lookahead < Z) {
              if (je(g), g.lookahead < Z && fe === l)
                return W;
              if (g.lookahead === 0)
                break;
            }
            if (le = 0, g.lookahead >= ae && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart), g.prev_length = g.match_length, g.prev_match = g.match_start, g.match_length = ae - 1, le !== 0 && g.prev_length < g.max_lazy_match && g.strstart - le <= g.w_size - Z && (g.match_length = Re(g, le), g.match_length <= 5 && (g.strategy === C || g.match_length === ae && g.strstart - g.match_start > 4096) && (g.match_length = ae - 1)), g.prev_length >= ae && g.match_length <= g.prev_length) {
              K = g.strstart + g.lookahead - ae, L = a._tr_tally(g, g.strstart - 1 - g.prev_match, g.prev_length - ae), g.lookahead -= g.prev_length - 1, g.prev_length -= 2;
              do
                ++g.strstart <= K && (g.ins_h = (g.ins_h << g.hash_shift ^ g.window[g.strstart + ae - 1]) & g.hash_mask, le = g.prev[g.strstart & g.w_mask] = g.head[g.ins_h], g.head[g.ins_h] = g.strstart);
              while (--g.prev_length !== 0);
              if (g.match_available = 0, g.match_length = ae - 1, g.strstart++, L && (S(g, !1), g.strm.avail_out === 0))
                return W;
            } else if (g.match_available) {
              if (L = a._tr_tally(g, 0, g.window[g.strstart - 1]), L && S(g, !1), g.strstart++, g.lookahead--, g.strm.avail_out === 0)
                return W;
            } else
              g.match_available = 1, g.strstart++, g.lookahead--;
          }
          return g.match_available && (L = a._tr_tally(g, 0, g.window[g.strstart - 1]), g.match_available = 0), g.insert = g.strstart < ae - 1 ? g.strstart : ae - 1, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
        }
        function Fe(g, fe) {
          for (var le, L, K, ce, Le = g.window; ; ) {
            if (g.lookahead <= z) {
              if (je(g), g.lookahead <= z && fe === l)
                return W;
              if (g.lookahead === 0)
                break;
            }
            if (g.match_length = 0, g.lookahead >= ae && g.strstart > 0 && (K = g.strstart - 1, L = Le[K], L === Le[++K] && L === Le[++K] && L === Le[++K])) {
              ce = g.strstart + z;
              do
                ;
              while (L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && L === Le[++K] && K < ce);
              g.match_length = z - (ce - K), g.match_length > g.lookahead && (g.match_length = g.lookahead);
            }
            if (g.match_length >= ae ? (le = a._tr_tally(g, 1, g.match_length - ae), g.lookahead -= g.match_length, g.strstart += g.match_length, g.match_length = 0) : (le = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++), le && (S(g, !1), g.strm.avail_out === 0))
              return W;
          }
          return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
        }
        function rt(g, fe) {
          for (var le; ; ) {
            if (g.lookahead === 0 && (je(g), g.lookahead === 0)) {
              if (fe === l)
                return W;
              break;
            }
            if (g.match_length = 0, le = a._tr_tally(g, 0, g.window[g.strstart]), g.lookahead--, g.strstart++, le && (S(g, !1), g.strm.avail_out === 0))
              return W;
          }
          return g.insert = 0, fe === h ? (S(g, !0), g.strm.avail_out === 0 ? se : Te) : g.last_lit && (S(g, !1), g.strm.avail_out === 0) ? W : Y;
        }
        function Ge(g, fe, le, L, K) {
          this.good_length = g, this.max_lazy = fe, this.nice_length = le, this.max_chain = L, this.func = K;
        }
        var Je;
        Je = [
          /*      good lazy nice chain */
          new Ge(0, 0, 0, 0, qe),
          /* 0 store only */
          new Ge(4, 4, 8, 4, ze),
          /* 1 max speed, no lazy matches */
          new Ge(4, 5, 16, 8, ze),
          /* 2 */
          new Ge(4, 6, 32, 32, ze),
          /* 3 */
          new Ge(4, 4, 16, 16, We),
          /* 4 lazy matches */
          new Ge(8, 16, 32, 32, We),
          /* 5 */
          new Ge(8, 16, 128, 128, We),
          /* 6 */
          new Ge(8, 32, 128, 256, We),
          /* 7 */
          new Ge(32, 128, 258, 1024, We),
          /* 8 */
          new Ge(32, 258, 258, 4096, We)
          /* 9 max compression */
        ];
        function Ze(g) {
          g.window_size = 2 * g.w_size, _(g.head), g.max_lazy_match = Je[g.level].max_lazy, g.good_match = Je[g.level].good_length, g.nice_match = Je[g.level].nice_length, g.max_chain_length = Je[g.level].max_chain, g.strstart = 0, g.block_start = 0, g.lookahead = 0, g.insert = 0, g.match_length = g.prev_length = ae - 1, g.match_available = 0, g.ins_h = 0;
        }
        function F() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = D, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(te * 2), this.dyn_dtree = new i.Buf16((2 * $ + 1) * 2), this.bl_tree = new i.Buf16((2 * ne + 1) * 2), _(this.dyn_ltree), _(this.dyn_dtree), _(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(de + 1), this.heap = new i.Buf16(2 * k + 1), _(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * k + 1), _(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function we(g) {
          var fe;
          return !g || !g.state ? B(g, w) : (g.total_in = g.total_out = 0, g.data_type = O, fe = g.state, fe.pending = 0, fe.pending_out = 0, fe.wrap < 0 && (fe.wrap = -fe.wrap), fe.status = fe.wrap ? ye : ge, g.adler = fe.wrap === 2 ? 0 : 1, fe.last_flush = l, a._tr_init(fe), f);
        }
        function xe(g) {
          var fe = we(g);
          return fe === f && Ze(g.state), fe;
        }
        function Ce(g, fe) {
          return !g || !g.state || g.state.wrap !== 2 ? w : (g.state.gzhead = fe, f);
        }
        function re(g, fe, le, L, K, ce) {
          if (!g)
            return w;
          var Le = 1;
          if (fe === T && (fe = 6), L < 0 ? (Le = 0, L = -L) : L > 15 && (Le = 2, L -= 16), K < 1 || K > H || le !== D || L < 8 || L > 15 || fe < 0 || fe > 9 || ce < 0 || ce > j)
            return B(g, w);
          L === 8 && (L = 9);
          var Ae = new F();
          return g.state = Ae, Ae.strm = g, Ae.wrap = Le, Ae.gzhead = null, Ae.w_bits = L, Ae.w_size = 1 << Ae.w_bits, Ae.w_mask = Ae.w_size - 1, Ae.hash_bits = K + 7, Ae.hash_size = 1 << Ae.hash_bits, Ae.hash_mask = Ae.hash_size - 1, Ae.hash_shift = ~~((Ae.hash_bits + ae - 1) / ae), Ae.window = new i.Buf8(Ae.w_size * 2), Ae.head = new i.Buf16(Ae.hash_size), Ae.prev = new i.Buf16(Ae.w_size), Ae.lit_bufsize = 1 << K + 6, Ae.pending_buf_size = Ae.lit_bufsize * 4, Ae.pending_buf = new i.Buf8(Ae.pending_buf_size), Ae.d_buf = 1 * Ae.lit_bufsize, Ae.l_buf = 3 * Ae.lit_bufsize, Ae.level = fe, Ae.strategy = ce, Ae.method = le, xe(g);
        }
        function me(g, fe) {
          return re(g, fe, D, G, X, N);
        }
        function I(g, fe) {
          var le, L, K, ce;
          if (!g || !g.state || fe > y || fe < 0)
            return g ? B(g, w) : w;
          if (L = g.state, !g.output || !g.input && g.avail_in !== 0 || L.status === he && fe !== h)
            return B(g, g.avail_out === 0 ? E : w);
          if (L.strm = g, le = L.last_flush, L.last_flush = fe, L.status === ye)
            if (L.wrap === 2)
              g.adler = 0, P(L, 31), P(L, 139), P(L, 8), L.gzhead ? (P(
                L,
                (L.gzhead.text ? 1 : 0) + (L.gzhead.hcrc ? 2 : 0) + (L.gzhead.extra ? 4 : 0) + (L.gzhead.name ? 8 : 0) + (L.gzhead.comment ? 16 : 0)
              ), P(L, L.gzhead.time & 255), P(L, L.gzhead.time >> 8 & 255), P(L, L.gzhead.time >> 16 & 255), P(L, L.gzhead.time >> 24 & 255), P(L, L.level === 9 ? 2 : L.strategy >= R || L.level < 2 ? 4 : 0), P(L, L.gzhead.os & 255), L.gzhead.extra && L.gzhead.extra.length && (P(L, L.gzhead.extra.length & 255), P(L, L.gzhead.extra.length >> 8 & 255)), L.gzhead.hcrc && (g.adler = c(g.adler, L.pending_buf, L.pending, 0)), L.gzindex = 0, L.status = V) : (P(L, 0), P(L, 0), P(L, 0), P(L, 0), P(L, 0), P(L, L.level === 9 ? 2 : L.strategy >= R || L.level < 2 ? 4 : 0), P(L, Oe), L.status = ge);
            else {
              var Le = D + (L.w_bits - 8 << 4) << 8, Ae = -1;
              L.strategy >= R || L.level < 2 ? Ae = 0 : L.level < 6 ? Ae = 1 : L.level === 6 ? Ae = 2 : Ae = 3, Le |= Ae << 6, L.strstart !== 0 && (Le |= oe), Le += 31 - Le % 31, L.status = ge, J(L, Le), L.strstart !== 0 && (J(L, g.adler >>> 16), J(L, g.adler & 65535)), g.adler = 1;
            }
          if (L.status === V)
            if (L.gzhead.extra) {
              for (K = L.pending; L.gzindex < (L.gzhead.extra.length & 65535) && !(L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)); )
                P(L, L.gzhead.extra[L.gzindex] & 255), L.gzindex++;
              L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), L.gzindex === L.gzhead.extra.length && (L.gzindex = 0, L.status = q);
            } else
              L.status = q;
          if (L.status === q)
            if (L.gzhead.name) {
              K = L.pending;
              do {
                if (L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)) {
                  ce = 1;
                  break;
                }
                L.gzindex < L.gzhead.name.length ? ce = L.gzhead.name.charCodeAt(L.gzindex++) & 255 : ce = 0, P(L, ce);
              } while (ce !== 0);
              L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), ce === 0 && (L.gzindex = 0, L.status = ee);
            } else
              L.status = ee;
          if (L.status === ee)
            if (L.gzhead.comment) {
              K = L.pending;
              do {
                if (L.pending === L.pending_buf_size && (L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), v(g), K = L.pending, L.pending === L.pending_buf_size)) {
                  ce = 1;
                  break;
                }
                L.gzindex < L.gzhead.comment.length ? ce = L.gzhead.comment.charCodeAt(L.gzindex++) & 255 : ce = 0, P(L, ce);
              } while (ce !== 0);
              L.gzhead.hcrc && L.pending > K && (g.adler = c(g.adler, L.pending_buf, L.pending - K, K)), ce === 0 && (L.status = ue);
            } else
              L.status = ue;
          if (L.status === ue && (L.gzhead.hcrc ? (L.pending + 2 > L.pending_buf_size && v(g), L.pending + 2 <= L.pending_buf_size && (P(L, g.adler & 255), P(L, g.adler >> 8 & 255), g.adler = 0, L.status = ge)) : L.status = ge), L.pending !== 0) {
            if (v(g), g.avail_out === 0)
              return L.last_flush = -1, f;
          } else if (g.avail_in === 0 && U(fe) <= U(le) && fe !== h)
            return B(g, E);
          if (L.status === he && g.avail_in !== 0)
            return B(g, E);
          if (g.avail_in !== 0 || L.lookahead !== 0 || fe !== l && L.status !== he) {
            var Ie = L.strategy === R ? rt(L, fe) : L.strategy === A ? Fe(L, fe) : Je[L.level].func(L, fe);
            if ((Ie === se || Ie === Te) && (L.status = he), Ie === W || Ie === se)
              return g.avail_out === 0 && (L.last_flush = -1), f;
            if (Ie === Y && (fe === d ? a._tr_align(L) : fe !== y && (a._tr_stored_block(L, 0, 0, !1), fe === u && (_(L.head), L.lookahead === 0 && (L.strstart = 0, L.block_start = 0, L.insert = 0))), v(g), g.avail_out === 0))
              return L.last_flush = -1, f;
          }
          return fe !== h ? f : L.wrap <= 0 ? b : (L.wrap === 2 ? (P(L, g.adler & 255), P(L, g.adler >> 8 & 255), P(L, g.adler >> 16 & 255), P(L, g.adler >> 24 & 255), P(L, g.total_in & 255), P(L, g.total_in >> 8 & 255), P(L, g.total_in >> 16 & 255), P(L, g.total_in >> 24 & 255)) : (J(L, g.adler >>> 16), J(L, g.adler & 65535)), v(g), L.wrap > 0 && (L.wrap = -L.wrap), L.pending !== 0 ? f : b);
        }
        function Ee(g) {
          var fe;
          return !g || !g.state ? w : (fe = g.state.status, fe !== ye && fe !== V && fe !== q && fe !== ee && fe !== ue && fe !== ge && fe !== he ? B(g, w) : (g.state = null, fe === ge ? B(g, x) : f));
        }
        function De(g, fe) {
          var le = fe.length, L, K, ce, Le, Ae, Ie, Ye, It;
          if (!g || !g.state || (L = g.state, Le = L.wrap, Le === 2 || Le === 1 && L.status !== ye || L.lookahead))
            return w;
          for (Le === 1 && (g.adler = s(g.adler, fe, le, 0)), L.wrap = 0, le >= L.w_size && (Le === 0 && (_(L.head), L.strstart = 0, L.block_start = 0, L.insert = 0), It = new i.Buf8(L.w_size), i.arraySet(It, fe, le - L.w_size, L.w_size, 0), fe = It, le = L.w_size), Ae = g.avail_in, Ie = g.next_in, Ye = g.input, g.avail_in = le, g.next_in = 0, g.input = fe, je(L); L.lookahead >= ae; ) {
            K = L.strstart, ce = L.lookahead - (ae - 1);
            do
              L.ins_h = (L.ins_h << L.hash_shift ^ L.window[K + ae - 1]) & L.hash_mask, L.prev[K & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = K, K++;
            while (--ce);
            L.strstart = K, L.lookahead = ae - 1, je(L);
          }
          return L.strstart += L.lookahead, L.block_start = L.strstart, L.insert = L.lookahead, L.lookahead = 0, L.match_length = L.prev_length = ae - 1, L.match_available = 0, g.next_in = Ie, g.input = Ye, g.avail_in = Ae, L.wrap = Le, f;
        }
        n.deflateInit = me, n.deflateInit2 = re, n.deflateReset = xe, n.deflateResetKeep = we, n.deflateSetHeader = Ce, n.deflate = I, n.deflateEnd = Ee, n.deflateSetDictionary = De, n.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(r, o, n) {
        var i = 30, a = 12;
        o.exports = function(c, p) {
          var l, d, u, h, y, f, b, w, x, E, T, C, R, A, j, N, O, D, H, G, X, Q, M, k, $;
          l = c.state, d = c.next_in, k = c.input, u = d + (c.avail_in - 5), h = c.next_out, $ = c.output, y = h - (p - c.avail_out), f = h + (c.avail_out - 257), b = l.dmax, w = l.wsize, x = l.whave, E = l.wnext, T = l.window, C = l.hold, R = l.bits, A = l.lencode, j = l.distcode, N = (1 << l.lenbits) - 1, O = (1 << l.distbits) - 1;
          e:
            do {
              R < 15 && (C += k[d++] << R, R += 8, C += k[d++] << R, R += 8), D = A[C & N];
              t:
                for (; ; ) {
                  if (H = D >>> 24, C >>>= H, R -= H, H = D >>> 16 & 255, H === 0)
                    $[h++] = D & 65535;
                  else if (H & 16) {
                    G = D & 65535, H &= 15, H && (R < H && (C += k[d++] << R, R += 8), G += C & (1 << H) - 1, C >>>= H, R -= H), R < 15 && (C += k[d++] << R, R += 8, C += k[d++] << R, R += 8), D = j[C & O];
                    r:
                      for (; ; ) {
                        if (H = D >>> 24, C >>>= H, R -= H, H = D >>> 16 & 255, H & 16) {
                          if (X = D & 65535, H &= 15, R < H && (C += k[d++] << R, R += 8, R < H && (C += k[d++] << R, R += 8)), X += C & (1 << H) - 1, X > b) {
                            c.msg = "invalid distance too far back", l.mode = i;
                            break e;
                          }
                          if (C >>>= H, R -= H, H = h - y, X > H) {
                            if (H = X - H, H > x && l.sane) {
                              c.msg = "invalid distance too far back", l.mode = i;
                              break e;
                            }
                            if (Q = 0, M = T, E === 0) {
                              if (Q += w - H, H < G) {
                                G -= H;
                                do
                                  $[h++] = T[Q++];
                                while (--H);
                                Q = h - X, M = $;
                              }
                            } else if (E < H) {
                              if (Q += w + E - H, H -= E, H < G) {
                                G -= H;
                                do
                                  $[h++] = T[Q++];
                                while (--H);
                                if (Q = 0, E < G) {
                                  H = E, G -= H;
                                  do
                                    $[h++] = T[Q++];
                                  while (--H);
                                  Q = h - X, M = $;
                                }
                              }
                            } else if (Q += E - H, H < G) {
                              G -= H;
                              do
                                $[h++] = T[Q++];
                              while (--H);
                              Q = h - X, M = $;
                            }
                            for (; G > 2; )
                              $[h++] = M[Q++], $[h++] = M[Q++], $[h++] = M[Q++], G -= 3;
                            G && ($[h++] = M[Q++], G > 1 && ($[h++] = M[Q++]));
                          } else {
                            Q = h - X;
                            do
                              $[h++] = $[Q++], $[h++] = $[Q++], $[h++] = $[Q++], G -= 3;
                            while (G > 2);
                            G && ($[h++] = $[Q++], G > 1 && ($[h++] = $[Q++]));
                          }
                        } else if (H & 64) {
                          c.msg = "invalid distance code", l.mode = i;
                          break e;
                        } else {
                          D = j[(D & 65535) + (C & (1 << H) - 1)];
                          continue r;
                        }
                        break;
                      }
                  } else if (H & 64)
                    if (H & 32) {
                      l.mode = a;
                      break e;
                    } else {
                      c.msg = "invalid literal/length code", l.mode = i;
                      break e;
                    }
                  else {
                    D = A[(D & 65535) + (C & (1 << H) - 1)];
                    continue t;
                  }
                  break;
                }
            } while (d < u && h < f);
          G = R >> 3, d -= G, R -= G << 3, C &= (1 << R) - 1, c.next_in = d, c.next_out = h, c.avail_in = d < u ? 5 + (u - d) : 5 - (d - u), c.avail_out = h < f ? 257 + (f - h) : 257 - (h - f), l.hold = C, l.bits = R;
        };
      }, {}], 58: [function(r, o, n) {
        var i = r("../utils/common"), a = r("./adler32"), s = r("./crc32"), c = r("./inffast"), p = r("./inftrees"), l = 0, d = 1, u = 2, h = 4, y = 5, f = 6, b = 0, w = 1, x = 2, E = -2, T = -3, C = -4, R = -5, A = 8, j = 1, N = 2, O = 3, D = 4, H = 5, G = 6, X = 7, Q = 8, M = 9, k = 10, $ = 11, ne = 12, te = 13, de = 14, ae = 15, z = 16, Z = 17, oe = 18, ye = 19, V = 20, q = 21, ee = 22, ue = 23, ge = 24, he = 25, W = 26, Y = 27, se = 28, Te = 29, Oe = 30, B = 31, U = 32, _ = 852, v = 592, S = 15, P = S;
        function J(re) {
          return (re >>> 24 & 255) + (re >>> 8 & 65280) + ((re & 65280) << 8) + ((re & 255) << 24);
        }
        function ve() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function Re(re) {
          var me;
          return !re || !re.state ? E : (me = re.state, re.total_in = re.total_out = me.total = 0, re.msg = "", me.wrap && (re.adler = me.wrap & 1), me.mode = j, me.last = 0, me.havedict = 0, me.dmax = 32768, me.head = null, me.hold = 0, me.bits = 0, me.lencode = me.lendyn = new i.Buf32(_), me.distcode = me.distdyn = new i.Buf32(v), me.sane = 1, me.back = -1, b);
        }
        function je(re) {
          var me;
          return !re || !re.state ? E : (me = re.state, me.wsize = 0, me.whave = 0, me.wnext = 0, Re(re));
        }
        function qe(re, me) {
          var I, Ee;
          return !re || !re.state || (Ee = re.state, me < 0 ? (I = 0, me = -me) : (I = (me >> 4) + 1, me < 48 && (me &= 15)), me && (me < 8 || me > 15)) ? E : (Ee.window !== null && Ee.wbits !== me && (Ee.window = null), Ee.wrap = I, Ee.wbits = me, je(re));
        }
        function ze(re, me) {
          var I, Ee;
          return re ? (Ee = new ve(), re.state = Ee, Ee.window = null, I = qe(re, me), I !== b && (re.state = null), I) : E;
        }
        function We(re) {
          return ze(re, P);
        }
        var Fe = !0, rt, Ge;
        function Je(re) {
          if (Fe) {
            var me;
            for (rt = new i.Buf32(512), Ge = new i.Buf32(32), me = 0; me < 144; )
              re.lens[me++] = 8;
            for (; me < 256; )
              re.lens[me++] = 9;
            for (; me < 280; )
              re.lens[me++] = 7;
            for (; me < 288; )
              re.lens[me++] = 8;
            for (p(d, re.lens, 0, 288, rt, 0, re.work, { bits: 9 }), me = 0; me < 32; )
              re.lens[me++] = 5;
            p(u, re.lens, 0, 32, Ge, 0, re.work, { bits: 5 }), Fe = !1;
          }
          re.lencode = rt, re.lenbits = 9, re.distcode = Ge, re.distbits = 5;
        }
        function Ze(re, me, I, Ee) {
          var De, g = re.state;
          return g.window === null && (g.wsize = 1 << g.wbits, g.wnext = 0, g.whave = 0, g.window = new i.Buf8(g.wsize)), Ee >= g.wsize ? (i.arraySet(g.window, me, I - g.wsize, g.wsize, 0), g.wnext = 0, g.whave = g.wsize) : (De = g.wsize - g.wnext, De > Ee && (De = Ee), i.arraySet(g.window, me, I - Ee, De, g.wnext), Ee -= De, Ee ? (i.arraySet(g.window, me, I - Ee, Ee, 0), g.wnext = Ee, g.whave = g.wsize) : (g.wnext += De, g.wnext === g.wsize && (g.wnext = 0), g.whave < g.wsize && (g.whave += De))), 0;
        }
        function F(re, me) {
          var I, Ee, De, g, fe, le, L, K, ce, Le, Ae, Ie, Ye, It, nt = 0, pe, ie, Se, ke, Ve, Ke, Be, $e, He = new i.Buf8(4), et, Xe, ct = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!re || !re.state || !re.output || !re.input && re.avail_in !== 0)
            return E;
          I = re.state, I.mode === ne && (I.mode = te), fe = re.next_out, De = re.output, L = re.avail_out, g = re.next_in, Ee = re.input, le = re.avail_in, K = I.hold, ce = I.bits, Le = le, Ae = L, $e = b;
          e:
            for (; ; )
              switch (I.mode) {
                case j:
                  if (I.wrap === 0) {
                    I.mode = te;
                    break;
                  }
                  for (; ce < 16; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (I.wrap & 2 && K === 35615) {
                    I.check = 0, He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0), K = 0, ce = 0, I.mode = N;
                    break;
                  }
                  if (I.flags = 0, I.head && (I.head.done = !1), !(I.wrap & 1) || /* check if zlib header allowed */
                  (((K & 255) << 8) + (K >> 8)) % 31) {
                    re.msg = "incorrect header check", I.mode = Oe;
                    break;
                  }
                  if ((K & 15) !== A) {
                    re.msg = "unknown compression method", I.mode = Oe;
                    break;
                  }
                  if (K >>>= 4, ce -= 4, Be = (K & 15) + 8, I.wbits === 0)
                    I.wbits = Be;
                  else if (Be > I.wbits) {
                    re.msg = "invalid window size", I.mode = Oe;
                    break;
                  }
                  I.dmax = 1 << Be, re.adler = I.check = 1, I.mode = K & 512 ? k : ne, K = 0, ce = 0;
                  break;
                case N:
                  for (; ce < 16; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (I.flags = K, (I.flags & 255) !== A) {
                    re.msg = "unknown compression method", I.mode = Oe;
                    break;
                  }
                  if (I.flags & 57344) {
                    re.msg = "unknown header flags set", I.mode = Oe;
                    break;
                  }
                  I.head && (I.head.text = K >> 8 & 1), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0, I.mode = O;
                /* falls through */
                case O:
                  for (; ce < 32; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.head && (I.head.time = K), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, He[2] = K >>> 16 & 255, He[3] = K >>> 24 & 255, I.check = s(I.check, He, 4, 0)), K = 0, ce = 0, I.mode = D;
                /* falls through */
                case D:
                  for (; ce < 16; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  I.head && (I.head.xflags = K & 255, I.head.os = K >> 8), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0, I.mode = H;
                /* falls through */
                case H:
                  if (I.flags & 1024) {
                    for (; ce < 16; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    I.length = K, I.head && (I.head.extra_len = K), I.flags & 512 && (He[0] = K & 255, He[1] = K >>> 8 & 255, I.check = s(I.check, He, 2, 0)), K = 0, ce = 0;
                  } else I.head && (I.head.extra = null);
                  I.mode = G;
                /* falls through */
                case G:
                  if (I.flags & 1024 && (Ie = I.length, Ie > le && (Ie = le), Ie && (I.head && (Be = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), i.arraySet(
                    I.head.extra,
                    Ee,
                    g,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    Ie,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    Be
                  )), I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, I.length -= Ie), I.length))
                    break e;
                  I.length = 0, I.mode = X;
                /* falls through */
                case X:
                  if (I.flags & 2048) {
                    if (le === 0)
                      break e;
                    Ie = 0;
                    do
                      Be = Ee[g + Ie++], I.head && Be && I.length < 65536 && (I.head.name += String.fromCharCode(Be));
                    while (Be && Ie < le);
                    if (I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, Be)
                      break e;
                  } else I.head && (I.head.name = null);
                  I.length = 0, I.mode = Q;
                /* falls through */
                case Q:
                  if (I.flags & 4096) {
                    if (le === 0)
                      break e;
                    Ie = 0;
                    do
                      Be = Ee[g + Ie++], I.head && Be && I.length < 65536 && (I.head.comment += String.fromCharCode(Be));
                    while (Be && Ie < le);
                    if (I.flags & 512 && (I.check = s(I.check, Ee, Ie, g)), le -= Ie, g += Ie, Be)
                      break e;
                  } else I.head && (I.head.comment = null);
                  I.mode = M;
                /* falls through */
                case M:
                  if (I.flags & 512) {
                    for (; ce < 16; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    if (K !== (I.check & 65535)) {
                      re.msg = "header crc mismatch", I.mode = Oe;
                      break;
                    }
                    K = 0, ce = 0;
                  }
                  I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), re.adler = I.check = 0, I.mode = ne;
                  break;
                case k:
                  for (; ce < 32; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  re.adler = I.check = J(K), K = 0, ce = 0, I.mode = $;
                /* falls through */
                case $:
                  if (I.havedict === 0)
                    return re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, x;
                  re.adler = I.check = 1, I.mode = ne;
                /* falls through */
                case ne:
                  if (me === y || me === f)
                    break e;
                /* falls through */
                case te:
                  if (I.last) {
                    K >>>= ce & 7, ce -= ce & 7, I.mode = Y;
                    break;
                  }
                  for (; ce < 3; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  switch (I.last = K & 1, K >>>= 1, ce -= 1, K & 3) {
                    case 0:
                      I.mode = de;
                      break;
                    case 1:
                      if (Je(I), I.mode = V, me === f) {
                        K >>>= 2, ce -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      I.mode = Z;
                      break;
                    case 3:
                      re.msg = "invalid block type", I.mode = Oe;
                  }
                  K >>>= 2, ce -= 2;
                  break;
                case de:
                  for (K >>>= ce & 7, ce -= ce & 7; ce < 32; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if ((K & 65535) !== (K >>> 16 ^ 65535)) {
                    re.msg = "invalid stored block lengths", I.mode = Oe;
                    break;
                  }
                  if (I.length = K & 65535, K = 0, ce = 0, I.mode = ae, me === f)
                    break e;
                /* falls through */
                case ae:
                  I.mode = z;
                /* falls through */
                case z:
                  if (Ie = I.length, Ie) {
                    if (Ie > le && (Ie = le), Ie > L && (Ie = L), Ie === 0)
                      break e;
                    i.arraySet(De, Ee, g, Ie, fe), le -= Ie, g += Ie, L -= Ie, fe += Ie, I.length -= Ie;
                    break;
                  }
                  I.mode = ne;
                  break;
                case Z:
                  for (; ce < 14; ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (I.nlen = (K & 31) + 257, K >>>= 5, ce -= 5, I.ndist = (K & 31) + 1, K >>>= 5, ce -= 5, I.ncode = (K & 15) + 4, K >>>= 4, ce -= 4, I.nlen > 286 || I.ndist > 30) {
                    re.msg = "too many length or distance symbols", I.mode = Oe;
                    break;
                  }
                  I.have = 0, I.mode = oe;
                /* falls through */
                case oe:
                  for (; I.have < I.ncode; ) {
                    for (; ce < 3; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    I.lens[ct[I.have++]] = K & 7, K >>>= 3, ce -= 3;
                  }
                  for (; I.have < 19; )
                    I.lens[ct[I.have++]] = 0;
                  if (I.lencode = I.lendyn, I.lenbits = 7, et = { bits: I.lenbits }, $e = p(l, I.lens, 0, 19, I.lencode, 0, I.work, et), I.lenbits = et.bits, $e) {
                    re.msg = "invalid code lengths set", I.mode = Oe;
                    break;
                  }
                  I.have = 0, I.mode = ye;
                /* falls through */
                case ye:
                  for (; I.have < I.nlen + I.ndist; ) {
                    for (; nt = I.lencode[K & (1 << I.lenbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    if (Se < 16)
                      K >>>= pe, ce -= pe, I.lens[I.have++] = Se;
                    else {
                      if (Se === 16) {
                        for (Xe = pe + 2; ce < Xe; ) {
                          if (le === 0)
                            break e;
                          le--, K += Ee[g++] << ce, ce += 8;
                        }
                        if (K >>>= pe, ce -= pe, I.have === 0) {
                          re.msg = "invalid bit length repeat", I.mode = Oe;
                          break;
                        }
                        Be = I.lens[I.have - 1], Ie = 3 + (K & 3), K >>>= 2, ce -= 2;
                      } else if (Se === 17) {
                        for (Xe = pe + 3; ce < Xe; ) {
                          if (le === 0)
                            break e;
                          le--, K += Ee[g++] << ce, ce += 8;
                        }
                        K >>>= pe, ce -= pe, Be = 0, Ie = 3 + (K & 7), K >>>= 3, ce -= 3;
                      } else {
                        for (Xe = pe + 7; ce < Xe; ) {
                          if (le === 0)
                            break e;
                          le--, K += Ee[g++] << ce, ce += 8;
                        }
                        K >>>= pe, ce -= pe, Be = 0, Ie = 11 + (K & 127), K >>>= 7, ce -= 7;
                      }
                      if (I.have + Ie > I.nlen + I.ndist) {
                        re.msg = "invalid bit length repeat", I.mode = Oe;
                        break;
                      }
                      for (; Ie--; )
                        I.lens[I.have++] = Be;
                    }
                  }
                  if (I.mode === Oe)
                    break;
                  if (I.lens[256] === 0) {
                    re.msg = "invalid code -- missing end-of-block", I.mode = Oe;
                    break;
                  }
                  if (I.lenbits = 9, et = { bits: I.lenbits }, $e = p(d, I.lens, 0, I.nlen, I.lencode, 0, I.work, et), I.lenbits = et.bits, $e) {
                    re.msg = "invalid literal/lengths set", I.mode = Oe;
                    break;
                  }
                  if (I.distbits = 6, I.distcode = I.distdyn, et = { bits: I.distbits }, $e = p(u, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, et), I.distbits = et.bits, $e) {
                    re.msg = "invalid distances set", I.mode = Oe;
                    break;
                  }
                  if (I.mode = V, me === f)
                    break e;
                /* falls through */
                case V:
                  I.mode = q;
                /* falls through */
                case q:
                  if (le >= 6 && L >= 258) {
                    re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, c(re, Ae), fe = re.next_out, De = re.output, L = re.avail_out, g = re.next_in, Ee = re.input, le = re.avail_in, K = I.hold, ce = I.bits, I.mode === ne && (I.back = -1);
                    break;
                  }
                  for (I.back = 0; nt = I.lencode[K & (1 << I.lenbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (ie && !(ie & 240)) {
                    for (ke = pe, Ve = ie, Ke = Se; nt = I.lencode[Ke + ((K & (1 << ke + Ve) - 1) >> ke)], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(ke + pe <= ce); ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    K >>>= ke, ce -= ke, I.back += ke;
                  }
                  if (K >>>= pe, ce -= pe, I.back += pe, I.length = Se, ie === 0) {
                    I.mode = W;
                    break;
                  }
                  if (ie & 32) {
                    I.back = -1, I.mode = ne;
                    break;
                  }
                  if (ie & 64) {
                    re.msg = "invalid literal/length code", I.mode = Oe;
                    break;
                  }
                  I.extra = ie & 15, I.mode = ee;
                /* falls through */
                case ee:
                  if (I.extra) {
                    for (Xe = I.extra; ce < Xe; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    I.length += K & (1 << I.extra) - 1, K >>>= I.extra, ce -= I.extra, I.back += I.extra;
                  }
                  I.was = I.length, I.mode = ue;
                /* falls through */
                case ue:
                  for (; nt = I.distcode[K & (1 << I.distbits) - 1], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(pe <= ce); ) {
                    if (le === 0)
                      break e;
                    le--, K += Ee[g++] << ce, ce += 8;
                  }
                  if (!(ie & 240)) {
                    for (ke = pe, Ve = ie, Ke = Se; nt = I.distcode[Ke + ((K & (1 << ke + Ve) - 1) >> ke)], pe = nt >>> 24, ie = nt >>> 16 & 255, Se = nt & 65535, !(ke + pe <= ce); ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    K >>>= ke, ce -= ke, I.back += ke;
                  }
                  if (K >>>= pe, ce -= pe, I.back += pe, ie & 64) {
                    re.msg = "invalid distance code", I.mode = Oe;
                    break;
                  }
                  I.offset = Se, I.extra = ie & 15, I.mode = ge;
                /* falls through */
                case ge:
                  if (I.extra) {
                    for (Xe = I.extra; ce < Xe; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    I.offset += K & (1 << I.extra) - 1, K >>>= I.extra, ce -= I.extra, I.back += I.extra;
                  }
                  if (I.offset > I.dmax) {
                    re.msg = "invalid distance too far back", I.mode = Oe;
                    break;
                  }
                  I.mode = he;
                /* falls through */
                case he:
                  if (L === 0)
                    break e;
                  if (Ie = Ae - L, I.offset > Ie) {
                    if (Ie = I.offset - Ie, Ie > I.whave && I.sane) {
                      re.msg = "invalid distance too far back", I.mode = Oe;
                      break;
                    }
                    Ie > I.wnext ? (Ie -= I.wnext, Ye = I.wsize - Ie) : Ye = I.wnext - Ie, Ie > I.length && (Ie = I.length), It = I.window;
                  } else
                    It = De, Ye = fe - I.offset, Ie = I.length;
                  Ie > L && (Ie = L), L -= Ie, I.length -= Ie;
                  do
                    De[fe++] = It[Ye++];
                  while (--Ie);
                  I.length === 0 && (I.mode = q);
                  break;
                case W:
                  if (L === 0)
                    break e;
                  De[fe++] = I.length, L--, I.mode = q;
                  break;
                case Y:
                  if (I.wrap) {
                    for (; ce < 32; ) {
                      if (le === 0)
                        break e;
                      le--, K |= Ee[g++] << ce, ce += 8;
                    }
                    if (Ae -= L, re.total_out += Ae, I.total += Ae, Ae && (re.adler = I.check = /*UPDATE(state.check, put - _out, _out);*/
                    I.flags ? s(I.check, De, Ae, fe - Ae) : a(I.check, De, Ae, fe - Ae)), Ae = L, (I.flags ? K : J(K)) !== I.check) {
                      re.msg = "incorrect data check", I.mode = Oe;
                      break;
                    }
                    K = 0, ce = 0;
                  }
                  I.mode = se;
                /* falls through */
                case se:
                  if (I.wrap && I.flags) {
                    for (; ce < 32; ) {
                      if (le === 0)
                        break e;
                      le--, K += Ee[g++] << ce, ce += 8;
                    }
                    if (K !== (I.total & 4294967295)) {
                      re.msg = "incorrect length check", I.mode = Oe;
                      break;
                    }
                    K = 0, ce = 0;
                  }
                  I.mode = Te;
                /* falls through */
                case Te:
                  $e = w;
                  break e;
                case Oe:
                  $e = T;
                  break e;
                case B:
                  return C;
                case U:
                /* falls through */
                default:
                  return E;
              }
          return re.next_out = fe, re.avail_out = L, re.next_in = g, re.avail_in = le, I.hold = K, I.bits = ce, (I.wsize || Ae !== re.avail_out && I.mode < Oe && (I.mode < Y || me !== h)) && Ze(re, re.output, re.next_out, Ae - re.avail_out), Le -= re.avail_in, Ae -= re.avail_out, re.total_in += Le, re.total_out += Ae, I.total += Ae, I.wrap && Ae && (re.adler = I.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          I.flags ? s(I.check, De, Ae, re.next_out - Ae) : a(I.check, De, Ae, re.next_out - Ae)), re.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === ne ? 128 : 0) + (I.mode === V || I.mode === ae ? 256 : 0), (Le === 0 && Ae === 0 || me === h) && $e === b && ($e = R), $e;
        }
        function we(re) {
          if (!re || !re.state)
            return E;
          var me = re.state;
          return me.window && (me.window = null), re.state = null, b;
        }
        function xe(re, me) {
          var I;
          return !re || !re.state || (I = re.state, !(I.wrap & 2)) ? E : (I.head = me, me.done = !1, b);
        }
        function Ce(re, me) {
          var I = me.length, Ee, De, g;
          return !re || !re.state || (Ee = re.state, Ee.wrap !== 0 && Ee.mode !== $) ? E : Ee.mode === $ && (De = 1, De = a(De, me, I, 0), De !== Ee.check) ? T : (g = Ze(re, me, I, I), g ? (Ee.mode = B, C) : (Ee.havedict = 1, b));
        }
        n.inflateReset = je, n.inflateReset2 = qe, n.inflateResetKeep = Re, n.inflateInit = We, n.inflateInit2 = ze, n.inflate = F, n.inflateEnd = we, n.inflateGetHeader = xe, n.inflateSetDictionary = Ce, n.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(r, o, n) {
        var i = r("../utils/common"), a = 15, s = 852, c = 592, p = 0, l = 1, d = 2, u = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ], h = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ], y = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ], f = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        o.exports = function(w, x, E, T, C, R, A, j) {
          var N = j.bits, O = 0, D = 0, H = 0, G = 0, X = 0, Q = 0, M = 0, k = 0, $ = 0, ne = 0, te, de, ae, z, Z, oe = null, ye = 0, V, q = new i.Buf16(a + 1), ee = new i.Buf16(a + 1), ue = null, ge = 0, he, W, Y;
          for (O = 0; O <= a; O++)
            q[O] = 0;
          for (D = 0; D < T; D++)
            q[x[E + D]]++;
          for (X = N, G = a; G >= 1 && q[G] === 0; G--)
            ;
          if (X > G && (X = G), G === 0)
            return C[R++] = 1 << 24 | 64 << 16 | 0, C[R++] = 1 << 24 | 64 << 16 | 0, j.bits = 1, 0;
          for (H = 1; H < G && q[H] === 0; H++)
            ;
          for (X < H && (X = H), k = 1, O = 1; O <= a; O++)
            if (k <<= 1, k -= q[O], k < 0)
              return -1;
          if (k > 0 && (w === p || G !== 1))
            return -1;
          for (ee[1] = 0, O = 1; O < a; O++)
            ee[O + 1] = ee[O] + q[O];
          for (D = 0; D < T; D++)
            x[E + D] !== 0 && (A[ee[x[E + D]]++] = D);
          if (w === p ? (oe = ue = A, V = 19) : w === l ? (oe = u, ye -= 257, ue = h, ge -= 257, V = 256) : (oe = y, ue = f, V = -1), ne = 0, D = 0, O = H, Z = R, Q = X, M = 0, ae = -1, $ = 1 << X, z = $ - 1, w === l && $ > s || w === d && $ > c)
            return 1;
          for (; ; ) {
            he = O - M, A[D] < V ? (W = 0, Y = A[D]) : A[D] > V ? (W = ue[ge + A[D]], Y = oe[ye + A[D]]) : (W = 96, Y = 0), te = 1 << O - M, de = 1 << Q, H = de;
            do
              de -= te, C[Z + (ne >> M) + de] = he << 24 | W << 16 | Y | 0;
            while (de !== 0);
            for (te = 1 << O - 1; ne & te; )
              te >>= 1;
            if (te !== 0 ? (ne &= te - 1, ne += te) : ne = 0, D++, --q[O] === 0) {
              if (O === G)
                break;
              O = x[E + A[D]];
            }
            if (O > X && (ne & z) !== ae) {
              for (M === 0 && (M = X), Z += H, Q = O - M, k = 1 << Q; Q + M < G && (k -= q[Q + M], !(k <= 0)); )
                Q++, k <<= 1;
              if ($ += 1 << Q, w === l && $ > s || w === d && $ > c)
                return 1;
              ae = ne & z, C[ae] = X << 24 | Q << 16 | Z - R | 0;
            }
          }
          return ne !== 0 && (C[Z + ne] = O - M << 24 | 64 << 16 | 0), j.bits = X, 0;
        };
      }, { "../utils/common": 52 }], 60: [function(r, o, n) {
        o.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 61: [function(r, o, n) {
        var i = r("../utils/common"), a = 4, s = 0, c = 1, p = 2;
        function l(F) {
          for (var we = F.length; --we >= 0; )
            F[we] = 0;
        }
        var d = 0, u = 1, h = 2, y = 3, f = 258, b = 29, w = 256, x = w + 1 + b, E = 30, T = 19, C = 2 * x + 1, R = 15, A = 16, j = 7, N = 256, O = 16, D = 17, H = 18, G = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), X = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Q = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], k = 512, $ = new Array((x + 2) * 2);
        l($);
        var ne = new Array(E * 2);
        l(ne);
        var te = new Array(k);
        l(te);
        var de = new Array(f - y + 1);
        l(de);
        var ae = new Array(b);
        l(ae);
        var z = new Array(E);
        l(z);
        function Z(F, we, xe, Ce, re) {
          this.static_tree = F, this.extra_bits = we, this.extra_base = xe, this.elems = Ce, this.max_length = re, this.has_stree = F && F.length;
        }
        var oe, ye, V;
        function q(F, we) {
          this.dyn_tree = F, this.max_code = 0, this.stat_desc = we;
        }
        function ee(F) {
          return F < 256 ? te[F] : te[256 + (F >>> 7)];
        }
        function ue(F, we) {
          F.pending_buf[F.pending++] = we & 255, F.pending_buf[F.pending++] = we >>> 8 & 255;
        }
        function ge(F, we, xe) {
          F.bi_valid > A - xe ? (F.bi_buf |= we << F.bi_valid & 65535, ue(F, F.bi_buf), F.bi_buf = we >> A - F.bi_valid, F.bi_valid += xe - A) : (F.bi_buf |= we << F.bi_valid & 65535, F.bi_valid += xe);
        }
        function he(F, we, xe) {
          ge(
            F,
            xe[we * 2],
            xe[we * 2 + 1]
            /*.Len*/
          );
        }
        function W(F, we) {
          var xe = 0;
          do
            xe |= F & 1, F >>>= 1, xe <<= 1;
          while (--we > 0);
          return xe >>> 1;
        }
        function Y(F) {
          F.bi_valid === 16 ? (ue(F, F.bi_buf), F.bi_buf = 0, F.bi_valid = 0) : F.bi_valid >= 8 && (F.pending_buf[F.pending++] = F.bi_buf & 255, F.bi_buf >>= 8, F.bi_valid -= 8);
        }
        function se(F, we) {
          var xe = we.dyn_tree, Ce = we.max_code, re = we.stat_desc.static_tree, me = we.stat_desc.has_stree, I = we.stat_desc.extra_bits, Ee = we.stat_desc.extra_base, De = we.stat_desc.max_length, g, fe, le, L, K, ce, Le = 0;
          for (L = 0; L <= R; L++)
            F.bl_count[L] = 0;
          for (xe[F.heap[F.heap_max] * 2 + 1] = 0, g = F.heap_max + 1; g < C; g++)
            fe = F.heap[g], L = xe[xe[fe * 2 + 1] * 2 + 1] + 1, L > De && (L = De, Le++), xe[fe * 2 + 1] = L, !(fe > Ce) && (F.bl_count[L]++, K = 0, fe >= Ee && (K = I[fe - Ee]), ce = xe[fe * 2], F.opt_len += ce * (L + K), me && (F.static_len += ce * (re[fe * 2 + 1] + K)));
          if (Le !== 0) {
            do {
              for (L = De - 1; F.bl_count[L] === 0; )
                L--;
              F.bl_count[L]--, F.bl_count[L + 1] += 2, F.bl_count[De]--, Le -= 2;
            } while (Le > 0);
            for (L = De; L !== 0; L--)
              for (fe = F.bl_count[L]; fe !== 0; )
                le = F.heap[--g], !(le > Ce) && (xe[le * 2 + 1] !== L && (F.opt_len += (L - xe[le * 2 + 1]) * xe[le * 2], xe[le * 2 + 1] = L), fe--);
          }
        }
        function Te(F, we, xe) {
          var Ce = new Array(R + 1), re = 0, me, I;
          for (me = 1; me <= R; me++)
            Ce[me] = re = re + xe[me - 1] << 1;
          for (I = 0; I <= we; I++) {
            var Ee = F[I * 2 + 1];
            Ee !== 0 && (F[I * 2] = W(Ce[Ee]++, Ee));
          }
        }
        function Oe() {
          var F, we, xe, Ce, re, me = new Array(R + 1);
          for (xe = 0, Ce = 0; Ce < b - 1; Ce++)
            for (ae[Ce] = xe, F = 0; F < 1 << G[Ce]; F++)
              de[xe++] = Ce;
          for (de[xe - 1] = Ce, re = 0, Ce = 0; Ce < 16; Ce++)
            for (z[Ce] = re, F = 0; F < 1 << X[Ce]; F++)
              te[re++] = Ce;
          for (re >>= 7; Ce < E; Ce++)
            for (z[Ce] = re << 7, F = 0; F < 1 << X[Ce] - 7; F++)
              te[256 + re++] = Ce;
          for (we = 0; we <= R; we++)
            me[we] = 0;
          for (F = 0; F <= 143; )
            $[F * 2 + 1] = 8, F++, me[8]++;
          for (; F <= 255; )
            $[F * 2 + 1] = 9, F++, me[9]++;
          for (; F <= 279; )
            $[F * 2 + 1] = 7, F++, me[7]++;
          for (; F <= 287; )
            $[F * 2 + 1] = 8, F++, me[8]++;
          for (Te($, x + 1, me), F = 0; F < E; F++)
            ne[F * 2 + 1] = 5, ne[F * 2] = W(F, 5);
          oe = new Z($, G, w + 1, x, R), ye = new Z(ne, X, 0, E, R), V = new Z(new Array(0), Q, 0, T, j);
        }
        function B(F) {
          var we;
          for (we = 0; we < x; we++)
            F.dyn_ltree[we * 2] = 0;
          for (we = 0; we < E; we++)
            F.dyn_dtree[we * 2] = 0;
          for (we = 0; we < T; we++)
            F.bl_tree[we * 2] = 0;
          F.dyn_ltree[N * 2] = 1, F.opt_len = F.static_len = 0, F.last_lit = F.matches = 0;
        }
        function U(F) {
          F.bi_valid > 8 ? ue(F, F.bi_buf) : F.bi_valid > 0 && (F.pending_buf[F.pending++] = F.bi_buf), F.bi_buf = 0, F.bi_valid = 0;
        }
        function _(F, we, xe, Ce) {
          U(F), ue(F, xe), ue(F, ~xe), i.arraySet(F.pending_buf, F.window, we, xe, F.pending), F.pending += xe;
        }
        function v(F, we, xe, Ce) {
          var re = we * 2, me = xe * 2;
          return F[re] < F[me] || F[re] === F[me] && Ce[we] <= Ce[xe];
        }
        function S(F, we, xe) {
          for (var Ce = F.heap[xe], re = xe << 1; re <= F.heap_len && (re < F.heap_len && v(we, F.heap[re + 1], F.heap[re], F.depth) && re++, !v(we, Ce, F.heap[re], F.depth)); )
            F.heap[xe] = F.heap[re], xe = re, re <<= 1;
          F.heap[xe] = Ce;
        }
        function P(F, we, xe) {
          var Ce, re, me = 0, I, Ee;
          if (F.last_lit !== 0)
            do
              Ce = F.pending_buf[F.d_buf + me * 2] << 8 | F.pending_buf[F.d_buf + me * 2 + 1], re = F.pending_buf[F.l_buf + me], me++, Ce === 0 ? he(F, re, we) : (I = de[re], he(F, I + w + 1, we), Ee = G[I], Ee !== 0 && (re -= ae[I], ge(F, re, Ee)), Ce--, I = ee(Ce), he(F, I, xe), Ee = X[I], Ee !== 0 && (Ce -= z[I], ge(F, Ce, Ee)));
            while (me < F.last_lit);
          he(F, N, we);
        }
        function J(F, we) {
          var xe = we.dyn_tree, Ce = we.stat_desc.static_tree, re = we.stat_desc.has_stree, me = we.stat_desc.elems, I, Ee, De = -1, g;
          for (F.heap_len = 0, F.heap_max = C, I = 0; I < me; I++)
            xe[I * 2] !== 0 ? (F.heap[++F.heap_len] = De = I, F.depth[I] = 0) : xe[I * 2 + 1] = 0;
          for (; F.heap_len < 2; )
            g = F.heap[++F.heap_len] = De < 2 ? ++De : 0, xe[g * 2] = 1, F.depth[g] = 0, F.opt_len--, re && (F.static_len -= Ce[g * 2 + 1]);
          for (we.max_code = De, I = F.heap_len >> 1; I >= 1; I--)
            S(F, xe, I);
          g = me;
          do
            I = F.heap[
              1
              /*SMALLEST*/
            ], F.heap[
              1
              /*SMALLEST*/
            ] = F.heap[F.heap_len--], S(
              F,
              xe,
              1
              /*SMALLEST*/
            ), Ee = F.heap[
              1
              /*SMALLEST*/
            ], F.heap[--F.heap_max] = I, F.heap[--F.heap_max] = Ee, xe[g * 2] = xe[I * 2] + xe[Ee * 2], F.depth[g] = (F.depth[I] >= F.depth[Ee] ? F.depth[I] : F.depth[Ee]) + 1, xe[I * 2 + 1] = xe[Ee * 2 + 1] = g, F.heap[
              1
              /*SMALLEST*/
            ] = g++, S(
              F,
              xe,
              1
              /*SMALLEST*/
            );
          while (F.heap_len >= 2);
          F.heap[--F.heap_max] = F.heap[
            1
            /*SMALLEST*/
          ], se(F, we), Te(xe, De, F.bl_count);
        }
        function ve(F, we, xe) {
          var Ce, re = -1, me, I = we[0 * 2 + 1], Ee = 0, De = 7, g = 4;
          for (I === 0 && (De = 138, g = 3), we[(xe + 1) * 2 + 1] = 65535, Ce = 0; Ce <= xe; Ce++)
            me = I, I = we[(Ce + 1) * 2 + 1], !(++Ee < De && me === I) && (Ee < g ? F.bl_tree[me * 2] += Ee : me !== 0 ? (me !== re && F.bl_tree[me * 2]++, F.bl_tree[O * 2]++) : Ee <= 10 ? F.bl_tree[D * 2]++ : F.bl_tree[H * 2]++, Ee = 0, re = me, I === 0 ? (De = 138, g = 3) : me === I ? (De = 6, g = 3) : (De = 7, g = 4));
        }
        function Re(F, we, xe) {
          var Ce, re = -1, me, I = we[0 * 2 + 1], Ee = 0, De = 7, g = 4;
          for (I === 0 && (De = 138, g = 3), Ce = 0; Ce <= xe; Ce++)
            if (me = I, I = we[(Ce + 1) * 2 + 1], !(++Ee < De && me === I)) {
              if (Ee < g)
                do
                  he(F, me, F.bl_tree);
                while (--Ee !== 0);
              else me !== 0 ? (me !== re && (he(F, me, F.bl_tree), Ee--), he(F, O, F.bl_tree), ge(F, Ee - 3, 2)) : Ee <= 10 ? (he(F, D, F.bl_tree), ge(F, Ee - 3, 3)) : (he(F, H, F.bl_tree), ge(F, Ee - 11, 7));
              Ee = 0, re = me, I === 0 ? (De = 138, g = 3) : me === I ? (De = 6, g = 3) : (De = 7, g = 4);
            }
        }
        function je(F) {
          var we;
          for (ve(F, F.dyn_ltree, F.l_desc.max_code), ve(F, F.dyn_dtree, F.d_desc.max_code), J(F, F.bl_desc), we = T - 1; we >= 3 && F.bl_tree[M[we] * 2 + 1] === 0; we--)
            ;
          return F.opt_len += 3 * (we + 1) + 5 + 5 + 4, we;
        }
        function qe(F, we, xe, Ce) {
          var re;
          for (ge(F, we - 257, 5), ge(F, xe - 1, 5), ge(F, Ce - 4, 4), re = 0; re < Ce; re++)
            ge(F, F.bl_tree[M[re] * 2 + 1], 3);
          Re(F, F.dyn_ltree, we - 1), Re(F, F.dyn_dtree, xe - 1);
        }
        function ze(F) {
          var we = 4093624447, xe;
          for (xe = 0; xe <= 31; xe++, we >>>= 1)
            if (we & 1 && F.dyn_ltree[xe * 2] !== 0)
              return s;
          if (F.dyn_ltree[9 * 2] !== 0 || F.dyn_ltree[10 * 2] !== 0 || F.dyn_ltree[13 * 2] !== 0)
            return c;
          for (xe = 32; xe < w; xe++)
            if (F.dyn_ltree[xe * 2] !== 0)
              return c;
          return s;
        }
        var We = !1;
        function Fe(F) {
          We || (Oe(), We = !0), F.l_desc = new q(F.dyn_ltree, oe), F.d_desc = new q(F.dyn_dtree, ye), F.bl_desc = new q(F.bl_tree, V), F.bi_buf = 0, F.bi_valid = 0, B(F);
        }
        function rt(F, we, xe, Ce) {
          ge(F, (d << 1) + (Ce ? 1 : 0), 3), _(F, we, xe);
        }
        function Ge(F) {
          ge(F, u << 1, 3), he(F, N, $), Y(F);
        }
        function Je(F, we, xe, Ce) {
          var re, me, I = 0;
          F.level > 0 ? (F.strm.data_type === p && (F.strm.data_type = ze(F)), J(F, F.l_desc), J(F, F.d_desc), I = je(F), re = F.opt_len + 3 + 7 >>> 3, me = F.static_len + 3 + 7 >>> 3, me <= re && (re = me)) : re = me = xe + 5, xe + 4 <= re && we !== -1 ? rt(F, we, xe, Ce) : F.strategy === a || me === re ? (ge(F, (u << 1) + (Ce ? 1 : 0), 3), P(F, $, ne)) : (ge(F, (h << 1) + (Ce ? 1 : 0), 3), qe(F, F.l_desc.max_code + 1, F.d_desc.max_code + 1, I + 1), P(F, F.dyn_ltree, F.dyn_dtree)), B(F), Ce && U(F);
        }
        function Ze(F, we, xe) {
          return F.pending_buf[F.d_buf + F.last_lit * 2] = we >>> 8 & 255, F.pending_buf[F.d_buf + F.last_lit * 2 + 1] = we & 255, F.pending_buf[F.l_buf + F.last_lit] = xe & 255, F.last_lit++, we === 0 ? F.dyn_ltree[xe * 2]++ : (F.matches++, we--, F.dyn_ltree[(de[xe] + w + 1) * 2]++, F.dyn_dtree[ee(we) * 2]++), F.last_lit === F.lit_bufsize - 1;
        }
        n._tr_init = Fe, n._tr_stored_block = rt, n._tr_flush_block = Je, n._tr_tally = Ze, n._tr_align = Ge;
      }, { "../utils/common": 52 }], 62: [function(r, o, n) {
        function i() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        o.exports = i;
      }, {}], 63: [function(r, o, n) {
        var i = o.exports = {}, a, s;
        function c() {
          throw new Error("setTimeout has not been defined");
        }
        function p() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? a = setTimeout : a = c;
          } catch {
            a = c;
          }
          try {
            typeof clearTimeout == "function" ? s = clearTimeout : s = p;
          } catch {
            s = p;
          }
        })();
        function l(T) {
          if (a === setTimeout)
            return setTimeout(T, 0);
          if ((a === c || !a) && setTimeout)
            return a = setTimeout, setTimeout(T, 0);
          try {
            return a(T, 0);
          } catch {
            try {
              return a.call(null, T, 0);
            } catch {
              return a.call(this, T, 0);
            }
          }
        }
        function d(T) {
          if (s === clearTimeout)
            return clearTimeout(T);
          if ((s === p || !s) && clearTimeout)
            return s = clearTimeout, clearTimeout(T);
          try {
            return s(T);
          } catch {
            try {
              return s.call(null, T);
            } catch {
              return s.call(this, T);
            }
          }
        }
        var u = [], h = !1, y, f = -1;
        function b() {
          !h || !y || (h = !1, y.length ? u = y.concat(u) : f = -1, u.length && w());
        }
        function w() {
          if (!h) {
            var T = l(b);
            h = !0;
            for (var C = u.length; C; ) {
              for (y = u, u = []; ++f < C; )
                y && y[f].run();
              f = -1, C = u.length;
            }
            y = null, h = !1, d(T);
          }
        }
        i.nextTick = function(T) {
          var C = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var R = 1; R < arguments.length; R++)
              C[R - 1] = arguments[R];
          u.push(new x(T, C)), u.length === 1 && !h && l(w);
        };
        function x(T, C) {
          this.fun = T, this.array = C;
        }
        x.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {};
        function E() {
        }
        i.on = E, i.addListener = E, i.once = E, i.off = E, i.removeListener = E, i.removeAllListeners = E, i.emit = E, i.prependListener = E, i.prependOnceListener = E, i.listeners = function(T) {
          return [];
        }, i.binding = function(T) {
          throw new Error("process.binding is not supported");
        }, i.cwd = function() {
          return "/";
        }, i.chdir = function(T) {
          throw new Error("process.chdir is not supported");
        }, i.umask = function() {
          return 0;
        };
      }, {}], 64: [function(r, o, n) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        var i = r("buffer"), a = i.Buffer;
        function s(p, l) {
          for (var d in p)
            l[d] = p[d];
        }
        a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? o.exports = i : (s(i, n), n.Buffer = c);
        function c(p, l, d) {
          return a(p, l, d);
        }
        c.prototype = Object.create(a.prototype), s(a, c), c.from = function(p, l, d) {
          if (typeof p == "number")
            throw new TypeError("Argument must not be a number");
          return a(p, l, d);
        }, c.alloc = function(p, l, d) {
          if (typeof p != "number")
            throw new TypeError("Argument must be a number");
          var u = a(p);
          return l !== void 0 ? typeof d == "string" ? u.fill(l, d) : u.fill(l) : u.fill(0), u;
        }, c.allocUnsafe = function(p) {
          if (typeof p != "number")
            throw new TypeError("Argument must be a number");
          return a(p);
        }, c.allocUnsafeSlow = function(p) {
          if (typeof p != "number")
            throw new TypeError("Argument must be a number");
          return i.SlowBuffer(p);
        };
      }, { buffer: 32 }], 65: [function(r, o, n) {
        o.exports = s;
        var i = r("events").EventEmitter, a = r("inherits");
        a(s, i), s.Readable = r("readable-stream/lib/_stream_readable.js"), s.Writable = r("readable-stream/lib/_stream_writable.js"), s.Duplex = r("readable-stream/lib/_stream_duplex.js"), s.Transform = r("readable-stream/lib/_stream_transform.js"), s.PassThrough = r("readable-stream/lib/_stream_passthrough.js"), s.finished = r("readable-stream/lib/internal/streams/end-of-stream.js"), s.pipeline = r("readable-stream/lib/internal/streams/pipeline.js"), s.Stream = s;
        function s() {
          i.call(this);
        }
        s.prototype.pipe = function(c, p) {
          var l = this;
          function d(x) {
            c.writable && c.write(x) === !1 && l.pause && l.pause();
          }
          l.on("data", d);
          function u() {
            l.readable && l.resume && l.resume();
          }
          c.on("drain", u), !c._isStdio && (!p || p.end !== !1) && (l.on("end", y), l.on("close", f));
          var h = !1;
          function y() {
            h || (h = !0, c.end());
          }
          function f() {
            h || (h = !0, typeof c.destroy == "function" && c.destroy());
          }
          function b(x) {
            if (w(), i.listenerCount(this, "error") === 0)
              throw x;
          }
          l.on("error", b), c.on("error", b);
          function w() {
            l.removeListener("data", d), c.removeListener("drain", u), l.removeListener("end", y), l.removeListener("close", f), l.removeListener("error", b), c.removeListener("error", b), l.removeListener("end", w), l.removeListener("close", w), c.removeListener("close", w);
          }
          return l.on("end", w), l.on("close", w), c.on("close", w), c.emit("pipe", l), c;
        };
      }, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(r, o, n) {
        function i(u, h) {
          u.prototype = Object.create(h.prototype), u.prototype.constructor = u, u.__proto__ = h;
        }
        var a = {};
        function s(u, h, y) {
          y || (y = Error);
          function f(w, x, E) {
            return typeof h == "string" ? h : h(w, x, E);
          }
          var b = /* @__PURE__ */ function(w) {
            i(x, w);
            function x(E, T, C) {
              return w.call(this, f(E, T, C)) || this;
            }
            return x;
          }(y);
          b.prototype.name = y.name, b.prototype.code = u, a[u] = b;
        }
        function c(u, h) {
          if (Array.isArray(u)) {
            var y = u.length;
            return u = u.map(function(f) {
              return String(f);
            }), y > 2 ? "one of ".concat(h, " ").concat(u.slice(0, y - 1).join(", "), ", or ") + u[y - 1] : y === 2 ? "one of ".concat(h, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(h, " ").concat(u[0]);
          } else
            return "of ".concat(h, " ").concat(String(u));
        }
        function p(u, h, y) {
          return u.substr(0, h.length) === h;
        }
        function l(u, h, y) {
          return (y === void 0 || y > u.length) && (y = u.length), u.substring(y - h.length, y) === h;
        }
        function d(u, h, y) {
          return typeof y != "number" && (y = 0), y + h.length > u.length ? !1 : u.indexOf(h, y) !== -1;
        }
        s("ERR_INVALID_OPT_VALUE", function(u, h) {
          return 'The value "' + h + '" is invalid for option "' + u + '"';
        }, TypeError), s("ERR_INVALID_ARG_TYPE", function(u, h, y) {
          var f;
          typeof h == "string" && p(h, "not ") ? (f = "must not be", h = h.replace(/^not /, "")) : f = "must be";
          var b;
          if (l(u, " argument"))
            b = "The ".concat(u, " ").concat(f, " ").concat(c(h, "type"));
          else {
            var w = d(u, ".") ? "property" : "argument";
            b = 'The "'.concat(u, '" ').concat(w, " ").concat(f, " ").concat(c(h, "type"));
          }
          return b += ". Received type ".concat(typeof y), b;
        }, TypeError), s("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), s("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
          return "The " + u + " method is not implemented";
        }), s("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), s("ERR_STREAM_DESTROYED", function(u) {
          return "Cannot call " + u + " after a stream was destroyed";
        }), s("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), s("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), s("ERR_STREAM_WRITE_AFTER_END", "write after end"), s("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), s("ERR_UNKNOWN_ENCODING", function(u) {
          return "Unknown encoding: " + u;
        }, TypeError), s("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), o.exports.codes = a;
      }, {}], 67: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = Object.keys || function(f) {
              var b = [];
              for (var w in f)
                b.push(w);
              return b;
            };
            o.exports = u;
            var s = r("./_stream_readable"), c = r("./_stream_writable");
            r("inherits")(u, s);
            for (var p = a(c.prototype), l = 0; l < p.length; l++) {
              var d = p[l];
              u.prototype[d] || (u.prototype[d] = c.prototype[d]);
            }
            function u(f) {
              if (!(this instanceof u)) return new u(f);
              s.call(this, f), c.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h)));
            }
            Object.defineProperty(u.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState.highWaterMark;
              }
            }), Object.defineProperty(u.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState && this._writableState.getBuffer();
              }
            }), Object.defineProperty(u.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState.length;
              }
            });
            function h() {
              this._writableState.ended || i.nextTick(y, this);
            }
            function y(f) {
              f.end();
            }
            Object.defineProperty(u.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function(b) {
                this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = b, this._writableState.destroyed = b);
              }
            });
          }).call(this);
        }).call(this, r("_process"));
      }, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(r, o, n) {
        o.exports = a;
        var i = r("./_stream_transform");
        r("inherits")(a, i);
        function a(s) {
          if (!(this instanceof a)) return new a(s);
          i.call(this, s);
        }
        a.prototype._transform = function(s, c, p) {
          p(null, s);
        };
      }, { "./_stream_transform": 70, inherits: 46 }], 69: [function(r, o, n) {
        (function(i, a) {
          (function() {
            o.exports = M;
            var s;
            M.ReadableState = Q, r("events").EventEmitter;
            var c = function(U, _) {
              return U.listeners(_).length;
            }, p = r("./internal/streams/stream"), l = r("buffer").Buffer, d = a.Uint8Array || function() {
            };
            function u(B) {
              return l.from(B);
            }
            function h(B) {
              return l.isBuffer(B) || B instanceof d;
            }
            var y = r("util"), f;
            y && y.debuglog ? f = y.debuglog("stream") : f = function() {
            };
            var b = r("./internal/streams/buffer_list"), w = r("./internal/streams/destroy"), x = r("./internal/streams/state"), E = x.getHighWaterMark, T = r("../errors").codes, C = T.ERR_INVALID_ARG_TYPE, R = T.ERR_STREAM_PUSH_AFTER_EOF, A = T.ERR_METHOD_NOT_IMPLEMENTED, j = T.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, N, O, D;
            r("inherits")(M, p);
            var H = w.errorOrDestroy, G = ["error", "close", "destroy", "pause", "resume"];
            function X(B, U, _) {
              if (typeof B.prependListener == "function") return B.prependListener(U, _);
              !B._events || !B._events[U] ? B.on(U, _) : Array.isArray(B._events[U]) ? B._events[U].unshift(_) : B._events[U] = [_, B._events[U]];
            }
            function Q(B, U, _) {
              s = s || r("./_stream_duplex"), B = B || {}, typeof _ != "boolean" && (_ = U instanceof s), this.objectMode = !!B.objectMode, _ && (this.objectMode = this.objectMode || !!B.readableObjectMode), this.highWaterMark = E(this, B, "readableHighWaterMark", _), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = B.emitClose !== !1, this.autoDestroy = !!B.autoDestroy, this.destroyed = !1, this.defaultEncoding = B.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, B.encoding && (N || (N = r("string_decoder/").StringDecoder), this.decoder = new N(B.encoding), this.encoding = B.encoding);
            }
            function M(B) {
              if (s = s || r("./_stream_duplex"), !(this instanceof M)) return new M(B);
              var U = this instanceof s;
              this._readableState = new Q(B, this, U), this.readable = !0, B && (typeof B.read == "function" && (this._read = B.read), typeof B.destroy == "function" && (this._destroy = B.destroy)), p.call(this);
            }
            Object.defineProperty(M.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState === void 0 ? !1 : this._readableState.destroyed;
              },
              set: function(U) {
                this._readableState && (this._readableState.destroyed = U);
              }
            }), M.prototype.destroy = w.destroy, M.prototype._undestroy = w.undestroy, M.prototype._destroy = function(B, U) {
              U(B);
            }, M.prototype.push = function(B, U) {
              var _ = this._readableState, v;
              return _.objectMode ? v = !0 : typeof B == "string" && (U = U || _.defaultEncoding, U !== _.encoding && (B = l.from(B, U), U = ""), v = !0), k(this, B, U, !1, v);
            }, M.prototype.unshift = function(B) {
              return k(this, B, null, !0, !1);
            };
            function k(B, U, _, v, S) {
              f("readableAddChunk", U);
              var P = B._readableState;
              if (U === null)
                P.reading = !1, z(B, P);
              else {
                var J;
                if (S || (J = ne(P, U)), J)
                  H(B, J);
                else if (P.objectMode || U && U.length > 0)
                  if (typeof U != "string" && !P.objectMode && Object.getPrototypeOf(U) !== l.prototype && (U = u(U)), v)
                    P.endEmitted ? H(B, new j()) : $(B, P, U, !0);
                  else if (P.ended)
                    H(B, new R());
                  else {
                    if (P.destroyed)
                      return !1;
                    P.reading = !1, P.decoder && !_ ? (U = P.decoder.write(U), P.objectMode || U.length !== 0 ? $(B, P, U, !1) : ye(B, P)) : $(B, P, U, !1);
                  }
                else v || (P.reading = !1, ye(B, P));
              }
              return !P.ended && (P.length < P.highWaterMark || P.length === 0);
            }
            function $(B, U, _, v) {
              U.flowing && U.length === 0 && !U.sync ? (U.awaitDrain = 0, B.emit("data", _)) : (U.length += U.objectMode ? 1 : _.length, v ? U.buffer.unshift(_) : U.buffer.push(_), U.needReadable && Z(B)), ye(B, U);
            }
            function ne(B, U) {
              var _;
              return !h(U) && typeof U != "string" && U !== void 0 && !B.objectMode && (_ = new C("chunk", ["string", "Buffer", "Uint8Array"], U)), _;
            }
            M.prototype.isPaused = function() {
              return this._readableState.flowing === !1;
            }, M.prototype.setEncoding = function(B) {
              N || (N = r("string_decoder/").StringDecoder);
              var U = new N(B);
              this._readableState.decoder = U, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var _ = this._readableState.buffer.head, v = ""; _ !== null; )
                v += U.write(_.data), _ = _.next;
              return this._readableState.buffer.clear(), v !== "" && this._readableState.buffer.push(v), this._readableState.length = v.length, this;
            };
            var te = 1073741824;
            function de(B) {
              return B >= te ? B = te : (B--, B |= B >>> 1, B |= B >>> 2, B |= B >>> 4, B |= B >>> 8, B |= B >>> 16, B++), B;
            }
            function ae(B, U) {
              return B <= 0 || U.length === 0 && U.ended ? 0 : U.objectMode ? 1 : B !== B ? U.flowing && U.length ? U.buffer.head.data.length : U.length : (B > U.highWaterMark && (U.highWaterMark = de(B)), B <= U.length ? B : U.ended ? U.length : (U.needReadable = !0, 0));
            }
            M.prototype.read = function(B) {
              f("read", B), B = parseInt(B, 10);
              var U = this._readableState, _ = B;
              if (B !== 0 && (U.emittedReadable = !1), B === 0 && U.needReadable && ((U.highWaterMark !== 0 ? U.length >= U.highWaterMark : U.length > 0) || U.ended))
                return f("read: emitReadable", U.length, U.ended), U.length === 0 && U.ended ? se(this) : Z(this), null;
              if (B = ae(B, U), B === 0 && U.ended)
                return U.length === 0 && se(this), null;
              var v = U.needReadable;
              f("need readable", v), (U.length === 0 || U.length - B < U.highWaterMark) && (v = !0, f("length less than watermark", v)), U.ended || U.reading ? (v = !1, f("reading or ended", v)) : v && (f("do read"), U.reading = !0, U.sync = !0, U.length === 0 && (U.needReadable = !0), this._read(U.highWaterMark), U.sync = !1, U.reading || (B = ae(_, U)));
              var S;
              return B > 0 ? S = Y(B, U) : S = null, S === null ? (U.needReadable = U.length <= U.highWaterMark, B = 0) : (U.length -= B, U.awaitDrain = 0), U.length === 0 && (U.ended || (U.needReadable = !0), _ !== B && U.ended && se(this)), S !== null && this.emit("data", S), S;
            };
            function z(B, U) {
              if (f("onEofChunk"), !U.ended) {
                if (U.decoder) {
                  var _ = U.decoder.end();
                  _ && _.length && (U.buffer.push(_), U.length += U.objectMode ? 1 : _.length);
                }
                U.ended = !0, U.sync ? Z(B) : (U.needReadable = !1, U.emittedReadable || (U.emittedReadable = !0, oe(B)));
              }
            }
            function Z(B) {
              var U = B._readableState;
              f("emitReadable", U.needReadable, U.emittedReadable), U.needReadable = !1, U.emittedReadable || (f("emitReadable", U.flowing), U.emittedReadable = !0, i.nextTick(oe, B));
            }
            function oe(B) {
              var U = B._readableState;
              f("emitReadable_", U.destroyed, U.length, U.ended), !U.destroyed && (U.length || U.ended) && (B.emit("readable"), U.emittedReadable = !1), U.needReadable = !U.flowing && !U.ended && U.length <= U.highWaterMark, W(B);
            }
            function ye(B, U) {
              U.readingMore || (U.readingMore = !0, i.nextTick(V, B, U));
            }
            function V(B, U) {
              for (; !U.reading && !U.ended && (U.length < U.highWaterMark || U.flowing && U.length === 0); ) {
                var _ = U.length;
                if (f("maybeReadMore read 0"), B.read(0), _ === U.length)
                  break;
              }
              U.readingMore = !1;
            }
            M.prototype._read = function(B) {
              H(this, new A("_read()"));
            }, M.prototype.pipe = function(B, U) {
              var _ = this, v = this._readableState;
              switch (v.pipesCount) {
                case 0:
                  v.pipes = B;
                  break;
                case 1:
                  v.pipes = [v.pipes, B];
                  break;
                default:
                  v.pipes.push(B);
                  break;
              }
              v.pipesCount += 1, f("pipe count=%d opts=%j", v.pipesCount, U);
              var S = (!U || U.end !== !1) && B !== i.stdout && B !== i.stderr, P = S ? ve : Ge;
              v.endEmitted ? i.nextTick(P) : _.once("end", P), B.on("unpipe", J);
              function J(Je, Ze) {
                f("onunpipe"), Je === _ && Ze && Ze.hasUnpiped === !1 && (Ze.hasUnpiped = !0, qe());
              }
              function ve() {
                f("onend"), B.end();
              }
              var Re = q(_);
              B.on("drain", Re);
              var je = !1;
              function qe() {
                f("cleanup"), B.removeListener("close", Fe), B.removeListener("finish", rt), B.removeListener("drain", Re), B.removeListener("error", We), B.removeListener("unpipe", J), _.removeListener("end", ve), _.removeListener("end", Ge), _.removeListener("data", ze), je = !0, v.awaitDrain && (!B._writableState || B._writableState.needDrain) && Re();
              }
              _.on("data", ze);
              function ze(Je) {
                f("ondata");
                var Ze = B.write(Je);
                f("dest.write", Ze), Ze === !1 && ((v.pipesCount === 1 && v.pipes === B || v.pipesCount > 1 && Oe(v.pipes, B) !== -1) && !je && (f("false write response, pause", v.awaitDrain), v.awaitDrain++), _.pause());
              }
              function We(Je) {
                f("onerror", Je), Ge(), B.removeListener("error", We), c(B, "error") === 0 && H(B, Je);
              }
              X(B, "error", We);
              function Fe() {
                B.removeListener("finish", rt), Ge();
              }
              B.once("close", Fe);
              function rt() {
                f("onfinish"), B.removeListener("close", Fe), Ge();
              }
              B.once("finish", rt);
              function Ge() {
                f("unpipe"), _.unpipe(B);
              }
              return B.emit("pipe", _), v.flowing || (f("pipe resume"), _.resume()), B;
            };
            function q(B) {
              return function() {
                var _ = B._readableState;
                f("pipeOnDrain", _.awaitDrain), _.awaitDrain && _.awaitDrain--, _.awaitDrain === 0 && c(B, "data") && (_.flowing = !0, W(B));
              };
            }
            M.prototype.unpipe = function(B) {
              var U = this._readableState, _ = {
                hasUnpiped: !1
              };
              if (U.pipesCount === 0) return this;
              if (U.pipesCount === 1)
                return B && B !== U.pipes ? this : (B || (B = U.pipes), U.pipes = null, U.pipesCount = 0, U.flowing = !1, B && B.emit("unpipe", this, _), this);
              if (!B) {
                var v = U.pipes, S = U.pipesCount;
                U.pipes = null, U.pipesCount = 0, U.flowing = !1;
                for (var P = 0; P < S; P++)
                  v[P].emit("unpipe", this, {
                    hasUnpiped: !1
                  });
                return this;
              }
              var J = Oe(U.pipes, B);
              return J === -1 ? this : (U.pipes.splice(J, 1), U.pipesCount -= 1, U.pipesCount === 1 && (U.pipes = U.pipes[0]), B.emit("unpipe", this, _), this);
            }, M.prototype.on = function(B, U) {
              var _ = p.prototype.on.call(this, B, U), v = this._readableState;
              return B === "data" ? (v.readableListening = this.listenerCount("readable") > 0, v.flowing !== !1 && this.resume()) : B === "readable" && !v.endEmitted && !v.readableListening && (v.readableListening = v.needReadable = !0, v.flowing = !1, v.emittedReadable = !1, f("on readable", v.length, v.reading), v.length ? Z(this) : v.reading || i.nextTick(ue, this)), _;
            }, M.prototype.addListener = M.prototype.on, M.prototype.removeListener = function(B, U) {
              var _ = p.prototype.removeListener.call(this, B, U);
              return B === "readable" && i.nextTick(ee, this), _;
            }, M.prototype.removeAllListeners = function(B) {
              var U = p.prototype.removeAllListeners.apply(this, arguments);
              return (B === "readable" || B === void 0) && i.nextTick(ee, this), U;
            };
            function ee(B) {
              var U = B._readableState;
              U.readableListening = B.listenerCount("readable") > 0, U.resumeScheduled && !U.paused ? U.flowing = !0 : B.listenerCount("data") > 0 && B.resume();
            }
            function ue(B) {
              f("readable nexttick read 0"), B.read(0);
            }
            M.prototype.resume = function() {
              var B = this._readableState;
              return B.flowing || (f("resume"), B.flowing = !B.readableListening, ge(this, B)), B.paused = !1, this;
            };
            function ge(B, U) {
              U.resumeScheduled || (U.resumeScheduled = !0, i.nextTick(he, B, U));
            }
            function he(B, U) {
              f("resume", U.reading), U.reading || B.read(0), U.resumeScheduled = !1, B.emit("resume"), W(B), U.flowing && !U.reading && B.read(0);
            }
            M.prototype.pause = function() {
              return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
            };
            function W(B) {
              var U = B._readableState;
              for (f("flow", U.flowing); U.flowing && B.read() !== null; )
                ;
            }
            M.prototype.wrap = function(B) {
              var U = this, _ = this._readableState, v = !1;
              B.on("end", function() {
                if (f("wrapped end"), _.decoder && !_.ended) {
                  var J = _.decoder.end();
                  J && J.length && U.push(J);
                }
                U.push(null);
              }), B.on("data", function(J) {
                if (f("wrapped data"), _.decoder && (J = _.decoder.write(J)), !(_.objectMode && J == null) && !(!_.objectMode && (!J || !J.length))) {
                  var ve = U.push(J);
                  ve || (v = !0, B.pause());
                }
              });
              for (var S in B)
                this[S] === void 0 && typeof B[S] == "function" && (this[S] = /* @__PURE__ */ function(ve) {
                  return function() {
                    return B[ve].apply(B, arguments);
                  };
                }(S));
              for (var P = 0; P < G.length; P++)
                B.on(G[P], this.emit.bind(this, G[P]));
              return this._read = function(J) {
                f("wrapped _read", J), v && (v = !1, B.resume());
              }, this;
            }, typeof Symbol == "function" && (M.prototype[Symbol.asyncIterator] = function() {
              return O === void 0 && (O = r("./internal/streams/async_iterator")), O(this);
            }), Object.defineProperty(M.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState.highWaterMark;
              }
            }), Object.defineProperty(M.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState && this._readableState.buffer;
              }
            }), Object.defineProperty(M.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState.flowing;
              },
              set: function(U) {
                this._readableState && (this._readableState.flowing = U);
              }
            }), M._fromList = Y, Object.defineProperty(M.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._readableState.length;
              }
            });
            function Y(B, U) {
              if (U.length === 0) return null;
              var _;
              return U.objectMode ? _ = U.buffer.shift() : !B || B >= U.length ? (U.decoder ? _ = U.buffer.join("") : U.buffer.length === 1 ? _ = U.buffer.first() : _ = U.buffer.concat(U.length), U.buffer.clear()) : _ = U.buffer.consume(B, U.decoder), _;
            }
            function se(B) {
              var U = B._readableState;
              f("endReadable", U.endEmitted), U.endEmitted || (U.ended = !0, i.nextTick(Te, U, B));
            }
            function Te(B, U) {
              if (f("endReadableNT", B.endEmitted, B.length), !B.endEmitted && B.length === 0 && (B.endEmitted = !0, U.readable = !1, U.emit("end"), B.autoDestroy)) {
                var _ = U._writableState;
                (!_ || _.autoDestroy && _.finished) && U.destroy();
              }
            }
            typeof Symbol == "function" && (M.from = function(B, U) {
              return D === void 0 && (D = r("./internal/streams/from")), D(M, B, U);
            });
            function Oe(B, U) {
              for (var _ = 0, v = B.length; _ < v; _++)
                if (B[_] === U) return _;
              return -1;
            }
          }).call(this);
        }).call(this, r("_process"), typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(r, o, n) {
        o.exports = u;
        var i = r("../errors").codes, a = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, c = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, p = i.ERR_TRANSFORM_WITH_LENGTH_0, l = r("./_stream_duplex");
        r("inherits")(u, l);
        function d(f, b) {
          var w = this._transformState;
          w.transforming = !1;
          var x = w.writecb;
          if (x === null)
            return this.emit("error", new s());
          w.writechunk = null, w.writecb = null, b != null && this.push(b), x(f);
          var E = this._readableState;
          E.reading = !1, (E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
        }
        function u(f) {
          if (!(this instanceof u)) return new u(f);
          l.call(this, f), this._transformState = {
            afterTransform: d.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, f && (typeof f.transform == "function" && (this._transform = f.transform), typeof f.flush == "function" && (this._flush = f.flush)), this.on("prefinish", h);
        }
        function h() {
          var f = this;
          typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(b, w) {
            y(f, b, w);
          }) : y(this, null, null);
        }
        u.prototype.push = function(f, b) {
          return this._transformState.needTransform = !1, l.prototype.push.call(this, f, b);
        }, u.prototype._transform = function(f, b, w) {
          w(new a("_transform()"));
        }, u.prototype._write = function(f, b, w) {
          var x = this._transformState;
          if (x.writecb = w, x.writechunk = f, x.writeencoding = b, !x.transforming) {
            var E = this._readableState;
            (x.needTransform || E.needReadable || E.length < E.highWaterMark) && this._read(E.highWaterMark);
          }
        }, u.prototype._read = function(f) {
          var b = this._transformState;
          b.writechunk !== null && !b.transforming ? (b.transforming = !0, this._transform(b.writechunk, b.writeencoding, b.afterTransform)) : b.needTransform = !0;
        }, u.prototype._destroy = function(f, b) {
          l.prototype._destroy.call(this, f, function(w) {
            b(w);
          });
        };
        function y(f, b, w) {
          if (b) return f.emit("error", b);
          if (w != null && f.push(w), f._writableState.length) throw new p();
          if (f._transformState.transforming) throw new c();
          return f.push(null);
        }
      }, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(r, o, n) {
        (function(i, a) {
          (function() {
            o.exports = Q;
            function s(W) {
              var Y = this;
              this.next = null, this.entry = null, this.finish = function() {
                he(Y, W);
              };
            }
            var c;
            Q.WritableState = G;
            var p = {
              deprecate: r("util-deprecate")
            }, l = r("./internal/streams/stream"), d = r("buffer").Buffer, u = a.Uint8Array || function() {
            };
            function h(W) {
              return d.from(W);
            }
            function y(W) {
              return d.isBuffer(W) || W instanceof u;
            }
            var f = r("./internal/streams/destroy"), b = r("./internal/streams/state"), w = b.getHighWaterMark, x = r("../errors").codes, E = x.ERR_INVALID_ARG_TYPE, T = x.ERR_METHOD_NOT_IMPLEMENTED, C = x.ERR_MULTIPLE_CALLBACK, R = x.ERR_STREAM_CANNOT_PIPE, A = x.ERR_STREAM_DESTROYED, j = x.ERR_STREAM_NULL_VALUES, N = x.ERR_STREAM_WRITE_AFTER_END, O = x.ERR_UNKNOWN_ENCODING, D = f.errorOrDestroy;
            r("inherits")(Q, l);
            function H() {
            }
            function G(W, Y, se) {
              c = c || r("./_stream_duplex"), W = W || {}, typeof se != "boolean" && (se = Y instanceof c), this.objectMode = !!W.objectMode, se && (this.objectMode = this.objectMode || !!W.writableObjectMode), this.highWaterMark = w(this, W, "writableHighWaterMark", se), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
              var Te = W.decodeStrings === !1;
              this.decodeStrings = !Te, this.defaultEncoding = W.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Oe) {
                z(Y, Oe);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = W.emitClose !== !1, this.autoDestroy = !!W.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
            }
            G.prototype.getBuffer = function() {
              for (var Y = this.bufferedRequest, se = []; Y; )
                se.push(Y), Y = Y.next;
              return se;
            }, function() {
              try {
                Object.defineProperty(G.prototype, "buffer", {
                  get: p.deprecate(function() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch {
              }
            }();
            var X;
            typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (X = Function.prototype[Symbol.hasInstance], Object.defineProperty(Q, Symbol.hasInstance, {
              value: function(Y) {
                return X.call(this, Y) ? !0 : this !== Q ? !1 : Y && Y._writableState instanceof G;
              }
            })) : X = function(Y) {
              return Y instanceof this;
            };
            function Q(W) {
              c = c || r("./_stream_duplex");
              var Y = this instanceof c;
              if (!Y && !X.call(Q, this)) return new Q(W);
              this._writableState = new G(W, this, Y), this.writable = !0, W && (typeof W.write == "function" && (this._write = W.write), typeof W.writev == "function" && (this._writev = W.writev), typeof W.destroy == "function" && (this._destroy = W.destroy), typeof W.final == "function" && (this._final = W.final)), l.call(this);
            }
            Q.prototype.pipe = function() {
              D(this, new R());
            };
            function M(W, Y) {
              var se = new N();
              D(W, se), i.nextTick(Y, se);
            }
            function k(W, Y, se, Te) {
              var Oe;
              return se === null ? Oe = new j() : typeof se != "string" && !Y.objectMode && (Oe = new E("chunk", ["string", "Buffer"], se)), Oe ? (D(W, Oe), i.nextTick(Te, Oe), !1) : !0;
            }
            Q.prototype.write = function(W, Y, se) {
              var Te = this._writableState, Oe = !1, B = !Te.objectMode && y(W);
              return B && !d.isBuffer(W) && (W = h(W)), typeof Y == "function" && (se = Y, Y = null), B ? Y = "buffer" : Y || (Y = Te.defaultEncoding), typeof se != "function" && (se = H), Te.ending ? M(this, se) : (B || k(this, Te, W, se)) && (Te.pendingcb++, Oe = ne(this, Te, B, W, Y, se)), Oe;
            }, Q.prototype.cork = function() {
              this._writableState.corked++;
            }, Q.prototype.uncork = function() {
              var W = this._writableState;
              W.corked && (W.corked--, !W.writing && !W.corked && !W.bufferProcessing && W.bufferedRequest && ye(this, W));
            }, Q.prototype.setDefaultEncoding = function(Y) {
              if (typeof Y == "string" && (Y = Y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Y + "").toLowerCase()) > -1)) throw new O(Y);
              return this._writableState.defaultEncoding = Y, this;
            }, Object.defineProperty(Q.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function $(W, Y, se) {
              return !W.objectMode && W.decodeStrings !== !1 && typeof Y == "string" && (Y = d.from(Y, se)), Y;
            }
            Object.defineProperty(Q.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState.highWaterMark;
              }
            });
            function ne(W, Y, se, Te, Oe, B) {
              if (!se) {
                var U = $(Y, Te, Oe);
                Te !== U && (se = !0, Oe = "buffer", Te = U);
              }
              var _ = Y.objectMode ? 1 : Te.length;
              Y.length += _;
              var v = Y.length < Y.highWaterMark;
              if (v || (Y.needDrain = !0), Y.writing || Y.corked) {
                var S = Y.lastBufferedRequest;
                Y.lastBufferedRequest = {
                  chunk: Te,
                  encoding: Oe,
                  isBuf: se,
                  callback: B,
                  next: null
                }, S ? S.next = Y.lastBufferedRequest : Y.bufferedRequest = Y.lastBufferedRequest, Y.bufferedRequestCount += 1;
              } else
                te(W, Y, !1, _, Te, Oe, B);
              return v;
            }
            function te(W, Y, se, Te, Oe, B, U) {
              Y.writelen = Te, Y.writecb = U, Y.writing = !0, Y.sync = !0, Y.destroyed ? Y.onwrite(new A("write")) : se ? W._writev(Oe, Y.onwrite) : W._write(Oe, B, Y.onwrite), Y.sync = !1;
            }
            function de(W, Y, se, Te, Oe) {
              --Y.pendingcb, se ? (i.nextTick(Oe, Te), i.nextTick(ue, W, Y), W._writableState.errorEmitted = !0, D(W, Te)) : (Oe(Te), W._writableState.errorEmitted = !0, D(W, Te), ue(W, Y));
            }
            function ae(W) {
              W.writing = !1, W.writecb = null, W.length -= W.writelen, W.writelen = 0;
            }
            function z(W, Y) {
              var se = W._writableState, Te = se.sync, Oe = se.writecb;
              if (typeof Oe != "function") throw new C();
              if (ae(se), Y) de(W, se, Te, Y, Oe);
              else {
                var B = V(se) || W.destroyed;
                !B && !se.corked && !se.bufferProcessing && se.bufferedRequest && ye(W, se), Te ? i.nextTick(Z, W, se, B, Oe) : Z(W, se, B, Oe);
              }
            }
            function Z(W, Y, se, Te) {
              se || oe(W, Y), Y.pendingcb--, Te(), ue(W, Y);
            }
            function oe(W, Y) {
              Y.length === 0 && Y.needDrain && (Y.needDrain = !1, W.emit("drain"));
            }
            function ye(W, Y) {
              Y.bufferProcessing = !0;
              var se = Y.bufferedRequest;
              if (W._writev && se && se.next) {
                var Te = Y.bufferedRequestCount, Oe = new Array(Te), B = Y.corkedRequestsFree;
                B.entry = se;
                for (var U = 0, _ = !0; se; )
                  Oe[U] = se, se.isBuf || (_ = !1), se = se.next, U += 1;
                Oe.allBuffers = _, te(W, Y, !0, Y.length, Oe, "", B.finish), Y.pendingcb++, Y.lastBufferedRequest = null, B.next ? (Y.corkedRequestsFree = B.next, B.next = null) : Y.corkedRequestsFree = new s(Y), Y.bufferedRequestCount = 0;
              } else {
                for (; se; ) {
                  var v = se.chunk, S = se.encoding, P = se.callback, J = Y.objectMode ? 1 : v.length;
                  if (te(W, Y, !1, J, v, S, P), se = se.next, Y.bufferedRequestCount--, Y.writing)
                    break;
                }
                se === null && (Y.lastBufferedRequest = null);
              }
              Y.bufferedRequest = se, Y.bufferProcessing = !1;
            }
            Q.prototype._write = function(W, Y, se) {
              se(new T("_write()"));
            }, Q.prototype._writev = null, Q.prototype.end = function(W, Y, se) {
              var Te = this._writableState;
              return typeof W == "function" ? (se = W, W = null, Y = null) : typeof Y == "function" && (se = Y, Y = null), W != null && this.write(W, Y), Te.corked && (Te.corked = 1, this.uncork()), Te.ending || ge(this, Te, se), this;
            }, Object.defineProperty(Q.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState.length;
              }
            });
            function V(W) {
              return W.ending && W.length === 0 && W.bufferedRequest === null && !W.finished && !W.writing;
            }
            function q(W, Y) {
              W._final(function(se) {
                Y.pendingcb--, se && D(W, se), Y.prefinished = !0, W.emit("prefinish"), ue(W, Y);
              });
            }
            function ee(W, Y) {
              !Y.prefinished && !Y.finalCalled && (typeof W._final == "function" && !Y.destroyed ? (Y.pendingcb++, Y.finalCalled = !0, i.nextTick(q, W, Y)) : (Y.prefinished = !0, W.emit("prefinish")));
            }
            function ue(W, Y) {
              var se = V(Y);
              if (se && (ee(W, Y), Y.pendingcb === 0 && (Y.finished = !0, W.emit("finish"), Y.autoDestroy))) {
                var Te = W._readableState;
                (!Te || Te.autoDestroy && Te.endEmitted) && W.destroy();
              }
              return se;
            }
            function ge(W, Y, se) {
              Y.ending = !0, ue(W, Y), se && (Y.finished ? i.nextTick(se) : W.once("finish", se)), Y.ended = !0, W.writable = !1;
            }
            function he(W, Y, se) {
              var Te = W.entry;
              for (W.entry = null; Te; ) {
                var Oe = Te.callback;
                Y.pendingcb--, Oe(se), Te = Te.next;
              }
              Y.corkedRequestsFree.next = W;
            }
            Object.defineProperty(Q.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: !1,
              get: function() {
                return this._writableState === void 0 ? !1 : this._writableState.destroyed;
              },
              set: function(Y) {
                this._writableState && (this._writableState.destroyed = Y);
              }
            }), Q.prototype.destroy = f.destroy, Q.prototype._undestroy = f.undestroy, Q.prototype._destroy = function(W, Y) {
              Y(W);
            };
          }).call(this);
        }).call(this, r("_process"), typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(r, o, n) {
        (function(i) {
          (function() {
            var a;
            function s(A, j, N) {
              return j in A ? Object.defineProperty(A, j, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : A[j] = N, A;
            }
            var c = r("./end-of-stream"), p = Symbol("lastResolve"), l = Symbol("lastReject"), d = Symbol("error"), u = Symbol("ended"), h = Symbol("lastPromise"), y = Symbol("handlePromise"), f = Symbol("stream");
            function b(A, j) {
              return {
                value: A,
                done: j
              };
            }
            function w(A) {
              var j = A[p];
              if (j !== null) {
                var N = A[f].read();
                N !== null && (A[h] = null, A[p] = null, A[l] = null, j(b(N, !1)));
              }
            }
            function x(A) {
              i.nextTick(w, A);
            }
            function E(A, j) {
              return function(N, O) {
                A.then(function() {
                  if (j[u]) {
                    N(b(void 0, !0));
                    return;
                  }
                  j[y](N, O);
                }, O);
              };
            }
            var T = Object.getPrototypeOf(function() {
            }), C = Object.setPrototypeOf((a = {
              get stream() {
                return this[f];
              },
              next: function() {
                var j = this, N = this[d];
                if (N !== null)
                  return Promise.reject(N);
                if (this[u])
                  return Promise.resolve(b(void 0, !0));
                if (this[f].destroyed)
                  return new Promise(function(G, X) {
                    i.nextTick(function() {
                      j[d] ? X(j[d]) : G(b(void 0, !0));
                    });
                  });
                var O = this[h], D;
                if (O)
                  D = new Promise(E(O, this));
                else {
                  var H = this[f].read();
                  if (H !== null)
                    return Promise.resolve(b(H, !1));
                  D = new Promise(this[y]);
                }
                return this[h] = D, D;
              }
            }, s(a, Symbol.asyncIterator, function() {
              return this;
            }), s(a, "return", function() {
              var j = this;
              return new Promise(function(N, O) {
                j[f].destroy(null, function(D) {
                  if (D) {
                    O(D);
                    return;
                  }
                  N(b(void 0, !0));
                });
              });
            }), a), T), R = function(j) {
              var N, O = Object.create(C, (N = {}, s(N, f, {
                value: j,
                writable: !0
              }), s(N, p, {
                value: null,
                writable: !0
              }), s(N, l, {
                value: null,
                writable: !0
              }), s(N, d, {
                value: null,
                writable: !0
              }), s(N, u, {
                value: j._readableState.endEmitted,
                writable: !0
              }), s(N, y, {
                value: function(H, G) {
                  var X = O[f].read();
                  X ? (O[h] = null, O[p] = null, O[l] = null, H(b(X, !1))) : (O[p] = H, O[l] = G);
                },
                writable: !0
              }), N));
              return O[h] = null, c(j, function(D) {
                if (D && D.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var H = O[l];
                  H !== null && (O[h] = null, O[p] = null, O[l] = null, H(D)), O[d] = D;
                  return;
                }
                var G = O[p];
                G !== null && (O[h] = null, O[p] = null, O[l] = null, G(b(void 0, !0))), O[u] = !0;
              }), j.on("readable", x.bind(null, O)), O;
            };
            o.exports = R;
          }).call(this);
        }).call(this, r("_process"));
      }, { "./end-of-stream": 75, _process: 63 }], 73: [function(r, o, n) {
        function i(w, x) {
          var E = Object.keys(w);
          if (Object.getOwnPropertySymbols) {
            var T = Object.getOwnPropertySymbols(w);
            x && (T = T.filter(function(C) {
              return Object.getOwnPropertyDescriptor(w, C).enumerable;
            })), E.push.apply(E, T);
          }
          return E;
        }
        function a(w) {
          for (var x = 1; x < arguments.length; x++) {
            var E = arguments[x] != null ? arguments[x] : {};
            x % 2 ? i(Object(E), !0).forEach(function(T) {
              s(w, T, E[T]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : i(Object(E)).forEach(function(T) {
              Object.defineProperty(w, T, Object.getOwnPropertyDescriptor(E, T));
            });
          }
          return w;
        }
        function s(w, x, E) {
          return x in w ? Object.defineProperty(w, x, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : w[x] = E, w;
        }
        function c(w, x) {
          if (!(w instanceof x))
            throw new TypeError("Cannot call a class as a function");
        }
        function p(w, x) {
          for (var E = 0; E < x.length; E++) {
            var T = x[E];
            T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(w, T.key, T);
          }
        }
        function l(w, x, E) {
          return x && p(w.prototype, x), w;
        }
        var d = r("buffer"), u = d.Buffer, h = r("util"), y = h.inspect, f = y && y.custom || "inspect";
        function b(w, x, E) {
          u.prototype.copy.call(w, x, E);
        }
        o.exports = /* @__PURE__ */ function() {
          function w() {
            c(this, w), this.head = null, this.tail = null, this.length = 0;
          }
          return l(w, [{
            key: "push",
            value: function(E) {
              var T = {
                data: E,
                next: null
              };
              this.length > 0 ? this.tail.next = T : this.head = T, this.tail = T, ++this.length;
            }
          }, {
            key: "unshift",
            value: function(E) {
              var T = {
                data: E,
                next: this.head
              };
              this.length === 0 && (this.tail = T), this.head = T, ++this.length;
            }
          }, {
            key: "shift",
            value: function() {
              if (this.length !== 0) {
                var E = this.head.data;
                return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
              }
            }
          }, {
            key: "clear",
            value: function() {
              this.head = this.tail = null, this.length = 0;
            }
          }, {
            key: "join",
            value: function(E) {
              if (this.length === 0) return "";
              for (var T = this.head, C = "" + T.data; T = T.next; )
                C += E + T.data;
              return C;
            }
          }, {
            key: "concat",
            value: function(E) {
              if (this.length === 0) return u.alloc(0);
              for (var T = u.allocUnsafe(E >>> 0), C = this.head, R = 0; C; )
                b(C.data, T, R), R += C.data.length, C = C.next;
              return T;
            }
            // Consumes a specified amount of bytes or characters from the buffered data.
          }, {
            key: "consume",
            value: function(E, T) {
              var C;
              return E < this.head.data.length ? (C = this.head.data.slice(0, E), this.head.data = this.head.data.slice(E)) : E === this.head.data.length ? C = this.shift() : C = T ? this._getString(E) : this._getBuffer(E), C;
            }
          }, {
            key: "first",
            value: function() {
              return this.head.data;
            }
            // Consumes a specified amount of characters from the buffered data.
          }, {
            key: "_getString",
            value: function(E) {
              var T = this.head, C = 1, R = T.data;
              for (E -= R.length; T = T.next; ) {
                var A = T.data, j = E > A.length ? A.length : E;
                if (j === A.length ? R += A : R += A.slice(0, E), E -= j, E === 0) {
                  j === A.length ? (++C, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = A.slice(j));
                  break;
                }
                ++C;
              }
              return this.length -= C, R;
            }
            // Consumes a specified amount of bytes from the buffered data.
          }, {
            key: "_getBuffer",
            value: function(E) {
              var T = u.allocUnsafe(E), C = this.head, R = 1;
              for (C.data.copy(T), E -= C.data.length; C = C.next; ) {
                var A = C.data, j = E > A.length ? A.length : E;
                if (A.copy(T, T.length - E, 0, j), E -= j, E === 0) {
                  j === A.length ? (++R, C.next ? this.head = C.next : this.head = this.tail = null) : (this.head = C, C.data = A.slice(j));
                  break;
                }
                ++R;
              }
              return this.length -= R, T;
            }
            // Make sure the linked list only shows the minimal necessary information.
          }, {
            key: f,
            value: function(E, T) {
              return y(this, a({}, T, {
                // Only inspect one level.
                depth: 0,
                // It should not recurse.
                customInspect: !1
              }));
            }
          }]), w;
        }();
      }, { buffer: 32, util: 29 }], 74: [function(r, o, n) {
        (function(i) {
          (function() {
            function a(u, h) {
              var y = this, f = this._readableState && this._readableState.destroyed, b = this._writableState && this._writableState.destroyed;
              return f || b ? (h ? h(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, i.nextTick(l, this, u)) : i.nextTick(l, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(w) {
                !h && w ? y._writableState ? y._writableState.errorEmitted ? i.nextTick(c, y) : (y._writableState.errorEmitted = !0, i.nextTick(s, y, w)) : i.nextTick(s, y, w) : h ? (i.nextTick(c, y), h(w)) : i.nextTick(c, y);
              }), this);
            }
            function s(u, h) {
              l(u, h), c(u);
            }
            function c(u) {
              u._writableState && !u._writableState.emitClose || u._readableState && !u._readableState.emitClose || u.emit("close");
            }
            function p() {
              this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
            }
            function l(u, h) {
              u.emit("error", h);
            }
            function d(u, h) {
              var y = u._readableState, f = u._writableState;
              y && y.autoDestroy || f && f.autoDestroy ? u.destroy(h) : u.emit("error", h);
            }
            o.exports = {
              destroy: a,
              undestroy: p,
              errorOrDestroy: d
            };
          }).call(this);
        }).call(this, r("_process"));
      }, { _process: 63 }], 75: [function(r, o, n) {
        var i = r("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function a(l) {
          var d = !1;
          return function() {
            if (!d) {
              d = !0;
              for (var u = arguments.length, h = new Array(u), y = 0; y < u; y++)
                h[y] = arguments[y];
              l.apply(this, h);
            }
          };
        }
        function s() {
        }
        function c(l) {
          return l.setHeader && typeof l.abort == "function";
        }
        function p(l, d, u) {
          if (typeof d == "function") return p(l, null, d);
          d || (d = {}), u = a(u || s);
          var h = d.readable || d.readable !== !1 && l.readable, y = d.writable || d.writable !== !1 && l.writable, f = function() {
            l.writable || w();
          }, b = l._writableState && l._writableState.finished, w = function() {
            y = !1, b = !0, h || u.call(l);
          }, x = l._readableState && l._readableState.endEmitted, E = function() {
            h = !1, x = !0, y || u.call(l);
          }, T = function(j) {
            u.call(l, j);
          }, C = function() {
            var j;
            if (h && !x)
              return (!l._readableState || !l._readableState.ended) && (j = new i()), u.call(l, j);
            if (y && !b)
              return (!l._writableState || !l._writableState.ended) && (j = new i()), u.call(l, j);
          }, R = function() {
            l.req.on("finish", w);
          };
          return c(l) ? (l.on("complete", w), l.on("abort", C), l.req ? R() : l.on("request", R)) : y && !l._writableState && (l.on("end", f), l.on("close", f)), l.on("end", E), l.on("finish", w), d.error !== !1 && l.on("error", T), l.on("close", C), function() {
            l.removeListener("complete", w), l.removeListener("abort", C), l.removeListener("request", R), l.req && l.req.removeListener("finish", w), l.removeListener("end", f), l.removeListener("close", f), l.removeListener("finish", w), l.removeListener("end", E), l.removeListener("error", T), l.removeListener("close", C);
          };
        }
        o.exports = p;
      }, { "../../../errors": 66 }], 76: [function(r, o, n) {
        o.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 77: [function(r, o, n) {
        var i;
        function a(w) {
          var x = !1;
          return function() {
            x || (x = !0, w.apply(void 0, arguments));
          };
        }
        var s = r("../../../errors").codes, c = s.ERR_MISSING_ARGS, p = s.ERR_STREAM_DESTROYED;
        function l(w) {
          if (w) throw w;
        }
        function d(w) {
          return w.setHeader && typeof w.abort == "function";
        }
        function u(w, x, E, T) {
          T = a(T);
          var C = !1;
          w.on("close", function() {
            C = !0;
          }), i === void 0 && (i = r("./end-of-stream")), i(w, {
            readable: x,
            writable: E
          }, function(A) {
            if (A) return T(A);
            C = !0, T();
          });
          var R = !1;
          return function(A) {
            if (!C && !R) {
              if (R = !0, d(w)) return w.abort();
              if (typeof w.destroy == "function") return w.destroy();
              T(A || new p("pipe"));
            }
          };
        }
        function h(w) {
          w();
        }
        function y(w, x) {
          return w.pipe(x);
        }
        function f(w) {
          return !w.length || typeof w[w.length - 1] != "function" ? l : w.pop();
        }
        function b() {
          for (var w = arguments.length, x = new Array(w), E = 0; E < w; E++)
            x[E] = arguments[E];
          var T = f(x);
          if (Array.isArray(x[0]) && (x = x[0]), x.length < 2)
            throw new c("streams");
          var C, R = x.map(function(A, j) {
            var N = j < x.length - 1, O = j > 0;
            return u(A, N, O, function(D) {
              C || (C = D), D && R.forEach(h), !N && (R.forEach(h), T(C));
            });
          });
          return x.reduce(y);
        }
        o.exports = b;
      }, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(r, o, n) {
        var i = r("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function a(c, p, l) {
          return c.highWaterMark != null ? c.highWaterMark : p ? c[l] : null;
        }
        function s(c, p, l, d) {
          var u = a(p, d, l);
          if (u != null) {
            if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
              var h = d ? l : "highWaterMark";
              throw new i(h, u);
            }
            return Math.floor(u);
          }
          return c.objectMode ? 16 : 16 * 1024;
        }
        o.exports = {
          getHighWaterMark: s
        };
      }, { "../../../errors": 66 }], 79: [function(r, o, n) {
        o.exports = r("events").EventEmitter;
      }, { events: 35 }], 80: [function(r, o, n) {
        var i = r("safe-buffer").Buffer, a = i.isEncoding || function(R) {
          switch (R = "" + R, R && R.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function s(R) {
          if (!R) return "utf8";
          for (var A; ; )
            switch (R) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return R;
              default:
                if (A) return;
                R = ("" + R).toLowerCase(), A = !0;
            }
        }
        function c(R) {
          var A = s(R);
          if (typeof A != "string" && (i.isEncoding === a || !a(R))) throw new Error("Unknown encoding: " + R);
          return A || R;
        }
        n.StringDecoder = p;
        function p(R) {
          this.encoding = c(R);
          var A;
          switch (this.encoding) {
            case "utf16le":
              this.text = b, this.end = w, A = 4;
              break;
            case "utf8":
              this.fillLast = h, A = 4;
              break;
            case "base64":
              this.text = x, this.end = E, A = 3;
              break;
            default:
              this.write = T, this.end = C;
              return;
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = i.allocUnsafe(A);
        }
        p.prototype.write = function(R) {
          if (R.length === 0) return "";
          var A, j;
          if (this.lastNeed) {
            if (A = this.fillLast(R), A === void 0) return "";
            j = this.lastNeed, this.lastNeed = 0;
          } else
            j = 0;
          return j < R.length ? A ? A + this.text(R, j) : this.text(R, j) : A || "";
        }, p.prototype.end = f, p.prototype.text = y, p.prototype.fillLast = function(R) {
          if (this.lastNeed <= R.length)
            return R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, R.length), this.lastNeed -= R.length;
        };
        function l(R) {
          return R <= 127 ? 0 : R >> 5 === 6 ? 2 : R >> 4 === 14 ? 3 : R >> 3 === 30 ? 4 : R >> 6 === 2 ? -1 : -2;
        }
        function d(R, A, j) {
          var N = A.length - 1;
          if (N < j) return 0;
          var O = l(A[N]);
          return O >= 0 ? (O > 0 && (R.lastNeed = O - 1), O) : --N < j || O === -2 ? 0 : (O = l(A[N]), O >= 0 ? (O > 0 && (R.lastNeed = O - 2), O) : --N < j || O === -2 ? 0 : (O = l(A[N]), O >= 0 ? (O > 0 && (O === 2 ? O = 0 : R.lastNeed = O - 3), O) : 0));
        }
        function u(R, A, j) {
          if ((A[0] & 192) !== 128)
            return R.lastNeed = 0, "�";
          if (R.lastNeed > 1 && A.length > 1) {
            if ((A[1] & 192) !== 128)
              return R.lastNeed = 1, "�";
            if (R.lastNeed > 2 && A.length > 2 && (A[2] & 192) !== 128)
              return R.lastNeed = 2, "�";
          }
        }
        function h(R) {
          var A = this.lastTotal - this.lastNeed, j = u(this, R);
          if (j !== void 0) return j;
          if (this.lastNeed <= R.length)
            return R.copy(this.lastChar, A, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          R.copy(this.lastChar, A, 0, R.length), this.lastNeed -= R.length;
        }
        function y(R, A) {
          var j = d(this, R, A);
          if (!this.lastNeed) return R.toString("utf8", A);
          this.lastTotal = j;
          var N = R.length - (j - this.lastNeed);
          return R.copy(this.lastChar, 0, N), R.toString("utf8", A, N);
        }
        function f(R) {
          var A = R && R.length ? this.write(R) : "";
          return this.lastNeed ? A + "�" : A;
        }
        function b(R, A) {
          if ((R.length - A) % 2 === 0) {
            var j = R.toString("utf16le", A);
            if (j) {
              var N = j.charCodeAt(j.length - 1);
              if (N >= 55296 && N <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1], j.slice(0, -1);
            }
            return j;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = R[R.length - 1], R.toString("utf16le", A, R.length - 1);
        }
        function w(R) {
          var A = R && R.length ? this.write(R) : "";
          if (this.lastNeed) {
            var j = this.lastTotal - this.lastNeed;
            return A + this.lastChar.toString("utf16le", 0, j);
          }
          return A;
        }
        function x(R, A) {
          var j = (R.length - A) % 3;
          return j === 0 ? R.toString("base64", A) : (this.lastNeed = 3 - j, this.lastTotal = 3, j === 1 ? this.lastChar[0] = R[R.length - 1] : (this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1]), R.toString("base64", A, R.length - j));
        }
        function E(R) {
          var A = R && R.length ? this.write(R) : "";
          return this.lastNeed ? A + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : A;
        }
        function T(R) {
          return R.toString(this.encoding);
        }
        function C(R) {
          return R && R.length ? this.write(R) : "";
        }
      }, { "safe-buffer": 64 }], 81: [function(r, o, n) {
        (function(i) {
          (function() {
            o.exports = a;
            function a(c, p) {
              if (s("noDeprecation"))
                return c;
              var l = !1;
              function d() {
                if (!l) {
                  if (s("throwDeprecation"))
                    throw new Error(p);
                  s("traceDeprecation") ? console.trace(p) : console.warn(p), l = !0;
                }
                return c.apply(this, arguments);
              }
              return d;
            }
            function s(c) {
              try {
                if (!i.localStorage) return !1;
              } catch {
                return !1;
              }
              var p = i.localStorage[c];
              return p == null ? !1 : String(p).toLowerCase() === "true";
            }
          }).call(this);
        }).call(this, typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 82: [function(r, o, n) {
        arguments[4][25][0].apply(n, arguments);
      }, { dup: 25 }], 83: [function(r, o, n) {
        var i = r("is-arguments"), a = r("is-generator-function"), s = r("which-typed-array"), c = r("is-typed-array");
        function p(P) {
          return P.call.bind(P);
        }
        var l = typeof BigInt < "u", d = typeof Symbol < "u", u = p(Object.prototype.toString), h = p(Number.prototype.valueOf), y = p(String.prototype.valueOf), f = p(Boolean.prototype.valueOf);
        if (l)
          var b = p(BigInt.prototype.valueOf);
        if (d)
          var w = p(Symbol.prototype.valueOf);
        function x(P, J) {
          if (typeof P != "object")
            return !1;
          try {
            return J(P), !0;
          } catch {
            return !1;
          }
        }
        n.isArgumentsObject = i, n.isGeneratorFunction = a, n.isTypedArray = c;
        function E(P) {
          return typeof Promise < "u" && P instanceof Promise || P !== null && typeof P == "object" && typeof P.then == "function" && typeof P.catch == "function";
        }
        n.isPromise = E;
        function T(P) {
          return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(P) : c(P) || V(P);
        }
        n.isArrayBufferView = T;
        function C(P) {
          return s(P) === "Uint8Array";
        }
        n.isUint8Array = C;
        function R(P) {
          return s(P) === "Uint8ClampedArray";
        }
        n.isUint8ClampedArray = R;
        function A(P) {
          return s(P) === "Uint16Array";
        }
        n.isUint16Array = A;
        function j(P) {
          return s(P) === "Uint32Array";
        }
        n.isUint32Array = j;
        function N(P) {
          return s(P) === "Int8Array";
        }
        n.isInt8Array = N;
        function O(P) {
          return s(P) === "Int16Array";
        }
        n.isInt16Array = O;
        function D(P) {
          return s(P) === "Int32Array";
        }
        n.isInt32Array = D;
        function H(P) {
          return s(P) === "Float32Array";
        }
        n.isFloat32Array = H;
        function G(P) {
          return s(P) === "Float64Array";
        }
        n.isFloat64Array = G;
        function X(P) {
          return s(P) === "BigInt64Array";
        }
        n.isBigInt64Array = X;
        function Q(P) {
          return s(P) === "BigUint64Array";
        }
        n.isBigUint64Array = Q;
        function M(P) {
          return u(P) === "[object Map]";
        }
        M.working = typeof Map < "u" && M(/* @__PURE__ */ new Map());
        function k(P) {
          return typeof Map > "u" ? !1 : M.working ? M(P) : P instanceof Map;
        }
        n.isMap = k;
        function $(P) {
          return u(P) === "[object Set]";
        }
        $.working = typeof Set < "u" && $(/* @__PURE__ */ new Set());
        function ne(P) {
          return typeof Set > "u" ? !1 : $.working ? $(P) : P instanceof Set;
        }
        n.isSet = ne;
        function te(P) {
          return u(P) === "[object WeakMap]";
        }
        te.working = typeof WeakMap < "u" && te(/* @__PURE__ */ new WeakMap());
        function de(P) {
          return typeof WeakMap > "u" ? !1 : te.working ? te(P) : P instanceof WeakMap;
        }
        n.isWeakMap = de;
        function ae(P) {
          return u(P) === "[object WeakSet]";
        }
        ae.working = typeof WeakSet < "u" && ae(/* @__PURE__ */ new WeakSet());
        function z(P) {
          return ae(P);
        }
        n.isWeakSet = z;
        function Z(P) {
          return u(P) === "[object ArrayBuffer]";
        }
        Z.working = typeof ArrayBuffer < "u" && Z(new ArrayBuffer());
        function oe(P) {
          return typeof ArrayBuffer > "u" ? !1 : Z.working ? Z(P) : P instanceof ArrayBuffer;
        }
        n.isArrayBuffer = oe;
        function ye(P) {
          return u(P) === "[object DataView]";
        }
        ye.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ye(new DataView(new ArrayBuffer(1), 0, 1));
        function V(P) {
          return typeof DataView > "u" ? !1 : ye.working ? ye(P) : P instanceof DataView;
        }
        n.isDataView = V;
        var q = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function ee(P) {
          return u(P) === "[object SharedArrayBuffer]";
        }
        function ue(P) {
          return typeof q > "u" ? !1 : (typeof ee.working > "u" && (ee.working = ee(new q())), ee.working ? ee(P) : P instanceof q);
        }
        n.isSharedArrayBuffer = ue;
        function ge(P) {
          return u(P) === "[object AsyncFunction]";
        }
        n.isAsyncFunction = ge;
        function he(P) {
          return u(P) === "[object Map Iterator]";
        }
        n.isMapIterator = he;
        function W(P) {
          return u(P) === "[object Set Iterator]";
        }
        n.isSetIterator = W;
        function Y(P) {
          return u(P) === "[object Generator]";
        }
        n.isGeneratorObject = Y;
        function se(P) {
          return u(P) === "[object WebAssembly.Module]";
        }
        n.isWebAssemblyCompiledModule = se;
        function Te(P) {
          return x(P, h);
        }
        n.isNumberObject = Te;
        function Oe(P) {
          return x(P, y);
        }
        n.isStringObject = Oe;
        function B(P) {
          return x(P, f);
        }
        n.isBooleanObject = B;
        function U(P) {
          return l && x(P, b);
        }
        n.isBigIntObject = U;
        function _(P) {
          return d && x(P, w);
        }
        n.isSymbolObject = _;
        function v(P) {
          return Te(P) || Oe(P) || B(P) || U(P) || _(P);
        }
        n.isBoxedPrimitive = v;
        function S(P) {
          return typeof Uint8Array < "u" && (oe(P) || ue(P));
        }
        n.isAnyArrayBuffer = S, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(P) {
          Object.defineProperty(n, P, {
            enumerable: !1,
            value: function() {
              throw new Error(P + " is not supported in userland");
            }
          });
        });
      }, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = Object.getOwnPropertyDescriptors || function(q) {
              for (var ee = Object.keys(q), ue = {}, ge = 0; ge < ee.length; ge++)
                ue[ee[ge]] = Object.getOwnPropertyDescriptor(q, ee[ge]);
              return ue;
            }, s = /%[sdj%]/g;
            n.format = function(V) {
              if (!O(V)) {
                for (var q = [], ee = 0; ee < arguments.length; ee++)
                  q.push(d(arguments[ee]));
                return q.join(" ");
              }
              for (var ee = 1, ue = arguments, ge = ue.length, he = String(V).replace(s, function(Y) {
                if (Y === "%%") return "%";
                if (ee >= ge) return Y;
                switch (Y) {
                  case "%s":
                    return String(ue[ee++]);
                  case "%d":
                    return Number(ue[ee++]);
                  case "%j":
                    try {
                      return JSON.stringify(ue[ee++]);
                    } catch {
                      return "[Circular]";
                    }
                  default:
                    return Y;
                }
              }), W = ue[ee]; ee < ge; W = ue[++ee])
                A(W) || !X(W) ? he += " " + W : he += " " + d(W);
              return he;
            }, n.deprecate = function(V, q) {
              if (typeof i < "u" && i.noDeprecation === !0)
                return V;
              if (typeof i > "u")
                return function() {
                  return n.deprecate(V, q).apply(this, arguments);
                };
              var ee = !1;
              function ue() {
                if (!ee) {
                  if (i.throwDeprecation)
                    throw new Error(q);
                  i.traceDeprecation ? console.trace(q) : console.error(q), ee = !0;
                }
                return V.apply(this, arguments);
              }
              return ue;
            };
            var c = {}, p = /^$/;
            if (i.env.NODE_DEBUG) {
              var l = i.env.NODE_DEBUG;
              l = l.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), p = new RegExp("^" + l + "$", "i");
            }
            n.debuglog = function(V) {
              if (V = V.toUpperCase(), !c[V])
                if (p.test(V)) {
                  var q = i.pid;
                  c[V] = function() {
                    var ee = n.format.apply(n, arguments);
                    console.error("%s %d: %s", V, q, ee);
                  };
                } else
                  c[V] = function() {
                  };
              return c[V];
            };
            function d(V, q) {
              var ee = {
                seen: [],
                stylize: h
              };
              return arguments.length >= 3 && (ee.depth = arguments[2]), arguments.length >= 4 && (ee.colors = arguments[3]), R(q) ? ee.showHidden = q : q && n._extend(ee, q), H(ee.showHidden) && (ee.showHidden = !1), H(ee.depth) && (ee.depth = 2), H(ee.colors) && (ee.colors = !1), H(ee.customInspect) && (ee.customInspect = !0), ee.colors && (ee.stylize = u), f(ee, V, ee.depth);
            }
            n.inspect = d, d.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39]
            }, d.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              // "name": intentionally not styling
              regexp: "red"
            };
            function u(V, q) {
              var ee = d.styles[q];
              return ee ? "\x1B[" + d.colors[ee][0] + "m" + V + "\x1B[" + d.colors[ee][1] + "m" : V;
            }
            function h(V, q) {
              return V;
            }
            function y(V) {
              var q = {};
              return V.forEach(function(ee, ue) {
                q[ee] = !0;
              }), q;
            }
            function f(V, q, ee) {
              if (V.customInspect && q && k(q.inspect) && // Filter out the util module, it's inspect function is special
              q.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
              !(q.constructor && q.constructor.prototype === q)) {
                var ue = q.inspect(ee, V);
                return O(ue) || (ue = f(V, ue, ee)), ue;
              }
              var ge = b(V, q);
              if (ge)
                return ge;
              var he = Object.keys(q), W = y(he);
              if (V.showHidden && (he = Object.getOwnPropertyNames(q)), M(q) && (he.indexOf("message") >= 0 || he.indexOf("description") >= 0))
                return w(q);
              if (he.length === 0) {
                if (k(q)) {
                  var Y = q.name ? ": " + q.name : "";
                  return V.stylize("[Function" + Y + "]", "special");
                }
                if (G(q))
                  return V.stylize(RegExp.prototype.toString.call(q), "regexp");
                if (Q(q))
                  return V.stylize(Date.prototype.toString.call(q), "date");
                if (M(q))
                  return w(q);
              }
              var se = "", Te = !1, Oe = ["{", "}"];
              if (C(q) && (Te = !0, Oe = ["[", "]"]), k(q)) {
                var B = q.name ? ": " + q.name : "";
                se = " [Function" + B + "]";
              }
              if (G(q) && (se = " " + RegExp.prototype.toString.call(q)), Q(q) && (se = " " + Date.prototype.toUTCString.call(q)), M(q) && (se = " " + w(q)), he.length === 0 && (!Te || q.length == 0))
                return Oe[0] + se + Oe[1];
              if (ee < 0)
                return G(q) ? V.stylize(RegExp.prototype.toString.call(q), "regexp") : V.stylize("[Object]", "special");
              V.seen.push(q);
              var U;
              return Te ? U = x(V, q, ee, W, he) : U = he.map(function(_) {
                return E(V, q, ee, W, _, Te);
              }), V.seen.pop(), T(U, se, Oe);
            }
            function b(V, q) {
              if (H(q))
                return V.stylize("undefined", "undefined");
              if (O(q)) {
                var ee = "'" + JSON.stringify(q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return V.stylize(ee, "string");
              }
              if (N(q))
                return V.stylize("" + q, "number");
              if (R(q))
                return V.stylize("" + q, "boolean");
              if (A(q))
                return V.stylize("null", "null");
            }
            function w(V) {
              return "[" + Error.prototype.toString.call(V) + "]";
            }
            function x(V, q, ee, ue, ge) {
              for (var he = [], W = 0, Y = q.length; W < Y; ++W)
                z(q, String(W)) ? he.push(E(
                  V,
                  q,
                  ee,
                  ue,
                  String(W),
                  !0
                )) : he.push("");
              return ge.forEach(function(se) {
                se.match(/^\d+$/) || he.push(E(
                  V,
                  q,
                  ee,
                  ue,
                  se,
                  !0
                ));
              }), he;
            }
            function E(V, q, ee, ue, ge, he) {
              var W, Y, se;
              if (se = Object.getOwnPropertyDescriptor(q, ge) || { value: q[ge] }, se.get ? se.set ? Y = V.stylize("[Getter/Setter]", "special") : Y = V.stylize("[Getter]", "special") : se.set && (Y = V.stylize("[Setter]", "special")), z(ue, ge) || (W = "[" + ge + "]"), Y || (V.seen.indexOf(se.value) < 0 ? (A(ee) ? Y = f(V, se.value, null) : Y = f(V, se.value, ee - 1), Y.indexOf(`
`) > -1 && (he ? Y = Y.split(`
`).map(function(Te) {
                return "  " + Te;
              }).join(`
`).slice(2) : Y = `
` + Y.split(`
`).map(function(Te) {
                return "   " + Te;
              }).join(`
`))) : Y = V.stylize("[Circular]", "special")), H(W)) {
                if (he && ge.match(/^\d+$/))
                  return Y;
                W = JSON.stringify("" + ge), W.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (W = W.slice(1, -1), W = V.stylize(W, "name")) : (W = W.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), W = V.stylize(W, "string"));
              }
              return W + ": " + Y;
            }
            function T(V, q, ee) {
              var ue = V.reduce(function(ge, he) {
                return he.indexOf(`
`) >= 0, ge + he.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              return ue > 60 ? ee[0] + (q === "" ? "" : q + `
 `) + " " + V.join(`,
  `) + " " + ee[1] : ee[0] + q + " " + V.join(", ") + " " + ee[1];
            }
            n.types = r("./support/types");
            function C(V) {
              return Array.isArray(V);
            }
            n.isArray = C;
            function R(V) {
              return typeof V == "boolean";
            }
            n.isBoolean = R;
            function A(V) {
              return V === null;
            }
            n.isNull = A;
            function j(V) {
              return V == null;
            }
            n.isNullOrUndefined = j;
            function N(V) {
              return typeof V == "number";
            }
            n.isNumber = N;
            function O(V) {
              return typeof V == "string";
            }
            n.isString = O;
            function D(V) {
              return typeof V == "symbol";
            }
            n.isSymbol = D;
            function H(V) {
              return V === void 0;
            }
            n.isUndefined = H;
            function G(V) {
              return X(V) && ne(V) === "[object RegExp]";
            }
            n.isRegExp = G, n.types.isRegExp = G;
            function X(V) {
              return typeof V == "object" && V !== null;
            }
            n.isObject = X;
            function Q(V) {
              return X(V) && ne(V) === "[object Date]";
            }
            n.isDate = Q, n.types.isDate = Q;
            function M(V) {
              return X(V) && (ne(V) === "[object Error]" || V instanceof Error);
            }
            n.isError = M, n.types.isNativeError = M;
            function k(V) {
              return typeof V == "function";
            }
            n.isFunction = k;
            function $(V) {
              return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || // ES6 symbol
              typeof V > "u";
            }
            n.isPrimitive = $, n.isBuffer = r("./support/isBuffer");
            function ne(V) {
              return Object.prototype.toString.call(V);
            }
            function te(V) {
              return V < 10 ? "0" + V.toString(10) : V.toString(10);
            }
            var de = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function ae() {
              var V = /* @__PURE__ */ new Date(), q = [
                te(V.getHours()),
                te(V.getMinutes()),
                te(V.getSeconds())
              ].join(":");
              return [V.getDate(), de[V.getMonth()], q].join(" ");
            }
            n.log = function() {
              console.log("%s - %s", ae(), n.format.apply(n, arguments));
            }, n.inherits = r("inherits"), n._extend = function(V, q) {
              if (!q || !X(q)) return V;
              for (var ee = Object.keys(q), ue = ee.length; ue--; )
                V[ee[ue]] = q[ee[ue]];
              return V;
            };
            function z(V, q) {
              return Object.prototype.hasOwnProperty.call(V, q);
            }
            var Z = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
            n.promisify = function(q) {
              if (typeof q != "function")
                throw new TypeError('The "original" argument must be of type Function');
              if (Z && q[Z]) {
                var ee = q[Z];
                if (typeof ee != "function")
                  throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(ee, Z, {
                  value: ee,
                  enumerable: !1,
                  writable: !1,
                  configurable: !0
                }), ee;
              }
              function ee() {
                for (var ue, ge, he = new Promise(function(se, Te) {
                  ue = se, ge = Te;
                }), W = [], Y = 0; Y < arguments.length; Y++)
                  W.push(arguments[Y]);
                W.push(function(se, Te) {
                  se ? ge(se) : ue(Te);
                });
                try {
                  q.apply(this, W);
                } catch (se) {
                  ge(se);
                }
                return he;
              }
              return Object.setPrototypeOf(ee, Object.getPrototypeOf(q)), Z && Object.defineProperty(ee, Z, {
                value: ee,
                enumerable: !1,
                writable: !1,
                configurable: !0
              }), Object.defineProperties(
                ee,
                a(q)
              );
            }, n.promisify.custom = Z;
            function oe(V, q) {
              if (!V) {
                var ee = new Error("Promise was rejected with a falsy value");
                ee.reason = V, V = ee;
              }
              return q(V);
            }
            function ye(V) {
              if (typeof V != "function")
                throw new TypeError('The "original" argument must be of type Function');
              function q() {
                for (var ee = [], ue = 0; ue < arguments.length; ue++)
                  ee.push(arguments[ue]);
                var ge = ee.pop();
                if (typeof ge != "function")
                  throw new TypeError("The last argument must be of type Function");
                var he = this, W = function() {
                  return ge.apply(he, arguments);
                };
                V.apply(this, ee).then(
                  function(Y) {
                    i.nextTick(W.bind(null, null, Y));
                  },
                  function(Y) {
                    i.nextTick(oe.bind(null, Y, W));
                  }
                );
              }
              return Object.setPrototypeOf(q, Object.getPrototypeOf(V)), Object.defineProperties(
                q,
                a(V)
              ), q;
            }
            n.callbackify = ye;
          }).call(this);
        }).call(this, r("_process"));
      }, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(r, o, n) {
        (function(i) {
          (function() {
            var a = r("for-each"), s = r("available-typed-arrays"), c = r("call-bind/callBound"), p = r("gopd"), l = c("Object.prototype.toString"), d = r("has-tostringtag/shams")(), u = typeof globalThis > "u" ? i : globalThis, h = s(), y = c("String.prototype.slice"), f = {}, b = Object.getPrototypeOf;
            d && p && b && a(h, function(E) {
              if (typeof u[E] == "function") {
                var T = new u[E]();
                if (Symbol.toStringTag in T) {
                  var C = b(T), R = p(C, Symbol.toStringTag);
                  if (!R) {
                    var A = b(C);
                    R = p(A, Symbol.toStringTag);
                  }
                  f[E] = R.get;
                }
              }
            });
            var w = function(T) {
              var C = !1;
              return a(f, function(R, A) {
                if (!C)
                  try {
                    var j = R.call(T);
                    j === A && (C = j);
                  } catch {
                  }
              }), C;
            }, x = r("is-typed-array");
            o.exports = function(T) {
              return x(T) ? !d || !(Symbol.toStringTag in T) ? y(l(T), 8, -1) : w(T) : !1;
            };
          }).call(this);
        }).call(this, typeof Yt < "u" ? Yt : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
    });
  }(vl)), vl.exports;
}
var Wd = DR();
const BR = ({
  file: e,
  meta: t,
  referencePoint: r,
  selected: o = !1
}) => {
  const { client: n, project: i } = vi(), [a, s] = Rt(!1), [c, p] = Rt(!1), l = ft(
    (x) => {
      const { address: E, color: T } = x, { lod: C, coordinate: R } = E;
      return new Promise(async (A, j) => {
        const N = new Wd.PNG(), O = `${R.x}-${R.y}-${R.z}`, D = {
          contractId: i.contractId,
          contractFileId: e.id,
          level: C,
          addr: O
        }, H = await (n == null ? void 0 : n.getContractFileImagePosition(D));
        if (H === void 0) {
          j(new Error("Failed to load PNG buffer"));
          return;
        }
        const G = N.parse(H);
        G.on("parsed", async () => {
          if (T) {
            const X = await (n == null ? void 0 : n.getContractFileImageColor(D));
            if (X === void 0) {
              j(new Error("Failed to load PNG buffer"));
              return;
            }
            const M = new Wd.PNG().parse(X);
            M.on("parsed", () => {
              A({
                position: G,
                color: M
              });
            });
          } else
            A({
              position: G
            });
        });
      });
    },
    [n, i, e]
  );
  Xt(() => {
    (async () => {
      if ((t == null ? void 0 : t.version) !== void 0)
        try {
          const {
            position: { data: x }
          } = await l({
            address: {
              lod: 0,
              coordinate: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }), { length: E } = x, T = Array.from({ length: E / 4 }).some((C, R) => {
            const A = x[R * 4 + 3];
            return A !== 0 && A !== 255;
          });
          p(T);
        } catch (x) {
          console.warn(x);
        }
      s(!0);
    })();
  }, [t, l]);
  const d = kt(() => {
    if (r === void 0) return t;
    const { min: x, max: E } = t.bounds, T = new Qe().fromArray(x).add(r), C = new Qe().fromArray(E).add(r);
    return {
      ...t,
      bounds: {
        min: T.toArray(),
        max: C.toArray()
      }
    };
  }, [t, r]), u = ft(
    (x) => {
      const E = r ?? new Qe();
      return LR(x).map((C) => (C.position.add(E), C));
    },
    [r]
  ), h = kt(() => dt.scale("Spectral"), []), y = ft(
    (x) => {
      const E = h(x), [T, C, R] = E.rgb(!1);
      return [T / 255, C / 255, R / 255];
    },
    [h]
  ), f = ft(
    ({ point: x }) => {
      const { color: E } = x;
      let T;
      if (E !== void 0) {
        const { r: C, g: R, b: A, a: j } = E;
        c ? T = y(j / 255) : T = [C / 255, R / 255, A / 255];
      } else
        T = [1, 1, 1];
      if (o) {
        const C = [0.12941176470588237, 0.5882352941176471, 0.9529411764705882], R = 0.3;
        return [
          T[0] * (1 - R) + C[0] * R,
          T[1] * (1 - R) + C[1] * R,
          T[2] * (1 - R) + C[2] * R
        ];
      }
      return T;
    },
    [y, c, o]
  ), b = kt(() => {
    const x = t.bounds, E = x.max[0] - x.min[0], T = x.max[1] - x.min[1], C = x.max[2] - x.min[2];
    return $R({ size: { x: E, y: T, z: C } });
  }, [t]), w = kt(() => (b ?? 1) * 0.1, [b]);
  return a ? /* @__PURE__ */ _e.jsx(
    FR,
    {
      frustumCulled: !1,
      meta: d,
      loader: l,
      parser: u,
      pointColorHandler: f,
      pointSize: b,
      minPointSize: w
    }
  ) : null;
};
function $R(e) {
  const { x: t, y: r, z: o } = e.size, { min: n, max: i } = e, s = Math.max(t, r, o) / 128 * 3;
  return Math.min(Math.max(n ?? s, s), i ?? s);
}
const UR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add"), zR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m3-8c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3"
}), "Adjust"), HR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4m-7 7H3v4c0 1.1.9 2 2 2h4v-2H5zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2m0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2z"
}), "CenterFocusStrong"), WR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close"), VR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm7 7V3.5L18.5 9z"
}), "InsertDriveFile"), ZR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "MoreHoriz"), qR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
}), "Save"), YR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"
}), "Visibility"), GR = Zr(/* @__PURE__ */ _e.jsx("path", {
  d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7M2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2m4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3z"
}), "VisibilityOff"), KR = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  maxHeight: "calc(100% - 40px)",
  width: 600,
  bgcolor: "background.paper",
  boxShadow: 12,
  borderRadius: 4,
  p: 4,
  overflowY: "auto"
}, XR = (e) => {
  const { children: t, boxSx: r, ...o } = e;
  return /* @__PURE__ */ _e.jsx(Qc, { ...o, children: /* @__PURE__ */ _e.jsx(fr, { component: "div", sx: { ...KR, ...r }, children: t }) });
}, QR = ({
  value: e,
  onChange: t
}) => {
  const r = kt(
    () => [
      {
        label: "スキャン番号",
        key: "no"
      },
      {
        label: "取得時間",
        key: "time"
      },
      {
        label: "取得方法",
        key: "method"
      },
      {
        label: "利用機器",
        key: "equipment"
      },
      {
        label: "作業者",
        key: "person"
      },
      {
        label: "対象構造物",
        key: "crs"
      }
    ],
    []
  ), o = ft(
    (n, i) => {
      t == null || t({
        key: i,
        value: n.target.value
      });
    },
    [t]
  );
  return /* @__PURE__ */ _e.jsxs(
    Ai,
    {
      sx: {
        marginBottom: 3,
        width: 1
      },
      children: [
        /* @__PURE__ */ _e.jsx(
          Es,
          {
            id: "file-variant",
            sx: {
              fontWeight: "bold",
              marginBottom: 1
            },
            children: "施工現場情報"
          }
        ),
        r.map((n) => /* @__PURE__ */ _e.jsx(
          ei,
          {
            id: `point-cloud-attribute-${n.key}`,
            size: "small",
            label: n.label,
            value: (e == null ? void 0 : e[n.key]) ?? "",
            onChange: (i) => o(i, n.key),
            sx: {
              marginBottom: 1
            }
          },
          `point-cloud-attribute-${n.key}`
        ))
      ]
    }
  );
}, JR = (e) => {
  const { client: t } = vi(), { contractId: r, onUploaded: o, ...n } = e, i = xr(null), [a, s] = Rt(null), [c, p] = Rt(!1), [l, d] = Rt(""), [u, h] = Rt({}), y = kt(() => ".las,.laz,.csv,.txt,.xyz,.e57", []), f = ft(
    (w) => {
      const { files: x } = w.target;
      if (x !== null) {
        const E = Array.from(x);
        if (E.length > 10) {
          d("アップロードできるファイル数は10個までです");
          return;
        }
        d(""), s(E[0]);
      }
    },
    []
  ), b = ft(() => {
    a !== null && (p(!0), a.arrayBuffer().then((w) => t == null ? void 0 : t.uploadContractFile({
      contractId: r,
      name: a.name,
      buffer: w,
      pointCloudAttribute: u
    })).then((w) => {
      w !== void 0 && (o == null || o(w));
    }).catch((w) => {
      console.error(w);
    }).finally(() => {
      p(!1);
    }));
  }, [r, t, a, u, o]);
  return /* @__PURE__ */ _e.jsx(XR, { ...n, children: /* @__PURE__ */ _e.jsx(
    fr,
    {
      component: "div",
      sx: {
        width: 1,
        height: 1
      },
      children: c ? /* @__PURE__ */ _e.jsx(
        fr,
        {
          component: "div",
          sx: {
            width: 1,
            height: 1,
            flexDirection: "column"
          },
          display: "flex",
          children: /* @__PURE__ */ _e.jsx(
            Fr,
            {
              variant: "h6",
              sx: {
                fontWeight: "bold",
                marginBottom: 3
              },
              children: "ファイルをアップロードしています"
            }
          )
        }
      ) : /* @__PURE__ */ _e.jsxs(
        fr,
        {
          component: "div",
          display: "flex",
          flexDirection: "column",
          gap: 1,
          sx: {
            width: 1,
            height: 1
          },
          children: [
            /* @__PURE__ */ _e.jsx(
              Fr,
              {
                variant: "h6",
                sx: {
                  fontWeight: "bold",
                  marginBottom: 2
                },
                children: "ファイルをアップロードする"
              }
            ),
            /* @__PURE__ */ _e.jsxs(Ai, { children: [
              /* @__PURE__ */ _e.jsx(
                Es,
                {
                  id: "file-uploading",
                  sx: {
                    fontWeight: "bold",
                    marginBottom: 1
                  },
                  children: "ファイルを選択する"
                }
              ),
              /* @__PURE__ */ _e.jsx(
                fi,
                {
                  variant: "outlined",
                  startIcon: /* @__PURE__ */ _e.jsx(UR, {}),
                  sx: {
                    width: "auto"
                  },
                  onClick: () => {
                    var w;
                    (w = i.current) == null || w.click();
                  },
                  children: "ファイルを選択する"
                }
              ),
              /* @__PURE__ */ _e.jsx(
                "input",
                {
                  multiple: !1,
                  type: "file",
                  accept: y,
                  onChange: f,
                  style: { display: "none" },
                  ref: i
                }
              ),
              /* @__PURE__ */ _e.jsx(Jc, { error: !0, children: l })
            ] }),
            a !== null && /* @__PURE__ */ _e.jsxs(fr, { width: 1, children: [
              /* @__PURE__ */ _e.jsx(
                Fr,
                {
                  variant: "body1",
                  sx: {
                    marginRight: 1
                  },
                  children: a.name
                }
              ),
              /* @__PURE__ */ _e.jsx(
                QR,
                {
                  value: u,
                  onChange: (w) => {
                    h((x) => ({
                      ...x,
                      [w.key]: w.value
                    }));
                  }
                }
              )
            ] }),
            /* @__PURE__ */ _e.jsx(
              fr,
              {
                component: "div",
                sx: {
                  width: 1,
                  marginTop: 1,
                  textAlign: "right"
                },
                children: /* @__PURE__ */ _e.jsx(
                  fi,
                  {
                    variant: "contained",
                    onClick: b,
                    disabled: a === null,
                    children: "アップロードする"
                  }
                )
              }
            )
          ]
        }
      )
    }
  ) });
}, eO = ({ contractId: e, onUploaded: t }) => {
  const r = ti.useSelector((p) => p), o = ti.useActorRef(), [n, i] = Rt({
    file: !1
  }), a = ft(
    (p) => () => {
      i((l) => ({ ...l, [p]: !1 }));
    },
    []
  ), s = kt(() => [
    {
      icon: /* @__PURE__ */ _e.jsx(VR, {}),
      text: "ファイル",
      onClick: () => {
        i({ file: !0 }), o.send({ type: "IDLE" });
      }
    },
    /*
    {
      icon: <Palette />,
      text: "外観",
      selected: state.matches("appearance"),
    },
    */
    {
      icon: /* @__PURE__ */ _e.jsx(zR, {}),
      text: "基準点",
      selected: r.matches("reference_point"),
      onClick: () => {
        r.matches("reference_point") ? o.send({ type: "IDLE" }) : o.send({ type: "REFERENCE_POINT" });
      }
    }
    /*
    {
      icon: <OpenWith />,
      text: "移動",
      selected: state.matches("transform.position"),
    },
    {
      icon: <RotateLeft />,
      text: "回転",
      selected: state.matches("transform.rotation"),
    },
    {
      icon: <SquareFoot />,
      text: "寸法",
      selected: state.matches("metric"),
    },
    {
      icon: <ThreeDRotation />,
      text: "モデリング",
      selected: state.matches("modeling"),
    },
    */
  ], [r, o]), c = ft(() => {
    t == null || t(), a("file")();
  }, [t, a]);
  return /* @__PURE__ */ _e.jsxs(
    ki,
    {
      dense: !0,
      sx: {
        flex: "0 0 auto"
      },
      children: [
        s.map((p, l) => /* @__PURE__ */ _e.jsxs(nu, { onClick: p.onClick, selected: p.selected, children: [
          /* @__PURE__ */ _e.jsx(Jh, { children: p.icon }),
          /* @__PURE__ */ _e.jsx(ey, { primary: p.text })
        ] }, l)),
        /* @__PURE__ */ _e.jsx(
          JR,
          {
            contractId: e,
            open: n.file ?? !1,
            onUploaded: c,
            onClose: a("file")
          }
        )
      ]
    }
  );
}, tO = ({ point: e }) => /* @__PURE__ */ _e.jsxs(
  fr,
  {
    component: "div",
    sx: {
      display: "inline-flex",
      alignItems: "center",
      alignContent: "center",
      pointerEvents: "none",
      userSelect: "none"
    },
    children: [
      /* @__PURE__ */ _e.jsx(
        Fr,
        {
          variant: "caption",
          sx: {
            marginRight: 1,
            marginTop: "2px"
          },
          children: "基準点"
        }
      ),
      /* @__PURE__ */ _e.jsxs(
        "code",
        {
          style: {
            fontSize: "0.75em"
          },
          children: [
            "(",
            _l(e.x),
            ", ",
            _l(e.y),
            ", ",
            _l(e.z),
            ")"
          ]
        }
      )
    ]
  }
), _l = (e) => Math.floor(e * 10) / 10, rO = ({
  onFileFocus: e,
  onFileDelete: t
}) => {
  const { client: r, project: o } = vi(), { toggleVisibility: n, containers: i } = lc(), [a, s] = Rt(null), c = a !== null, p = ft(
    (u, h) => {
      s({ el: u, container: h });
    },
    []
  ), l = ft(() => {
    s(null);
  }, []), d = ft(
    (u) => {
      const { id: h } = u;
      o === void 0 || h === void 0 || r == null || r.getContractFileDownloadUrl(o.contractId, h).then((y) => {
        const { presignedURL: f } = y;
        f !== void 0 && window.open(f, "_blank");
      });
    },
    [r, o]
  );
  return /* @__PURE__ */ _e.jsxs(_e.Fragment, { children: [
    i.map((u) => {
      const { file: h, visible: y } = u;
      return /* @__PURE__ */ _e.jsxs(Ua, { children: [
        /* @__PURE__ */ _e.jsx(Fr, { variant: "body2", marginRight: 2, children: h.name }),
        /* @__PURE__ */ _e.jsxs(fr, { children: [
          /* @__PURE__ */ _e.jsx(ba, { title: "ファイルを表示", disableInteractive: !0, children: /* @__PURE__ */ _e.jsx(
            ya,
            {
              size: "small",
              onClick: () => {
                n(u);
              },
              children: y ? /* @__PURE__ */ _e.jsx(YR, {}) : /* @__PURE__ */ _e.jsx(GR, {})
            }
          ) }),
          /* @__PURE__ */ _e.jsx(ba, { title: "ファイルの中心に移動", disableInteractive: !0, children: /* @__PURE__ */ _e.jsx(
            ya,
            {
              size: "small",
              disabled: !y,
              onClick: () => {
                e(h);
              },
              children: /* @__PURE__ */ _e.jsx(HR, {})
            }
          ) }),
          /* @__PURE__ */ _e.jsx(ba, { title: "ファイルの詳細", children: /* @__PURE__ */ _e.jsx(
            ya,
            {
              size: "small",
              onClick: (f) => {
                p(f.currentTarget, u);
              },
              children: /* @__PURE__ */ _e.jsx(ZR, {})
            }
          ) })
        ] })
      ] }, h.id);
    }),
    /* @__PURE__ */ _e.jsx(ru, { anchorEl: a == null ? void 0 : a.el, open: c, onClose: l, children: /* @__PURE__ */ _e.jsxs(ki, { dense: !0, children: [
      /* @__PURE__ */ _e.jsx(
        nu,
        {
          onClick: () => {
            a !== null && d(a.container.file);
          },
          children: "ダウンロード"
        }
      ),
      // eslint-disable-next-line no-constant-binary-expression
      !1
    ] }) })
  ] });
}, nO = () => {
  const e = ti.useActorRef(), { point: t, change: r, save: o } = qa(), n = ft(
    (s) => (c) => {
      const {
        target: { value: p }
      } = c, l = Number(p);
      if (!Number.isNaN(l)) {
        const d = t.clone();
        d.setComponent(s, l), r(d);
      }
    },
    [t, r]
  ), i = ft(() => {
    o(t);
  }, [t, o]), a = ft(() => {
    e.send({ type: "IDLE" });
  }, [e]);
  return /* @__PURE__ */ _e.jsx(
    fr,
    {
      component: "div",
      sx: {
        width: 1,
        height: 1
      },
      children: /* @__PURE__ */ _e.jsxs(eu, { children: [
        /* @__PURE__ */ _e.jsx(Ua, { children: /* @__PURE__ */ _e.jsxs(
          Ai,
          {
            sx: {
              width: 1
            },
            children: [
              /* @__PURE__ */ _e.jsx(
                ei,
                {
                  id: "x",
                  label: "X",
                  size: "small",
                  fullWidth: !0,
                  sx: {
                    marginBottom: 1
                  },
                  type: "number",
                  value: t.x,
                  onChange: n(0)
                }
              ),
              /* @__PURE__ */ _e.jsx(
                ei,
                {
                  id: "y",
                  label: "Y",
                  size: "small",
                  fullWidth: !0,
                  sx: {
                    marginBottom: 1
                  },
                  type: "number",
                  value: t.y,
                  onChange: n(1)
                }
              ),
              /* @__PURE__ */ _e.jsx(
                ei,
                {
                  id: "z",
                  label: "Z",
                  size: "small",
                  fullWidth: !0,
                  type: "number",
                  value: t.z,
                  onChange: n(2)
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ _e.jsxs(Ua, { sx: { display: "flex", flexDirection: "column" }, children: [
          /* @__PURE__ */ _e.jsx(
            fi,
            {
              sx: { marginBottom: 1 },
              variant: "contained",
              fullWidth: !0,
              startIcon: /* @__PURE__ */ _e.jsx(qR, {}),
              onClick: i,
              children: "保存"
            }
          ),
          /* @__PURE__ */ _e.jsx(
            fi,
            {
              variant: "outlined",
              fullWidth: !0,
              startIcon: /* @__PURE__ */ _e.jsx(WR, {}),
              onClick: a,
              children: "閉じる"
            }
          )
        ] })
      ] })
    }
  );
}, oO = ({ onFileFocus: e, onFileDelete: t }) => {
  const r = ti.useSelector((o) => o);
  return /* @__PURE__ */ _e.jsx(
    ki,
    {
      dense: !0,
      sx: {
        flex: "0 0 auto"
      },
      children: r.matches("reference_point") ? /* @__PURE__ */ _e.jsx(nO, {}) : /* @__PURE__ */ _e.jsx(
        rO,
        {
          onFileFocus: e,
          onFileDelete: t
        }
      )
    }
  );
};
function sm(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: iO } = Object.prototype, { getPrototypeOf: Eu } = Object, { iterator: Cs, toStringTag: lm } = Symbol, Ps = /* @__PURE__ */ ((e) => (t) => {
  const r = iO.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kr = (e) => (e = e.toLowerCase(), (t) => Ps(t) === e), Is = (e) => (t) => typeof t === e, { isArray: Oo } = Array, yo = Is("undefined");
function Ii(e) {
  return e !== null && !yo(e) && e.constructor !== null && !yo(e.constructor) && sr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const cm = kr("ArrayBuffer");
function aO(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && cm(e.buffer), t;
}
const sO = Is("string"), sr = Is("function"), um = Is("number"), Ni = (e) => e !== null && typeof e == "object", lO = (e) => e === !0 || e === !1, Ea = (e) => {
  if (Ps(e) !== "object")
    return !1;
  const t = Eu(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(lm in e) && !(Cs in e);
}, cO = (e) => {
  if (!Ni(e) || Ii(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, uO = kr("Date"), fO = kr("File"), dO = kr("Blob"), pO = kr("FileList"), hO = (e) => Ni(e) && sr(e.pipe), yO = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || sr(e.append) && ((t = Ps(e)) === "formdata" || // detect form-data instance
  t === "object" && sr(e.toString) && e.toString() === "[object FormData]"));
}, mO = kr("URLSearchParams"), [gO, bO, vO, _O] = ["ReadableStream", "Request", "Response", "Headers"].map(kr), wO = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Li(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let o, n;
  if (typeof e != "object" && (e = [e]), Oo(e))
    for (o = 0, n = e.length; o < n; o++)
      t.call(null, e[o], o, e);
  else {
    if (Ii(e))
      return;
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), a = i.length;
    let s;
    for (o = 0; o < a; o++)
      s = i[o], t.call(null, e[s], s, e);
  }
}
function fm(e, t) {
  if (Ii(e))
    return null;
  t = t.toLowerCase();
  const r = Object.keys(e);
  let o = r.length, n;
  for (; o-- > 0; )
    if (n = r[o], t === n.toLowerCase())
      return n;
  return null;
}
const On = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, dm = (e) => !yo(e) && e !== On;
function rc() {
  const { caseless: e, skipUndefined: t } = dm(this) && this || {}, r = {}, o = (n, i) => {
    const a = e && fm(r, i) || i;
    Ea(r[a]) && Ea(n) ? r[a] = rc(r[a], n) : Ea(n) ? r[a] = rc({}, n) : Oo(n) ? r[a] = n.slice() : (!t || !yo(n)) && (r[a] = n);
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Li(arguments[n], o);
  return r;
}
const EO = (e, t, r, { allOwnKeys: o } = {}) => (Li(t, (n, i) => {
  r && sr(n) ? e[i] = sm(n, r) : e[i] = n;
}, { allOwnKeys: o }), e), SO = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), TO = (e, t, r, o) => {
  e.prototype = Object.create(t.prototype, o), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, xO = (e, t, r, o) => {
  let n, i, a;
  const s = {};
  if (t = t || {}, e == null) return t;
  do {
    for (n = Object.getOwnPropertyNames(e), i = n.length; i-- > 0; )
      a = n[i], (!o || o(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
    e = r !== !1 && Eu(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, RO = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const o = e.indexOf(t, r);
  return o !== -1 && o === r;
}, OO = (e) => {
  if (!e) return null;
  if (Oo(e)) return e;
  let t = e.length;
  if (!um(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, AO = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Eu(Uint8Array)), kO = (e, t) => {
  const o = (e && e[Cs]).call(e);
  let n;
  for (; (n = o.next()) && !n.done; ) {
    const i = n.value;
    t.call(e, i[0], i[1]);
  }
}, CO = (e, t) => {
  let r;
  const o = [];
  for (; (r = e.exec(t)) !== null; )
    o.push(r);
  return o;
}, PO = kr("HTMLFormElement"), IO = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, o, n) {
    return o.toUpperCase() + n;
  }
), Vd = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), NO = kr("RegExp"), pm = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), o = {};
  Li(r, (n, i) => {
    let a;
    (a = t(n, i, e)) !== !1 && (o[i] = a || n);
  }), Object.defineProperties(e, o);
}, LO = (e) => {
  pm(e, (t, r) => {
    if (sr(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const o = e[r];
    if (sr(o)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, jO = (e, t) => {
  const r = {}, o = (n) => {
    n.forEach((i) => {
      r[i] = !0;
    });
  };
  return Oo(e) ? o(e) : o(String(e).split(t)), r;
}, MO = () => {
}, FO = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function DO(e) {
  return !!(e && sr(e.append) && e[lm] === "FormData" && e[Cs]);
}
const BO = (e) => {
  const t = new Array(10), r = (o, n) => {
    if (Ni(o)) {
      if (t.indexOf(o) >= 0)
        return;
      if (Ii(o))
        return o;
      if (!("toJSON" in o)) {
        t[n] = o;
        const i = Oo(o) ? [] : {};
        return Li(o, (a, s) => {
          const c = r(a, n + 1);
          !yo(c) && (i[s] = c);
        }), t[n] = void 0, i;
      }
    }
    return o;
  };
  return r(e, 0);
}, $O = kr("AsyncFunction"), UO = (e) => e && (Ni(e) || sr(e)) && sr(e.then) && sr(e.catch), hm = ((e, t) => e ? setImmediate : t ? ((r, o) => (On.addEventListener("message", ({ source: n, data: i }) => {
  n === On && i === r && o.length && o.shift()();
}, !1), (n) => {
  o.push(n), On.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  sr(On.postMessage)
), zO = typeof queueMicrotask < "u" ? queueMicrotask.bind(On) : typeof process < "u" && process.nextTick || hm, HO = (e) => e != null && sr(e[Cs]), Pe = {
  isArray: Oo,
  isArrayBuffer: cm,
  isBuffer: Ii,
  isFormData: yO,
  isArrayBufferView: aO,
  isString: sO,
  isNumber: um,
  isBoolean: lO,
  isObject: Ni,
  isPlainObject: Ea,
  isEmptyObject: cO,
  isReadableStream: gO,
  isRequest: bO,
  isResponse: vO,
  isHeaders: _O,
  isUndefined: yo,
  isDate: uO,
  isFile: fO,
  isBlob: dO,
  isRegExp: NO,
  isFunction: sr,
  isStream: hO,
  isURLSearchParams: mO,
  isTypedArray: AO,
  isFileList: pO,
  forEach: Li,
  merge: rc,
  extend: EO,
  trim: wO,
  stripBOM: SO,
  inherits: TO,
  toFlatObject: xO,
  kindOf: Ps,
  kindOfTest: kr,
  endsWith: RO,
  toArray: OO,
  forEachEntry: kO,
  matchAll: CO,
  isHTMLForm: PO,
  hasOwnProperty: Vd,
  hasOwnProp: Vd,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: pm,
  freezeMethods: LO,
  toObjectSet: jO,
  toCamelCase: IO,
  noop: MO,
  toFiniteNumber: FO,
  findKey: fm,
  global: On,
  isContextDefined: dm,
  isSpecCompliantForm: DO,
  toJSONObject: BO,
  isAsyncFn: $O,
  isThenable: UO,
  setImmediate: hm,
  asap: zO,
  isIterable: HO
};
function st(e, t, r, o, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), o && (this.request = o), n && (this.response = n, this.status = n.status ? n.status : null);
}
Pe.inherits(st, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Pe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const ym = st.prototype, mm = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  mm[e] = { value: e };
});
Object.defineProperties(st, mm);
Object.defineProperty(ym, "isAxiosError", { value: !0 });
st.from = (e, t, r, o, n, i) => {
  const a = Object.create(ym);
  Pe.toFlatObject(e, a, function(l) {
    return l !== Error.prototype;
  }, (p) => p !== "isAxiosError");
  const s = e && e.message ? e.message : "Error", c = t == null && e ? e.code : t;
  return st.call(a, s, c, r, o, n), e && a.cause == null && Object.defineProperty(a, "cause", { value: e, configurable: !0 }), a.name = e && e.name || "Error", i && Object.assign(a, i), a;
};
const WO = null;
function nc(e) {
  return Pe.isPlainObject(e) || Pe.isArray(e);
}
function gm(e) {
  return Pe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Zd(e, t, r) {
  return e ? e.concat(t).map(function(n, i) {
    return n = gm(n), !r && i ? "[" + n + "]" : n;
  }).join(r ? "." : "") : t;
}
function VO(e) {
  return Pe.isArray(e) && !e.some(nc);
}
const ZO = Pe.toFlatObject(Pe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Ns(e, t, r) {
  if (!Pe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = Pe.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(f, b) {
    return !Pe.isUndefined(b[f]);
  });
  const o = r.metaTokens, n = r.visitor || l, i = r.dots, a = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && Pe.isSpecCompliantForm(t);
  if (!Pe.isFunction(n))
    throw new TypeError("visitor must be a function");
  function p(y) {
    if (y === null) return "";
    if (Pe.isDate(y))
      return y.toISOString();
    if (Pe.isBoolean(y))
      return y.toString();
    if (!c && Pe.isBlob(y))
      throw new st("Blob is not supported. Use a Buffer instead.");
    return Pe.isArrayBuffer(y) || Pe.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function l(y, f, b) {
    let w = y;
    if (y && !b && typeof y == "object") {
      if (Pe.endsWith(f, "{}"))
        f = o ? f : f.slice(0, -2), y = JSON.stringify(y);
      else if (Pe.isArray(y) && VO(y) || (Pe.isFileList(y) || Pe.endsWith(f, "[]")) && (w = Pe.toArray(y)))
        return f = gm(f), w.forEach(function(E, T) {
          !(Pe.isUndefined(E) || E === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? Zd([f], T, i) : a === null ? f : f + "[]",
            p(E)
          );
        }), !1;
    }
    return nc(y) ? !0 : (t.append(Zd(b, f, i), p(y)), !1);
  }
  const d = [], u = Object.assign(ZO, {
    defaultVisitor: l,
    convertValue: p,
    isVisitable: nc
  });
  function h(y, f) {
    if (!Pe.isUndefined(y)) {
      if (d.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + f.join("."));
      d.push(y), Pe.forEach(y, function(w, x) {
        (!(Pe.isUndefined(w) || w === null) && n.call(
          t,
          w,
          Pe.isString(x) ? x.trim() : x,
          f,
          u
        )) === !0 && h(w, f ? f.concat(x) : [x]);
      }), d.pop();
    }
  }
  if (!Pe.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function qd(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(o) {
    return t[o];
  });
}
function Su(e, t) {
  this._pairs = [], e && Ns(e, this, t);
}
const bm = Su.prototype;
bm.append = function(t, r) {
  this._pairs.push([t, r]);
};
bm.toString = function(t) {
  const r = t ? function(o) {
    return t.call(this, o, qd);
  } : qd;
  return this._pairs.map(function(n) {
    return r(n[0]) + "=" + r(n[1]);
  }, "").join("&");
};
function qO(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function vm(e, t, r) {
  if (!t)
    return e;
  const o = r && r.encode || qO;
  Pe.isFunction(r) && (r = {
    serialize: r
  });
  const n = r && r.serialize;
  let i;
  if (n ? i = n(t, r) : i = Pe.isURLSearchParams(t) ? t.toString() : new Su(t, r).toString(o), i) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
class Yd {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, o) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: o ? o.synchronous : !1,
      runWhen: o ? o.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Pe.forEach(this.handlers, function(o) {
      o !== null && t(o);
    });
  }
}
const _m = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, YO = typeof URLSearchParams < "u" ? URLSearchParams : Su, GO = typeof FormData < "u" ? FormData : null, KO = typeof Blob < "u" ? Blob : null, XO = {
  isBrowser: !0,
  classes: {
    URLSearchParams: YO,
    FormData: GO,
    Blob: KO
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Tu = typeof window < "u" && typeof document < "u", oc = typeof navigator == "object" && navigator || void 0, QO = Tu && (!oc || ["ReactNative", "NativeScript", "NS"].indexOf(oc.product) < 0), JO = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", eA = Tu && window.location.href || "http://localhost", tA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Tu,
  hasStandardBrowserEnv: QO,
  hasStandardBrowserWebWorkerEnv: JO,
  navigator: oc,
  origin: eA
}, Symbol.toStringTag, { value: "Module" })), Jt = {
  ...tA,
  ...XO
};
function rA(e, t) {
  return Ns(e, new Jt.classes.URLSearchParams(), {
    visitor: function(r, o, n, i) {
      return Jt.isNode && Pe.isBuffer(r) ? (this.append(o, r.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function nA(e) {
  return Pe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function oA(e) {
  const t = {}, r = Object.keys(e);
  let o;
  const n = r.length;
  let i;
  for (o = 0; o < n; o++)
    i = r[o], t[i] = e[i];
  return t;
}
function wm(e) {
  function t(r, o, n, i) {
    let a = r[i++];
    if (a === "__proto__") return !0;
    const s = Number.isFinite(+a), c = i >= r.length;
    return a = !a && Pe.isArray(n) ? n.length : a, c ? (Pe.hasOwnProp(n, a) ? n[a] = [n[a], o] : n[a] = o, !s) : ((!n[a] || !Pe.isObject(n[a])) && (n[a] = []), t(r, o, n[a], i) && Pe.isArray(n[a]) && (n[a] = oA(n[a])), !s);
  }
  if (Pe.isFormData(e) && Pe.isFunction(e.entries)) {
    const r = {};
    return Pe.forEachEntry(e, (o, n) => {
      t(nA(o), n, r, 0);
    }), r;
  }
  return null;
}
function iA(e, t, r) {
  if (Pe.isString(e))
    try {
      return (t || JSON.parse)(e), Pe.trim(e);
    } catch (o) {
      if (o.name !== "SyntaxError")
        throw o;
    }
  return (r || JSON.stringify)(e);
}
const ji = {
  transitional: _m,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const o = r.getContentType() || "", n = o.indexOf("application/json") > -1, i = Pe.isObject(t);
    if (i && Pe.isHTMLForm(t) && (t = new FormData(t)), Pe.isFormData(t))
      return n ? JSON.stringify(wm(t)) : t;
    if (Pe.isArrayBuffer(t) || Pe.isBuffer(t) || Pe.isStream(t) || Pe.isFile(t) || Pe.isBlob(t) || Pe.isReadableStream(t))
      return t;
    if (Pe.isArrayBufferView(t))
      return t.buffer;
    if (Pe.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (i) {
      if (o.indexOf("application/x-www-form-urlencoded") > -1)
        return rA(t, this.formSerializer).toString();
      if ((s = Pe.isFileList(t)) || o.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ns(
          s ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return i || n ? (r.setContentType("application/json", !1), iA(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || ji.transitional, o = r && r.forcedJSONParsing, n = this.responseType === "json";
    if (Pe.isResponse(t) || Pe.isReadableStream(t))
      return t;
    if (t && Pe.isString(t) && (o && !this.responseType || n)) {
      const a = !(r && r.silentJSONParsing) && n;
      try {
        return JSON.parse(t, this.parseReviver);
      } catch (s) {
        if (a)
          throw s.name === "SyntaxError" ? st.from(s, st.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Jt.classes.FormData,
    Blob: Jt.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Pe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ji.headers[e] = {};
});
const aA = Pe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), sA = (e) => {
  const t = {};
  let r, o, n;
  return e && e.split(`
`).forEach(function(a) {
    n = a.indexOf(":"), r = a.substring(0, n).trim().toLowerCase(), o = a.substring(n + 1).trim(), !(!r || t[r] && aA[r]) && (r === "set-cookie" ? t[r] ? t[r].push(o) : t[r] = [o] : t[r] = t[r] ? t[r] + ", " + o : o);
  }), t;
}, Gd = Symbol("internals");
function zo(e) {
  return e && String(e).trim().toLowerCase();
}
function Sa(e) {
  return e === !1 || e == null ? e : Pe.isArray(e) ? e.map(Sa) : String(e);
}
function lA(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let o;
  for (; o = r.exec(e); )
    t[o[1]] = o[2];
  return t;
}
const cA = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function wl(e, t, r, o, n) {
  if (Pe.isFunction(o))
    return o.call(this, t, r);
  if (n && (t = r), !!Pe.isString(t)) {
    if (Pe.isString(o))
      return t.indexOf(o) !== -1;
    if (Pe.isRegExp(o))
      return o.test(t);
  }
}
function uA(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, o) => r.toUpperCase() + o);
}
function fA(e, t) {
  const r = Pe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((o) => {
    Object.defineProperty(e, o + r, {
      value: function(n, i, a) {
        return this[o].call(this, t, n, i, a);
      },
      configurable: !0
    });
  });
}
class lr {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, o) {
    const n = this;
    function i(s, c, p) {
      const l = zo(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = Pe.findKey(n, l);
      (!d || n[d] === void 0 || p === !0 || p === void 0 && n[d] !== !1) && (n[d || c] = Sa(s));
    }
    const a = (s, c) => Pe.forEach(s, (p, l) => i(p, l, c));
    if (Pe.isPlainObject(t) || t instanceof this.constructor)
      a(t, r);
    else if (Pe.isString(t) && (t = t.trim()) && !cA(t))
      a(sA(t), r);
    else if (Pe.isObject(t) && Pe.isIterable(t)) {
      let s = {}, c, p;
      for (const l of t) {
        if (!Pe.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        s[p = l[0]] = (c = s[p]) ? Pe.isArray(c) ? [...c, l[1]] : [c, l[1]] : l[1];
      }
      a(s, r);
    } else
      t != null && i(r, t, o);
    return this;
  }
  get(t, r) {
    if (t = zo(t), t) {
      const o = Pe.findKey(this, t);
      if (o) {
        const n = this[o];
        if (!r)
          return n;
        if (r === !0)
          return lA(n);
        if (Pe.isFunction(r))
          return r.call(this, n, o);
        if (Pe.isRegExp(r))
          return r.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = zo(t), t) {
      const o = Pe.findKey(this, t);
      return !!(o && this[o] !== void 0 && (!r || wl(this, this[o], o, r)));
    }
    return !1;
  }
  delete(t, r) {
    const o = this;
    let n = !1;
    function i(a) {
      if (a = zo(a), a) {
        const s = Pe.findKey(o, a);
        s && (!r || wl(o, o[s], s, r)) && (delete o[s], n = !0);
      }
    }
    return Pe.isArray(t) ? t.forEach(i) : i(t), n;
  }
  clear(t) {
    const r = Object.keys(this);
    let o = r.length, n = !1;
    for (; o--; ) {
      const i = r[o];
      (!t || wl(this, this[i], i, t, !0)) && (delete this[i], n = !0);
    }
    return n;
  }
  normalize(t) {
    const r = this, o = {};
    return Pe.forEach(this, (n, i) => {
      const a = Pe.findKey(o, i);
      if (a) {
        r[a] = Sa(n), delete r[i];
        return;
      }
      const s = t ? uA(i) : String(i).trim();
      s !== i && delete r[i], r[s] = Sa(n), o[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return Pe.forEach(this, (o, n) => {
      o != null && o !== !1 && (r[n] = t && Pe.isArray(o) ? o.join(", ") : o);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const o = new this(t);
    return r.forEach((n) => o.set(n)), o;
  }
  static accessor(t) {
    const o = (this[Gd] = this[Gd] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function i(a) {
      const s = zo(a);
      o[s] || (fA(n, a), o[s] = !0);
    }
    return Pe.isArray(t) ? t.forEach(i) : i(t), this;
  }
}
lr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Pe.reduceDescriptors(lr.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(o) {
      this[r] = o;
    }
  };
});
Pe.freezeMethods(lr);
function El(e, t) {
  const r = this || ji, o = t || r, n = lr.from(o.headers);
  let i = o.data;
  return Pe.forEach(e, function(s) {
    i = s.call(r, i, n.normalize(), t ? t.status : void 0);
  }), n.normalize(), i;
}
function Em(e) {
  return !!(e && e.__CANCEL__);
}
function Ao(e, t, r) {
  st.call(this, e ?? "canceled", st.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Pe.inherits(Ao, st, {
  __CANCEL__: !0
});
function Sm(e, t, r) {
  const o = r.config.validateStatus;
  !r.status || !o || o(r.status) ? e(r) : t(new st(
    "Request failed with status code " + r.status,
    [st.ERR_BAD_REQUEST, st.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function dA(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function pA(e, t) {
  e = e || 10;
  const r = new Array(e), o = new Array(e);
  let n = 0, i = 0, a;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const p = Date.now(), l = o[i];
    a || (a = p), r[n] = c, o[n] = p;
    let d = i, u = 0;
    for (; d !== n; )
      u += r[d++], d = d % e;
    if (n = (n + 1) % e, n === i && (i = (i + 1) % e), p - a < t)
      return;
    const h = l && p - l;
    return h ? Math.round(u * 1e3 / h) : void 0;
  };
}
function hA(e, t) {
  let r = 0, o = 1e3 / t, n, i;
  const a = (p, l = Date.now()) => {
    r = l, n = null, i && (clearTimeout(i), i = null), e(...p);
  };
  return [(...p) => {
    const l = Date.now(), d = l - r;
    d >= o ? a(p, l) : (n = p, i || (i = setTimeout(() => {
      i = null, a(n);
    }, o - d)));
  }, () => n && a(n)];
}
const Za = (e, t, r = 3) => {
  let o = 0;
  const n = pA(50, 250);
  return hA((i) => {
    const a = i.loaded, s = i.lengthComputable ? i.total : void 0, c = a - o, p = n(c), l = a <= s;
    o = a;
    const d = {
      loaded: a,
      total: s,
      progress: s ? a / s : void 0,
      bytes: c,
      rate: p || void 0,
      estimated: p && s && l ? (s - a) / p : void 0,
      event: i,
      lengthComputable: s != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, r);
}, Kd = (e, t) => {
  const r = e != null;
  return [(o) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: o
  }), t[1]];
}, Xd = (e) => (...t) => Pe.asap(() => e(...t)), yA = Jt.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (r) => (r = new URL(r, Jt.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(Jt.origin),
  Jt.navigator && /(msie|trident)/i.test(Jt.navigator.userAgent)
) : () => !0, mA = Jt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, o, n, i, a) {
      if (typeof document > "u") return;
      const s = [`${e}=${encodeURIComponent(t)}`];
      Pe.isNumber(r) && s.push(`expires=${new Date(r).toUTCString()}`), Pe.isString(o) && s.push(`path=${o}`), Pe.isString(n) && s.push(`domain=${n}`), i === !0 && s.push("secure"), Pe.isString(a) && s.push(`SameSite=${a}`), document.cookie = s.join("; ");
    },
    read(e) {
      if (typeof document > "u") return null;
      const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
      return t ? decodeURIComponent(t[1]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function gA(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function bA(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Tm(e, t, r) {
  let o = !gA(t);
  return e && (o || r == !1) ? bA(e, t) : t;
}
const Qd = (e) => e instanceof lr ? { ...e } : e;
function jn(e, t) {
  t = t || {};
  const r = {};
  function o(p, l, d, u) {
    return Pe.isPlainObject(p) && Pe.isPlainObject(l) ? Pe.merge.call({ caseless: u }, p, l) : Pe.isPlainObject(l) ? Pe.merge({}, l) : Pe.isArray(l) ? l.slice() : l;
  }
  function n(p, l, d, u) {
    if (Pe.isUndefined(l)) {
      if (!Pe.isUndefined(p))
        return o(void 0, p, d, u);
    } else return o(p, l, d, u);
  }
  function i(p, l) {
    if (!Pe.isUndefined(l))
      return o(void 0, l);
  }
  function a(p, l) {
    if (Pe.isUndefined(l)) {
      if (!Pe.isUndefined(p))
        return o(void 0, p);
    } else return o(void 0, l);
  }
  function s(p, l, d) {
    if (d in t)
      return o(p, l);
    if (d in e)
      return o(void 0, p);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: s,
    headers: (p, l, d) => n(Qd(p), Qd(l), d, !0)
  };
  return Pe.forEach(Object.keys({ ...e, ...t }), function(l) {
    const d = c[l] || n, u = d(e[l], t[l], l);
    Pe.isUndefined(u) && d !== s || (r[l] = u);
  }), r;
}
const xm = (e) => {
  const t = jn({}, e);
  let { data: r, withXSRFToken: o, xsrfHeaderName: n, xsrfCookieName: i, headers: a, auth: s } = t;
  if (t.headers = a = lr.from(a), t.url = vm(Tm(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), s && a.set(
    "Authorization",
    "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
  ), Pe.isFormData(r)) {
    if (Jt.hasStandardBrowserEnv || Jt.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if (Pe.isFunction(r.getHeaders)) {
      const c = r.getHeaders(), p = ["content-type", "content-length"];
      Object.entries(c).forEach(([l, d]) => {
        p.includes(l.toLowerCase()) && a.set(l, d);
      });
    }
  }
  if (Jt.hasStandardBrowserEnv && (o && Pe.isFunction(o) && (o = o(t)), o || o !== !1 && yA(t.url))) {
    const c = n && i && mA.read(i);
    c && a.set(n, c);
  }
  return t;
}, vA = typeof XMLHttpRequest < "u", _A = vA && function(e) {
  return new Promise(function(r, o) {
    const n = xm(e);
    let i = n.data;
    const a = lr.from(n.headers).normalize();
    let { responseType: s, onUploadProgress: c, onDownloadProgress: p } = n, l, d, u, h, y;
    function f() {
      h && h(), y && y(), n.cancelToken && n.cancelToken.unsubscribe(l), n.signal && n.signal.removeEventListener("abort", l);
    }
    let b = new XMLHttpRequest();
    b.open(n.method.toUpperCase(), n.url, !0), b.timeout = n.timeout;
    function w() {
      if (!b)
        return;
      const E = lr.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), C = {
        data: !s || s === "text" || s === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: E,
        config: e,
        request: b
      };
      Sm(function(A) {
        r(A), f();
      }, function(A) {
        o(A), f();
      }, C), b = null;
    }
    "onloadend" in b ? b.onloadend = w : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, b.onabort = function() {
      b && (o(new st("Request aborted", st.ECONNABORTED, e, b)), b = null);
    }, b.onerror = function(T) {
      const C = T && T.message ? T.message : "Network Error", R = new st(C, st.ERR_NETWORK, e, b);
      R.event = T || null, o(R), b = null;
    }, b.ontimeout = function() {
      let T = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const C = n.transitional || _m;
      n.timeoutErrorMessage && (T = n.timeoutErrorMessage), o(new st(
        T,
        C.clarifyTimeoutError ? st.ETIMEDOUT : st.ECONNABORTED,
        e,
        b
      )), b = null;
    }, i === void 0 && a.setContentType(null), "setRequestHeader" in b && Pe.forEach(a.toJSON(), function(T, C) {
      b.setRequestHeader(C, T);
    }), Pe.isUndefined(n.withCredentials) || (b.withCredentials = !!n.withCredentials), s && s !== "json" && (b.responseType = n.responseType), p && ([u, y] = Za(p, !0), b.addEventListener("progress", u)), c && b.upload && ([d, h] = Za(c), b.upload.addEventListener("progress", d), b.upload.addEventListener("loadend", h)), (n.cancelToken || n.signal) && (l = (E) => {
      b && (o(!E || E.type ? new Ao(null, e, b) : E), b.abort(), b = null);
    }, n.cancelToken && n.cancelToken.subscribe(l), n.signal && (n.signal.aborted ? l() : n.signal.addEventListener("abort", l)));
    const x = dA(n.url);
    if (x && Jt.protocols.indexOf(x) === -1) {
      o(new st("Unsupported protocol " + x + ":", st.ERR_BAD_REQUEST, e));
      return;
    }
    b.send(i || null);
  });
}, wA = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let o = new AbortController(), n;
    const i = function(p) {
      if (!n) {
        n = !0, s();
        const l = p instanceof Error ? p : this.reason;
        o.abort(l instanceof st ? l : new Ao(l instanceof Error ? l.message : l));
      }
    };
    let a = t && setTimeout(() => {
      a = null, i(new st(`timeout ${t} of ms exceeded`, st.ETIMEDOUT));
    }, t);
    const s = () => {
      e && (a && clearTimeout(a), a = null, e.forEach((p) => {
        p.unsubscribe ? p.unsubscribe(i) : p.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((p) => p.addEventListener("abort", i));
    const { signal: c } = o;
    return c.unsubscribe = () => Pe.asap(s), c;
  }
}, EA = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let o = 0, n;
  for (; o < r; )
    n = o + t, yield e.slice(o, n), o = n;
}, SA = async function* (e, t) {
  for await (const r of TA(e))
    yield* EA(r, t);
}, TA = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: o } = await t.read();
      if (r)
        break;
      yield o;
    }
  } finally {
    await t.cancel();
  }
}, Jd = (e, t, r, o) => {
  const n = SA(e, t);
  let i = 0, a, s = (c) => {
    a || (a = !0, o && o(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: p, value: l } = await n.next();
        if (p) {
          s(), c.close();
          return;
        }
        let d = l.byteLength;
        if (r) {
          let u = i += d;
          r(u);
        }
        c.enqueue(new Uint8Array(l));
      } catch (p) {
        throw s(p), p;
      }
    },
    cancel(c) {
      return s(c), n.return();
    }
  }, {
    highWaterMark: 2
  });
}, ep = 64 * 1024, { isFunction: aa } = Pe, xA = (({ Request: e, Response: t }) => ({
  Request: e,
  Response: t
}))(Pe.global), {
  ReadableStream: tp,
  TextEncoder: rp
} = Pe.global, np = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, RA = (e) => {
  e = Pe.merge.call({
    skipUndefined: !0
  }, xA, e);
  const { fetch: t, Request: r, Response: o } = e, n = t ? aa(t) : typeof fetch == "function", i = aa(r), a = aa(o);
  if (!n)
    return !1;
  const s = n && aa(tp), c = n && (typeof rp == "function" ? /* @__PURE__ */ ((y) => (f) => y.encode(f))(new rp()) : async (y) => new Uint8Array(await new r(y).arrayBuffer())), p = i && s && np(() => {
    let y = !1;
    const f = new r(Jt.origin, {
      body: new tp(),
      method: "POST",
      get duplex() {
        return y = !0, "half";
      }
    }).headers.has("Content-Type");
    return y && !f;
  }), l = a && s && np(() => Pe.isReadableStream(new o("").body)), d = {
    stream: l && ((y) => y.body)
  };
  n && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((y) => {
    !d[y] && (d[y] = (f, b) => {
      let w = f && f[y];
      if (w)
        return w.call(f);
      throw new st(`Response type '${y}' is not supported`, st.ERR_NOT_SUPPORT, b);
    });
  });
  const u = async (y) => {
    if (y == null)
      return 0;
    if (Pe.isBlob(y))
      return y.size;
    if (Pe.isSpecCompliantForm(y))
      return (await new r(Jt.origin, {
        method: "POST",
        body: y
      }).arrayBuffer()).byteLength;
    if (Pe.isArrayBufferView(y) || Pe.isArrayBuffer(y))
      return y.byteLength;
    if (Pe.isURLSearchParams(y) && (y = y + ""), Pe.isString(y))
      return (await c(y)).byteLength;
  }, h = async (y, f) => {
    const b = Pe.toFiniteNumber(y.getContentLength());
    return b ?? u(f);
  };
  return async (y) => {
    let {
      url: f,
      method: b,
      data: w,
      signal: x,
      cancelToken: E,
      timeout: T,
      onDownloadProgress: C,
      onUploadProgress: R,
      responseType: A,
      headers: j,
      withCredentials: N = "same-origin",
      fetchOptions: O
    } = xm(y), D = t || fetch;
    A = A ? (A + "").toLowerCase() : "text";
    let H = wA([x, E && E.toAbortSignal()], T), G = null;
    const X = H && H.unsubscribe && (() => {
      H.unsubscribe();
    });
    let Q;
    try {
      if (R && p && b !== "get" && b !== "head" && (Q = await h(j, w)) !== 0) {
        let de = new r(f, {
          method: "POST",
          body: w,
          duplex: "half"
        }), ae;
        if (Pe.isFormData(w) && (ae = de.headers.get("content-type")) && j.setContentType(ae), de.body) {
          const [z, Z] = Kd(
            Q,
            Za(Xd(R))
          );
          w = Jd(de.body, ep, z, Z);
        }
      }
      Pe.isString(N) || (N = N ? "include" : "omit");
      const M = i && "credentials" in r.prototype, k = {
        ...O,
        signal: H,
        method: b.toUpperCase(),
        headers: j.normalize().toJSON(),
        body: w,
        duplex: "half",
        credentials: M ? N : void 0
      };
      G = i && new r(f, k);
      let $ = await (i ? D(G, O) : D(f, k));
      const ne = l && (A === "stream" || A === "response");
      if (l && (C || ne && X)) {
        const de = {};
        ["status", "statusText", "headers"].forEach((oe) => {
          de[oe] = $[oe];
        });
        const ae = Pe.toFiniteNumber($.headers.get("content-length")), [z, Z] = C && Kd(
          ae,
          Za(Xd(C), !0)
        ) || [];
        $ = new o(
          Jd($.body, ep, z, () => {
            Z && Z(), X && X();
          }),
          de
        );
      }
      A = A || "text";
      let te = await d[Pe.findKey(d, A) || "text"]($, y);
      return !ne && X && X(), await new Promise((de, ae) => {
        Sm(de, ae, {
          data: te,
          headers: lr.from($.headers),
          status: $.status,
          statusText: $.statusText,
          config: y,
          request: G
        });
      });
    } catch (M) {
      throw X && X(), M && M.name === "TypeError" && /Load failed|fetch/i.test(M.message) ? Object.assign(
        new st("Network Error", st.ERR_NETWORK, y, G),
        {
          cause: M.cause || M
        }
      ) : st.from(M, M && M.code, y, G);
    }
  };
}, OA = /* @__PURE__ */ new Map(), Rm = (e) => {
  let t = e && e.env || {};
  const { fetch: r, Request: o, Response: n } = t, i = [
    o,
    n,
    r
  ];
  let a = i.length, s = a, c, p, l = OA;
  for (; s--; )
    c = i[s], p = l.get(c), p === void 0 && l.set(c, p = s ? /* @__PURE__ */ new Map() : RA(t)), l = p;
  return p;
};
Rm();
const xu = {
  http: WO,
  xhr: _A,
  fetch: {
    get: Rm
  }
};
Pe.forEach(xu, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const op = (e) => `- ${e}`, AA = (e) => Pe.isFunction(e) || e === null || e === !1;
function kA(e, t) {
  e = Pe.isArray(e) ? e : [e];
  const { length: r } = e;
  let o, n;
  const i = {};
  for (let a = 0; a < r; a++) {
    o = e[a];
    let s;
    if (n = o, !AA(o) && (n = xu[(s = String(o)).toLowerCase()], n === void 0))
      throw new st(`Unknown adapter '${s}'`);
    if (n && (Pe.isFunction(n) || (n = n.get(t))))
      break;
    i[s || "#" + a] = n;
  }
  if (!n) {
    const a = Object.entries(i).map(
      ([c, p]) => `adapter ${c} ` + (p === !1 ? "is not supported by the environment" : "is not available in the build")
    );
    let s = r ? a.length > 1 ? `since :
` + a.map(op).join(`
`) : " " + op(a[0]) : "as no adapter specified";
    throw new st(
      "There is no suitable adapter to dispatch the request " + s,
      "ERR_NOT_SUPPORT"
    );
  }
  return n;
}
const Om = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: kA,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: xu
};
function Sl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Ao(null, e);
}
function ip(e) {
  return Sl(e), e.headers = lr.from(e.headers), e.data = El.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Om.getAdapter(e.adapter || ji.adapter, e)(e).then(function(o) {
    return Sl(e), o.data = El.call(
      e,
      e.transformResponse,
      o
    ), o.headers = lr.from(o.headers), o;
  }, function(o) {
    return Em(o) || (Sl(e), o && o.response && (o.response.data = El.call(
      e,
      e.transformResponse,
      o.response
    ), o.response.headers = lr.from(o.response.headers))), Promise.reject(o);
  });
}
const Am = "1.13.2", Ls = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Ls[e] = function(o) {
    return typeof o === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const ap = {};
Ls.transitional = function(t, r, o) {
  function n(i, a) {
    return "[Axios v" + Am + "] Transitional option '" + i + "'" + a + (o ? ". " + o : "");
  }
  return (i, a, s) => {
    if (t === !1)
      throw new st(
        n(a, " has been removed" + (r ? " in " + r : "")),
        st.ERR_DEPRECATED
      );
    return r && !ap[a] && (ap[a] = !0, console.warn(
      n(
        a,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(i, a, s) : !0;
  };
};
Ls.spelling = function(t) {
  return (r, o) => (console.warn(`${o} is likely a misspelling of ${t}`), !0);
};
function CA(e, t, r) {
  if (typeof e != "object")
    throw new st("options must be an object", st.ERR_BAD_OPTION_VALUE);
  const o = Object.keys(e);
  let n = o.length;
  for (; n-- > 0; ) {
    const i = o[n], a = t[i];
    if (a) {
      const s = e[i], c = s === void 0 || a(s, i, e);
      if (c !== !0)
        throw new st("option " + i + " must be " + c, st.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new st("Unknown option " + i, st.ERR_BAD_OPTION);
  }
}
const Ta = {
  assertOptions: CA,
  validators: Ls
}, Ir = Ta.validators;
class Pn {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new Yd(),
      response: new Yd()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (o) {
      if (o instanceof Error) {
        let n = {};
        Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
        const i = n.stack ? n.stack.replace(/^.+\n/, "") : "";
        try {
          o.stack ? i && !String(o.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (o.stack += `
` + i) : o.stack = i;
        } catch {
        }
      }
      throw o;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = jn(this.defaults, r);
    const { transitional: o, paramsSerializer: n, headers: i } = r;
    o !== void 0 && Ta.assertOptions(o, {
      silentJSONParsing: Ir.transitional(Ir.boolean),
      forcedJSONParsing: Ir.transitional(Ir.boolean),
      clarifyTimeoutError: Ir.transitional(Ir.boolean)
    }, !1), n != null && (Pe.isFunction(n) ? r.paramsSerializer = {
      serialize: n
    } : Ta.assertOptions(n, {
      encode: Ir.function,
      serialize: Ir.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Ta.assertOptions(r, {
      baseUrl: Ir.spelling("baseURL"),
      withXsrfToken: Ir.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let a = i && Pe.merge(
      i.common,
      i[r.method]
    );
    i && Pe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete i[y];
      }
    ), r.headers = lr.concat(a, i);
    const s = [];
    let c = !0;
    this.interceptors.request.forEach(function(f) {
      typeof f.runWhen == "function" && f.runWhen(r) === !1 || (c = c && f.synchronous, s.unshift(f.fulfilled, f.rejected));
    });
    const p = [];
    this.interceptors.response.forEach(function(f) {
      p.push(f.fulfilled, f.rejected);
    });
    let l, d = 0, u;
    if (!c) {
      const y = [ip.bind(this), void 0];
      for (y.unshift(...s), y.push(...p), u = y.length, l = Promise.resolve(r); d < u; )
        l = l.then(y[d++], y[d++]);
      return l;
    }
    u = s.length;
    let h = r;
    for (; d < u; ) {
      const y = s[d++], f = s[d++];
      try {
        h = y(h);
      } catch (b) {
        f.call(this, b);
        break;
      }
    }
    try {
      l = ip.call(this, h);
    } catch (y) {
      return Promise.reject(y);
    }
    for (d = 0, u = p.length; d < u; )
      l = l.then(p[d++], p[d++]);
    return l;
  }
  getUri(t) {
    t = jn(this.defaults, t);
    const r = Tm(t.baseURL, t.url, t.allowAbsoluteUrls);
    return vm(r, t.params, t.paramsSerializer);
  }
}
Pe.forEach(["delete", "get", "head", "options"], function(t) {
  Pn.prototype[t] = function(r, o) {
    return this.request(jn(o || {}, {
      method: t,
      url: r,
      data: (o || {}).data
    }));
  };
});
Pe.forEach(["post", "put", "patch"], function(t) {
  function r(o) {
    return function(i, a, s) {
      return this.request(jn(s || {}, {
        method: t,
        headers: o ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: a
      }));
    };
  }
  Pn.prototype[t] = r(), Pn.prototype[t + "Form"] = r(!0);
});
class Ru {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(i) {
      r = i;
    });
    const o = this;
    this.promise.then((n) => {
      if (!o._listeners) return;
      let i = o._listeners.length;
      for (; i-- > 0; )
        o._listeners[i](n);
      o._listeners = null;
    }), this.promise.then = (n) => {
      let i;
      const a = new Promise((s) => {
        o.subscribe(s), i = s;
      }).then(n);
      return a.cancel = function() {
        o.unsubscribe(i);
      }, a;
    }, t(function(i, a, s) {
      o.reason || (o.reason = new Ao(i, a, s), r(o.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (o) => {
      t.abort(o);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Ru(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
}
function PA(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function IA(e) {
  return Pe.isObject(e) && e.isAxiosError === !0;
}
const ic = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(ic).forEach(([e, t]) => {
  ic[t] = e;
});
function km(e) {
  const t = new Pn(e), r = sm(Pn.prototype.request, t);
  return Pe.extend(r, Pn.prototype, t, { allOwnKeys: !0 }), Pe.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(n) {
    return km(jn(e, n));
  }, r;
}
const Ft = km(ji);
Ft.Axios = Pn;
Ft.CanceledError = Ao;
Ft.CancelToken = Ru;
Ft.isCancel = Em;
Ft.VERSION = Am;
Ft.toFormData = Ns;
Ft.AxiosError = st;
Ft.Cancel = Ft.CanceledError;
Ft.all = function(t) {
  return Promise.all(t);
};
Ft.spread = PA;
Ft.isAxiosError = IA;
Ft.mergeConfig = jn;
Ft.AxiosHeaders = lr;
Ft.formToJSON = (e) => wm(Pe.isHTMLForm(e) ? new FormData(e) : e);
Ft.getAdapter = Om.getAdapter;
Ft.HttpStatusCode = ic;
Ft.default = Ft;
const NA = "RCDE_VIEWER_CMD", sa = (e, t, r) => Math.min(r, Math.max(t, e));
let sp = !1;
function LA() {
  sp || (sp = !0, Ft.defaults.validateStatus = () => !0, Ft.interceptors.response.use(
    (e) => e,
    (e) => {
      const t = e.response;
      return t ? Promise.resolve(t) : Promise.resolve({
        status: 0,
        statusText: "AxiosNetworkError",
        data: {
          error: "network_error",
          message: e.message ?? "Network error"
        },
        headers: {},
        config: e.config ?? {}
      });
    }
  ));
}
const jA = (e, t) => {
  const r = new Qe(1 / e.direction.x, 1 / e.direction.y, 1 / e.direction.z), o = (t.min.x - e.origin.x) * r.x, n = (t.max.x - e.origin.x) * r.x, i = (t.min.y - e.origin.y) * r.y, a = (t.max.y - e.origin.y) * r.y, s = (t.min.z - e.origin.z) * r.z, c = (t.max.z - e.origin.z) * r.z, p = Math.max(Math.max(Math.min(o, n), Math.min(i, a)), Math.min(s, c)), l = Math.min(Math.min(Math.max(o, n), Math.max(i, a)), Math.max(s, c));
  if (l < 0 || p > l)
    return null;
  const d = p > 0 ? p : l;
  return e.origin.clone().add(e.direction.clone().multiplyScalar(d));
}, MA = ({ views: e, referencePoint: t, onContractFileClick: r }) => {
  const { camera: o, gl: n } = sc(), i = kt(() => new Um(), []), a = ft((s) => {
    if (!r) return;
    const c = n.domElement.getBoundingClientRect(), p = (s.clientX - c.left) / c.width * 2 - 1, l = -((s.clientY - c.top) / c.height) * 2 + 1;
    i.setFromCamera(new qo(p, l), o);
    const d = i.ray;
    let u = null;
    for (const h of e) {
      const y = h.boundingBox.clone();
      y.translate(t);
      const f = jA(d, y);
      if (f) {
        const b = d.origin.distanceTo(f);
        (!u || b < u.distance) && (u = { view: h, distance: b });
      }
    }
    u ? r(u.view.file, u.view.boundingBox) : r(void 0, void 0);
  }, [e, t, r, o, n, i]);
  return Xt(() => {
    const s = n.domElement;
    return s.addEventListener("click", a), () => {
      s.removeEventListener("click", a);
    };
  }, [n, a]), null;
}, FA = (e) => {
  const { load: t, containers: r } = lc(), { app: o, constructionId: n, contractId: i, contractFileIds: a, r3f: s, children: c, positionOffsetComponent: p, showLeftSider: l = !0, showRightSider: d = !0, selectedFileId: u, onContractFileClick: h } = e, { initialize: y, client: f, project: b, setProject: w } = vi(), { point: x, change: E } = qa(), [T, C] = Rt([]), R = xr(null), A = xr(null), j = xr(null), [N, O] = Rt({
    pointSize: 2,
    opacity: 100
  }), D = a ? JSON.stringify(a) : void 0, H = kt(() => a, [D]);
  Xt(() => {
    LA(), y(o);
  }, [o, y]), Xt(() => {
    w({ constructionId: n, contractId: i });
  }, [n, i, w]);
  const G = ft(async () => {
    if (!(!f || !i))
      try {
        const ne = await f.getContractFileList({ contractId: i }), te = (ne == null ? void 0 : ne.contractFiles) ?? [];
        t(te, H);
      } catch (ne) {
        console.warn("[Viewer] getContractFileList threw:", ne), t([], H);
      }
  }, [f, i, H, t]);
  Xt(() => {
    f && i && G();
  }, [f, i, G]);
  const X = kt(() => ({
    fov: 40,
    position: new Qe(1, 2, 1).multiplyScalar(100),
    up: new Qe(0, 0, 1),
    near: 0.1,
    far: 1e3 * 5
  }), []);
  Xt(() => {
    if (b === void 0) return;
    const ne = r.filter((te) => te.visible).map((te) => {
      const de = te.file.id;
      return de === void 0 ? Promise.resolve(void 0) : f == null ? void 0 : f.getContractFileMetadata({ ...b, contractFileId: de }).then((ae) => {
        const z = ae, { min: Z, max: oe } = z.bounds, ye = new An(new Qe().fromArray(Z), new Qe().fromArray(oe));
        return { file: te.file, meta: z, boundingBox: ye };
      }).catch((ae) => {
        console.error(ae);
      });
    });
    Promise.all(ne).then((te) => {
      C(te.filter((de) => de !== void 0));
    });
  }, [r, b, f]);
  const Q = ft((ne) => {
    const te = T.find((ae) => ae.file.id === ne.id);
    if (!te) return;
    const de = te.boundingBox.getCenter(new Qe());
    E(de.negate());
  }, [T, E]), M = ft((ne) => {
    console.log(ne);
  }, []), k = ft(() => {
    G();
  }, [G]), $ = ft((ne, te, de) => {
    if (!ne) return;
    const ae = sa(te, 0, 5), z = sa(de, 0, 100) / 100;
    ne.traverse((Z) => {
      var ye, V;
      const oe = Z.material;
      oe && (typeof oe.size == "number" && (oe.size = ae, oe.needsUpdate = !0), oe.uniforms && (((ye = oe.uniforms.pointSize) == null ? void 0 : ye.value) !== void 0 && (oe.uniforms.pointSize.value = ae), ((V = oe.uniforms.opacity) == null ? void 0 : V.value) !== void 0 && (oe.uniforms.opacity.value = z)), typeof oe.opacity == "number" && (oe.opacity = z, z < 1 && oe.transparent !== !0 && (oe.transparent = !0), oe.needsUpdate = !0));
    });
  }, []);
  return Xt(() => {
    $(R.current, N.pointSize, N.opacity);
  }, [N, $]), Xt(() => {
    const ne = (te) => {
      var ae, z, Z, oe, ye, V;
      if (!(te != null && te.data) || te.data.channel !== NA) return;
      const de = te.data.cmd;
      if (de.type === "SET_TRANSFORM") {
        const q = R.current;
        if (!q) return;
        const { translation: ee, rotation: ue } = de.payload;
        q.position.set(ee.x, ee.y, ee.z);
        const ge = Math.PI / 180;
        q.rotation.set(ue.x * ge, ue.y * ge, ue.z * ge, "XYZ");
      } else if (de.type === "SET_APPEARANCE") {
        const q = de.payload.upAxis, ee = sa(de.payload.pointSize ?? N.pointSize, 0, 5), ue = sa(de.payload.opacity ?? N.opacity, 0, 100);
        if (O({ pointSize: ee, opacity: ue }), q) {
          const ge = A.current;
          ge && (q === "Y" ? ge.up.set(0, 1, 0) : ge.up.set(0, 0, 1), (ae = ge.updateProjectionMatrix) == null || ae.call(ge)), (Z = (z = j.current) == null ? void 0 : z.update) == null || Z.call(z);
        }
      } else if (de.type === "RESET") {
        const q = R.current;
        q && (q.position.set(0, 0, 0), q.rotation.set(0, 0, 0, "XYZ")), O({ pointSize: 2, opacity: 100 });
        const ee = A.current;
        ee && (ee.up.set(0, 0, 1), (oe = ee.updateProjectionMatrix) == null || oe.call(ee)), (V = (ye = j.current) == null ? void 0 : ye.update) == null || V.call(ye);
      }
    };
    return window.addEventListener("message", ne), () => window.removeEventListener("message", ne);
  }, [N.pointSize, N.opacity]), /* @__PURE__ */ _e.jsxs(fr, { width: 1, height: 1, display: "flex", children: [
    l && /* @__PURE__ */ _e.jsx(eO, { contractId: i, onUploaded: k }),
    /* @__PURE__ */ _e.jsxs(fr, { width: 1, height: 1, flex: 1, position: "relative", overflow: "hidden", children: [
      /* @__PURE__ */ _e.jsxs(Km, { camera: X, ...s == null ? void 0 : s.canvas, children: [
        /* @__PURE__ */ _e.jsx("perspectiveCamera", { ref: A }),
        (s == null ? void 0 : s.map) !== !1 && /* @__PURE__ */ _e.jsx(Wm, { ref: j, makeDefault: !0, screenSpacePanning: !0 }),
        (s == null ? void 0 : s.light) !== !1 && /* @__PURE__ */ _e.jsx("ambientLight", { intensity: 0.5 }),
        (s == null ? void 0 : s.grid) !== !1 && /* @__PURE__ */ _e.jsx(
          Vm,
          {
            args: [10, 10],
            quaternion: new fp().setFromAxisAngle(new Qe(1, 0, 0), Math.PI / 2),
            infiniteGrid: !0,
            followCamera: !0,
            fadeDistance: 1e3,
            cellSize: 10,
            sectionSize: 10 * 5,
            sectionColor: new up("#6f6f6f"),
            side: $m
          }
        ),
        (s == null ? void 0 : s.gizmo) !== !1 && /* @__PURE__ */ _e.jsx(Zm, { alignment: "top-right", margin: [80, 80], children: /* @__PURE__ */ _e.jsx(qm, { axisColors: ["#9d4b4b", "#2f7f4f", "#3b5b9d"], labelColor: "white" }) }),
        /* @__PURE__ */ _e.jsxs("group", { ref: R, children: [
          T.map((ne) => /* @__PURE__ */ _e.jsx(
            BR,
            {
              file: ne.file,
              meta: ne.meta,
              referencePoint: x,
              selected: ne.file.id === u
            },
            ne.file.id
          )),
          /* @__PURE__ */ _e.jsx("group", { position: x, children: p }),
          /* @__PURE__ */ _e.jsx("group", { children: c }),
          h && /* @__PURE__ */ _e.jsx(MA, { views: T, referencePoint: x, onContractFileClick: h })
        ] })
      ] }),
      /* @__PURE__ */ _e.jsx(
        fr,
        {
          component: "div",
          sx: {
            position: "absolute",
            bottom: 10,
            left: 0,
            right: 0,
            display: "flex",
            justifyContent: "center"
          },
          children: /* @__PURE__ */ _e.jsx(tO, { point: x })
        }
      )
    ] }),
    d && /* @__PURE__ */ _e.jsx(oO, { onFileFocus: Q, onFileDelete: M })
  ] });
}, nk = (e) => /* @__PURE__ */ _e.jsx(ti.Provider, { children: /* @__PURE__ */ _e.jsx(ng, { children: /* @__PURE__ */ _e.jsx(og, { children: /* @__PURE__ */ _e.jsx(ig, { children: /* @__PURE__ */ _e.jsx(FA, { ...e }) }) }) }) }), ok = ({
  length: e = 10,
  width: t = 0.2,
  visible: r = !0
}) => {
  const { point: o } = qa(), n = kt(
    () => [
      { direction: new Qe(1, 0, 0), color: "#ff0000", label: "X" },
      // Red for X
      { direction: new Qe(0, 1, 0), color: "#00ff00", label: "Y" },
      // Green for Y
      { direction: new Qe(0, 0, 1), color: "#0000ff", label: "Z" }
      // Blue for Z
    ],
    []
  );
  return r ? /* @__PURE__ */ _e.jsx("group", { position: o, children: n.map((i) => /* @__PURE__ */ _e.jsx(
    "arrowHelper",
    {
      args: [i.direction, new Qe(0, 0, 0), e, i.color, e * 0.2, t]
    },
    i.label
  )) }) : null;
}, Cm = "RCDE_VIEWER_CMD";
function Tl(e) {
  typeof window > "u" || window.postMessage({ channel: Cm, cmd: e }, "*");
}
const ik = {
  setTransform(e) {
    Tl({ type: "SET_TRANSFORM", payload: e });
  },
  setAppearance(e) {
    Tl({ type: "SET_APPEARANCE", payload: e });
  },
  reset() {
    Tl({ type: "RESET" });
  },
  addListener(e) {
    if (typeof window > "u") return () => {
    };
    const t = (r) => {
      !(r != null && r.data) || r.data.channel !== Cm || e(r.data.cmd);
    };
    return window.addEventListener("message", t), () => window.removeEventListener("message", t);
  }
}, Pm = bi({
  clippingPlanes: [],
  setClippingPlanes: () => {
  }
}), ak = ({ children: e }) => {
  const [t, r] = Rt([]);
  return /* @__PURE__ */ _e.jsx(
    Pm.Provider,
    {
      value: {
        clippingPlanes: t,
        setClippingPlanes: r
      },
      children: e
    }
  );
}, DA = () => {
  const e = mo(Pm);
  if (!e)
    throw new Error("useClippingPlanes must be used within a ClippingPlanesProvider");
  return e;
}, sk = () => {
  const [e, t] = Rt(
    new Ou().setFromNormalAndCoplanarPoint(
      new Qe(0, 0, -1),
      new Qe()
    )
  ), { setClippingPlanes: r } = DA();
  Xt(() => (r([e]), () => {
    r([]);
  }), [e, r]);
  const o = ft((n) => {
    const i = new Qe(), a = new fp();
    n.decompose(i, a, new Qe());
    const s = new Qe(0, 0, -1);
    s.applyQuaternion(a).normalize();
    const c = new Ou().setFromNormalAndCoplanarPoint(s, i);
    t(c);
  }, []);
  return /* @__PURE__ */ _e.jsx(Ym, { scale: 50, fixed: !0, disableScaling: !0, onDrag: o, children: /* @__PURE__ */ _e.jsx(BA, { size: 100 }) });
}, BA = ({ size: e, color: t = "yellow", opacity: r = 0.85 }) => {
  const o = kt(() => {
    const a = [
      new Qe(-e / 2, -e / 2, 0),
      new Qe(e / 2, -e / 2, 0),
      new Qe(e / 2, e / 2, 0),
      new Qe(-e / 2, e / 2, 0)
    ];
    return [...a, a[0]];
  }, [e]), n = kt(() => [
    new Qe(-e / 2, -e / 2, 0),
    new Qe(e / 2, e / 2, 0)
  ], [e]), i = kt(() => [
    new Qe(e / 2, -e / 2, 0),
    new Qe(-e / 2, e / 2, 0)
  ], [e]);
  return /* @__PURE__ */ _e.jsxs("group", { children: [
    /* @__PURE__ */ _e.jsx(Fs, { points: o, color: t, transparent: !0, opacity: r }),
    /* @__PURE__ */ _e.jsx(Fs, { points: n, color: t, transparent: !0, opacity: r }),
    /* @__PURE__ */ _e.jsx(Fs, { points: i, color: t, transparent: !0, opacity: r })
  ] });
}, Im = bi({
  points: [],
  setPoints: () => {
  },
  isActive: !1,
  setIsActive: () => {
  }
}), lk = ({ children: e }) => {
  const [t, r] = Rt([]), [o, n] = Rt(!1);
  return /* @__PURE__ */ _e.jsx(
    Im.Provider,
    {
      value: {
        points: t,
        setPoints: r,
        isActive: o,
        setIsActive: n
      },
      children: e
    }
  );
}, ck = () => {
  const e = mo(Im);
  if (!e)
    throw new Error("useMeasurement must be used within a MeasurementProvider");
  return e;
};
class Zo {
  constructor(t, r, o, n, i) {
    this.x = t, this.y = r, this.w = o, this.h = n, this.data = i;
  }
  contains(t) {
    return t.x >= this.x && t.x <= this.x + this.w && t.y >= this.y && t.y <= this.y + this.h;
  }
  intersects(t) {
    return !(t.x > this.x + this.w || t.x + t.w < this.x || t.y > this.y + this.h || t.y + t.h < this.y);
  }
}
class $A {
  constructor(t, r, o, n) {
    this.x = t, this.y = r, this.r = o, this.rPow2 = this.r * this.r, this.data = n;
  }
  euclideanDistancePow2(t, r) {
    return Math.pow(t.x - r.x, 2) + Math.pow(t.y - r.y, 2);
  }
  contains(t) {
    return this.euclideanDistancePow2(t, this) <= this.rPow2;
  }
  intersects(t) {
    const r = this.x - Math.max(t.x, Math.min(this.x, t.x + t.w)), o = this.y - Math.max(t.y, Math.min(this.y, t.y + t.h));
    return r * r + o * o <= this.rPow2;
  }
}
class UA {
  constructor(t, r, o) {
    this.x = t, this.y = r, this.data = o;
  }
}
const zA = { capacity: 4, removeEmptyNodes: !1, maximumDepth: -1, arePointsEqual: (e, t) => e.x === t.x && e.y === t.y };
class Qn {
  constructor(t, r, o = []) {
    this.container = t, this.config = Object.assign({}, zA, r), this.isDivided = !1, this.points = [];
    for (const n of o) this.insertRecursive(n);
  }
  getTree() {
    let t;
    return t = this.isDivided ? { ne: this.ne.getTree(), nw: this.nw.getTree(), se: this.se.getTree(), sw: this.sw.getTree() } : this.getNodePointAmount(), t;
  }
  getAllPoints() {
    const t = [];
    return this.getAllPointsRecursive(t), t;
  }
  getAllPointsRecursive(t) {
    this.isDivided ? (this.ne.getAllPointsRecursive(t), this.nw.getAllPointsRecursive(t), this.se.getAllPointsRecursive(t), this.sw.getAllPointsRecursive(t)) : Array.prototype.push.apply(t, this.points.slice());
  }
  getNodePointAmount() {
    return this.points.length;
  }
  divide() {
    const t = this.config.maximumDepth === -1 ? -1 : this.config.maximumDepth - 1, r = Object.assign({}, this.config, { maximumDepth: t });
    this.isDivided = !0;
    const o = this.container.x, n = this.container.y, i = this.container.w / 2, a = this.container.h / 2;
    this.ne = new Qn(new Zo(o + i, n, i, a), r), this.nw = new Qn(new Zo(o, n, i, a), r), this.se = new Qn(new Zo(o + i, n + a, i, a), r), this.sw = new Qn(new Zo(o, n + a, i, a), r), this.insert(this.points.slice()), this.points.length = 0, this.points = [];
  }
  remove(t) {
    if (Array.isArray(t)) for (const r of t) this.removeRecursive(r);
    else this.removeRecursive(t);
  }
  removeRecursive(t) {
    if (this.container.contains(t)) if (this.isDivided) this.ne.removeRecursive(t), this.nw.removeRecursive(t), this.se.removeRecursive(t), this.sw.removeRecursive(t), this.config.removeEmptyNodes && (this.ne.getNodePointAmount() !== 0 || this.ne.isDivided || this.nw.getNodePointAmount() !== 0 || this.nw.isDivided || this.se.getNodePointAmount() !== 0 || this.se.isDivided || this.sw.getNodePointAmount() !== 0 || this.sw.isDivided || (this.isDivided = !1, delete this.ne, delete this.nw, delete this.se, delete this.sw));
    else
      for (let r = this.points.length - 1; r >= 0; r--) this.config.arePointsEqual(t, this.points[r]) && this.points.splice(r, 1);
  }
  insert(t) {
    if (Array.isArray(t)) {
      let r = !0;
      for (const o of t) r = r && this.insertRecursive(o);
      return r;
    }
    return this.insertRecursive(t);
  }
  insertRecursive(t) {
    if (!this.container.contains(t)) return !1;
    if (!this.isDivided) {
      if (this.getNodePointAmount() < this.config.capacity || this.config.maximumDepth === 0) return this.points.push(t), !0;
      (this.config.maximumDepth === -1 || this.config.maximumDepth > 0) && this.divide();
    }
    return !!this.isDivided && (this.ne.insertRecursive(t) || this.nw.insertRecursive(t) || this.se.insertRecursive(t) || this.sw.insertRecursive(t));
  }
  query(t) {
    const r = [];
    return this.queryRecursive(t, r), r;
  }
  queryRecursive(t, r) {
    if (t.intersects(this.container)) if (this.isDivided) this.ne.queryRecursive(t, r), this.nw.queryRecursive(t, r), this.se.queryRecursive(t, r), this.sw.queryRecursive(t, r);
    else {
      const o = this.points.filter((n) => t.contains(n));
      Array.prototype.push.apply(r, o);
    }
  }
  clear() {
    this.points = [], this.isDivided = !1, delete this.ne, delete this.nw, delete this.se, delete this.sw;
  }
}
const lp = (e) => {
  const { points: t, camera: r } = e, o = new Qn(new Zo(-1, -1, 2, 2)), n = /* @__PURE__ */ new Map(), i = 1e4;
  let a = 0, s = 0;
  return t.forEach((c, p) => {
    const l = c.clone().project(r), d = Math.round(l.x * i) / i, u = Math.round(l.y * i) / i;
    if (d < -1 || d > 1 || u < -1 || u > 1) {
      s++;
      return;
    }
    const h = `${d},${u}`;
    if (!n.has(h)) {
      const y = new UA(d, u, { id: p });
      n.set(h, y), o.insert(y), a++;
    }
  }), console.log(`[Picking] buildTree: ${t.length} points, ${a} inserted, ${s} out of bounds`), {
    tree: o
  };
}, HA = (e, t, r) => {
  const o = t.query(new $A(e.x, e.y, 0.05));
  if (o.length > 0) {
    const n = WA(e, o), { id: i } = n.data;
    return r[i].clone();
  }
}, WA = (e, t) => {
  const r = t.map((n) => {
    const i = e.x - n.x, a = e.y - n.y;
    return i * i + a * a;
  }), o = Math.min(...r);
  return t[r.indexOf(o)];
}, VA = (e) => {
  const { canvas: t } = e;
  return ft(
    (r) => {
      const o = new qo(r.clientX, r.clientY), { x: n, y: i, width: a, height: s } = t.getBoundingClientRect();
      return o.sub(new qo(n, i)), new qo(
        o.x / a * 2 - 1,
        -(o.y / s) * 2 + 1
      );
    },
    [t]
  );
}, ZA = 180 / Math.PI, qA = (e, t, r) => {
  const { width: o, height: n } = e.getBoundingClientRect(), i = r.clone().project(t);
  return new Qe((i.x + 1) / 2 * o, -(i.y - 1) / 2 * n, 0);
}, YA = ({
  points: e,
  referencePoint: t,
  edit: r
}) => {
  const { camera: o } = sc(), [n, i] = Rt(null), [a, s] = Rt([]), [c, p] = Rt([]), l = xr(new dp()), d = xr(0), u = kt(() => e !== void 0 ? e : [], [e]), h = kt(() => t !== void 0 ? t : new Qe(), [t]), y = ft(
    (f) => {
      const b = u.map((C) => C.clone().add(h));
      if (console.log(`[MeasurementView] updateMetrics: pts=${u.length}, edit=${r}, div=${n !== null}`), n === null || b.length < 1) return [];
      const { width: w, height: x } = n.getBoundingClientRect();
      console.log(`[MeasurementView] div size: ${w}x${x}`);
      const E = b.map((C, R) => {
        const A = qA(n, f, C);
        return console.log(`[MeasurementView] point[${R}]: world=(${C.x.toFixed(2)}, ${C.y.toFixed(2)}, ${C.z.toFixed(2)}) -> screen=(${A.x.toFixed(2)}, ${A.y.toFixed(2)})`), A;
      });
      r ? (console.log(`[MeasurementView] setEditMetricPoints: ${E.length} points`), s(E)) : console.log("[MeasurementView] edit is false, skipping setEditMetricPoints");
      const T = Array.from(Array(E.length - 1).keys()).map(
        (C) => {
          const R = b[C], A = b[C + 1], j = R.distanceTo(A);
          return {
            from: E[C],
            to: E[C + 1],
            length: j
          };
        }
      );
      p(T);
    },
    [n, r, h, u]
  );
  return Xt(() => {
    n !== null && u.length > 0 && (console.log(`[MeasurementView] pts changed: ${u.length} points`), y(o));
  }, [u, n, o, y]), ac(({ camera: f }) => {
    const b = d.current !== u.length;
    (!l.current.equals(f.matrixWorld) || b) && n !== null && (l.current.copy(f.matrixWorld), d.current = u.length, y(f));
  }), /* @__PURE__ */ _e.jsxs(
    Gm,
    {
      as: "div",
      ref: i,
      fullscreen: !0,
      style: {
        pointerEvents: "none",
        userSelect: "none"
      },
      zIndexRange: [0, 100],
      children: [
        a.map((f, b) => /* @__PURE__ */ _e.jsx(
          GA,
          {
            position: f,
            color: "white"
          },
          `metrics-point-${b}`
        )),
        c.map((f, b) => /* @__PURE__ */ _e.jsx(KA, { ...f }, `metrics-line-${b}`))
      ]
    }
  );
}, GA = ({ position: e, color: t }) => /* @__PURE__ */ _e.jsx(
  "div",
  {
    style: {
      position: "absolute",
      left: "0px",
      right: "0px",
      top: "0px",
      bottom: "0px",
      pointerEvents: "none",
      overflow: "hidden"
    },
    children: /* @__PURE__ */ _e.jsx("svg", { width: "100%", height: "100%", children: /* @__PURE__ */ _e.jsx(
      "circle",
      {
        cx: e.x,
        cy: e.y,
        r: 5,
        fill: t,
        stroke: "black"
      }
    ) })
  }
), KA = ({ from: e, to: t, length: r }) => {
  const o = kt(() => {
    const n = t.clone().sub(e), i = n.length(), a = new Qe(n.y, -n.x, 0), s = new Qe(), c = n.clone().normalize(), p = Math.PI * 0.15, l = Math.min(i * 0.25, 10), d = 15, h = Math.min(
      1,
      (i - d) / (40 - d)
    ), y = c.clone().applyAxisAngle(new Qe(0, 0, 1), p).setLength(l), f = c.clone().applyAxisAngle(new Qe(0, 0, 1), -p).setLength(l), b = t.clone().add(s), w = b.clone().add(y.clone().negate()), x = b.clone().add(f.clone().negate()), E = e.clone().add(s), T = E.clone().add(y), C = E.clone().add(f), R = a.clone().setLength(10), A = e.clone().add(t).multiplyScalar(0.5).add(R), N = new qo(c.x, c.y).negate().angle() * ZA;
    return {
      head: b,
      tail: E,
      headLeft: w,
      headRight: x,
      tailLeft: T,
      tailRight: C,
      opacity: h,
      angle: N,
      wp: A
    };
  }, [e, t]);
  return /* @__PURE__ */ _e.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        left: "0px",
        right: "0px",
        top: "0px",
        bottom: "0px",
        pointerEvents: "none",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ _e.jsx("svg", { width: "100%", height: "100%", children: /* @__PURE__ */ _e.jsxs(
          "g",
          {
            style: {
              stroke: "white",
              strokeWidth: 2,
              mixBlendMode: "difference"
            },
            children: [
              /* @__PURE__ */ _e.jsx(
                "line",
                {
                  x1: o.head.x,
                  y1: o.head.y,
                  x2: o.tail.x,
                  y2: o.tail.y
                }
              ),
              /* @__PURE__ */ _e.jsx(
                "line",
                {
                  x1: o.head.x,
                  y1: o.head.y,
                  x2: o.headLeft.x,
                  y2: o.headLeft.y
                }
              ),
              /* @__PURE__ */ _e.jsx(
                "line",
                {
                  x1: o.head.x,
                  y1: o.head.y,
                  x2: o.headRight.x,
                  y2: o.headRight.y
                }
              ),
              /* @__PURE__ */ _e.jsx(
                "line",
                {
                  x1: o.tail.x,
                  y1: o.tail.y,
                  x2: o.tailLeft.x,
                  y2: o.tailLeft.y
                }
              ),
              /* @__PURE__ */ _e.jsx(
                "line",
                {
                  x1: o.tail.x,
                  y1: o.tail.y,
                  x2: o.tailRight.x,
                  y2: o.tailRight.y
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ _e.jsxs(
          "span",
          {
            style: {
              position: "absolute",
              left: `${o.wp.x}px`,
              top: `${o.wp.y}px`,
              transform: `translate(-50%, -50%) rotate(${o.angle}deg)`,
              color: "white",
              mixBlendMode: "difference",
              fontSize: "14px",
              fontWeight: "bold"
            },
            children: [
              r.toFixed(2),
              "m"
            ]
          }
        )
      ]
    }
  );
}, cp = (e, t = 10) => {
  const r = [];
  let o = 0;
  return e.traverse((n) => {
    if ((n.type === "Points" || n.type === "points" || n instanceof Ms) && console.log(`[MeasurementHandler] Found Points: type=${n.type}, instanceof=${n instanceof Ms}, name=${n.name}`), n instanceof Ms || n.type === "Points" || n.type === "points") {
      o++;
      const a = n.geometry.getAttribute("position");
      if (a) {
        console.log(`[MeasurementHandler] Points positions count: ${a.count}`);
        for (let s = 0; s < a.count; s += t) {
          const c = new Qe(
            a.getX(s),
            a.getY(s),
            a.getZ(s)
          );
          c.applyMatrix4(n.matrixWorld), r.push(c);
        }
      } else
        console.log("[MeasurementHandler] Points has no position attribute");
    }
  }), console.log(`[MeasurementHandler] extractPointsFromScene: found ${o} Points objects, ${r.length} total points`), r;
}, uk = ({ onChange: e }) => {
  const t = xr(null), [r, o] = Rt(null), [n, i] = Rt([]);
  qa();
  const a = xr(null), s = xr([]), c = xr(new dp()), { camera: p, gl: l, scene: d } = sc(), u = l.domElement, h = VA({ canvas: u });
  ac(() => {
    if (!c.current.equals(p.matrixWorld)) {
      c.current.copy(p.matrixWorld);
      const f = cp(d);
      if (f.length > 0) {
        s.current = f;
        const b = lp({ camera: p, points: f });
        a.current = b.tree;
      }
    }
  }), Xt(() => {
    const f = setTimeout(() => {
      const b = cp(d);
      if (b.length > 0) {
        s.current = b;
        const w = lp({ camera: p, points: b });
        a.current = w.tree;
      }
    }, 500);
    return () => clearTimeout(f);
  }, [p, d]);
  const y = ft(
    (f) => {
      if (!a.current || s.current.length === 0) {
        console.log(`[MeasurementHandler] pickPoint: tree=${!!a.current}, points=${s.current.length}`);
        return;
      }
      const b = HA(f, a.current, s.current);
      return Math.random() < 0.05 && console.log(`[MeasurementHandler] pickPoint: uv=(${f.x.toFixed(3)}, ${f.y.toFixed(3)}), result=${b ? "found" : "undefined"}`), b;
    },
    []
  );
  return Xt(() => {
    const f = (T) => {
      T.stopPropagation();
      const C = t.current;
      if (C !== null) {
        const R = [...n, C];
        i(R), e == null || e(R), t.current = null, R.length >= 2 && setTimeout(() => {
          i([]);
        }, 2e3);
      }
    }, b = (T) => {
      const C = h(T), R = y({ x: C.x, y: C.y });
      R !== void 0 && (t.current = R, o(R));
    }, w = (T) => {
      T.key === "Escape" && (i([]), o(null), t.current = null);
    }, x = (T) => {
      T.preventDefault(), T.stopPropagation(), i([]), o(null), t.current = null;
    }, E = (T) => {
      T.stopPropagation(), T.stopImmediatePropagation();
    };
    return u.addEventListener("mousedown", f, { capture: !0 }), u.addEventListener("click", E, { capture: !0 }), u.addEventListener("mousemove", b), window.addEventListener("keydown", w), u.addEventListener("contextmenu", x, { capture: !0 }), () => {
      u.removeEventListener("mousedown", f, { capture: !0 }), u.removeEventListener("click", E, { capture: !0 }), u.removeEventListener("mousemove", b), window.removeEventListener("keydown", w), u.removeEventListener("contextmenu", x, { capture: !0 });
    };
  }, [u, h, y, n, i, e]), /* @__PURE__ */ _e.jsx(
    YA,
    {
      edit: !0,
      points: r !== null ? [...n, r] : [...n]
    }
  );
};
export {
  ng as ClientProvider,
  Pm as ClippingPlanesContext,
  ak as ClippingPlanesProvider,
  BR as ContractFileView,
  og as ContractFilesProvider,
  sk as CrossSectionHandler,
  BA as CrossSectionPlane,
  ti as GlobalStateContext,
  Im as MeasurementContext,
  uk as MeasurementHandler,
  lk as MeasurementProvider,
  YA as MeasurementView,
  nk as RCDE,
  rg as RCDEClient,
  ok as ReferencePointAxis,
  ig as ReferencePointProvider,
  FA as Viewer,
  ik as ViewerBridge,
  vi as useClient,
  DA as useClippingPlanes,
  lc as useContractFiles,
  ck as useMeasurement,
  qa as useReferencePoint
};
